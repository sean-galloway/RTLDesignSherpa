@startuml axi_write_engine_pipeline
!theme plain
title AXI Write Engine - Streaming Pipeline Architecture (NO FSM!)

skinparam activity {
  BackgroundColor LightSalmon
  BorderColor DarkRed
  ArrowColor DarkRed
  ArrowFontColor Black
  ArrowFontSize 10
  DiamondBackgroundColor LightGray
  DiamondBorderColor DarkRed
}

start

note right
<b>Key Design Philosophy:</b>
<b>FSMs are HORRIBLE for performance!</b>

This design uses:
• Arbiter-granted streaming pipeline
• Flag-based control (no state machine)
• Continuous data flow when granted
• Zero-bubble operation

<b>Control Flags (not FSM states):</b>
r_aw_inflight  - Transaction in flight
r_aw_valid     - AW channel has data
r_w_active     - W channel streaming
r_b_pending    - B response pending
datawr_ready   - Can accept new request

<b>Performance:</b>
• Single outstanding transaction (v1)
• Pipelined AW/W/B channels
• No state transition delays
• Backpressure only from SRAM
end note

:Arbiter grants channel access;
note right
Scheduler requests write via:
• datawr_valid = 1
• datawr_beats_remaining = total
• datawr_addr = destination address

Arbiter grants when:
• Engine not busy (!r_aw_inflight)
• No pending AW (!r_aw_valid)
• No pending B (!r_b_pending)
end note

if (datawr_valid && datawr_ready?) then (yes)
  :Latch Request;
  note right
    r_aw_addr <= datawr_addr
    r_aw_len <= calculate_burst_len()
    r_aw_channel_id <= datawr_channel_id
    r_aw_valid <= 1
    r_aw_inflight <= 1
  end note

  :Calculate Burst Length;
  note right
    <b>Autonomous Burst Decision:</b>
    burst_len = min(
      datawr_burst_len,      // Requested
      MAX_BURST_LEN,         // Limit (16)
      datawr_beats_remaining // Remaining
    )

    Engine decides, NOT scheduler!
  end note
else (no)
  stop
endif

partition "AW Channel Streaming" {
  :Wait for m_axi_awready;
  note right
    AW transaction with:
    • m_axi_awid = {4'h0, channel_id[3:0]}
    • m_axi_awlen = burst_len - 1
    • m_axi_awsize = $clog2(DATA_WIDTH/8)
    • m_axi_awburst = INCR (2'b01)
  end note

  :m_axi_awvalid && m_axi_awready;
  :Clear r_aw_valid;
  :Set r_w_active = 1;
  note right
    AW handshake complete
    Start W channel streaming
    r_expected_beats = awlen + 1
  end note
}

partition "W Channel Streaming (CONTINUOUS)" {
  note right
    <b>Streaming Control:</b>
    m_axi_wvalid = r_w_active && sram_rd_valid
    m_axi_wdata = sram_rd_data (direct!)
    m_axi_wstrb = all 1's (aligned writes)
    m_axi_wlast = (beats_sent == expected - 1)

    <b>SRAM Read Pipeline:</b>
    sram_rd_en = r_w_active && (beats < expected)
    sram_rd_addr = r_sram_rd_ptr++

    <b>NO state machine overhead!</b>
    Data streams continuously from SRAM.
  end note

  repeat
    :Request SRAM read;
    note right: sram_rd_req = (r_beats_sent < r_expected_beats)

    :Wait for sram_rd_valid;

    :m_axi_wvalid && m_axi_wready;
    note right
      Send W data beat
      Increment beat counter
      r_beats_sent++
    end note

    if (r_beats_sent == r_expected_beats - 1?) then (yes)
      :Assert m_axi_wlast;
      :Set r_b_pending = 1;
      note right: Last beat, expect B response
    endif

  repeat while (m_axi_wlast == 0?)

  :Clear r_w_active;
}

partition "B Channel Response" {
  :Wait for m_axi_bvalid;
  note right
    <b>Streaming B Channel:</b>
    • m_axi_bready = 1 (always ready)
    • Check BRESP for errors
    • NO state machine needed!
  end note

  :m_axi_bvalid && m_axi_bready;

  if (m_axi_bresp != OKAY?) then (error)
    :Set datawr_error;
    note right
      r_error_detected <= 1
      r_error_resp <= m_axi_bresp
    end note
  endif

  :Clear r_b_pending;
  :Clear r_aw_inflight;
}

:Assert datawr_done_strobe;
note right
<b>Completion Reporting:</b>
• datawr_done_strobe = 1 (single cycle)
• datawr_beats_done = r_expected_beats
• Ready for next request!

<b>No state transition overhead!</b>
Can accept new request IMMEDIATELY.
end note

:Generate MonBus packet;
note right
  Monitor packet with:
  • Event: WRITE_COMPLETE
  • Channel ID from AWID
  • Beats transferred
  • Timestamp
end note

if (datawr_beats_remaining > 0?) then (yes)
  :Continue transfer;
  note right
    Scheduler decrements beats_remaining
    and re-issues datawr_valid.
    Engine immediately accepts!
  end note
  detach
else (no)
  :Transfer complete;
  stop
endif

note bottom
<b>Pipeline Flow Diagram - NOT FSM!</b>

<b>Key Differences from FSM Approach:</b>

<b>FSM (OLD - NOT USED):</b>
IDLE → ISSUE_AW → STREAM_W → WAIT_B → COMPLETE → IDLE
• State transitions add latency
• Bubbles between transactions
• Complex state tracking
• Cannot overlap AW/W/B channels

<b>Streaming Pipeline (ACTUAL RTL):</b>
Request → AW Stream → W Stream (parallel!) → B Stream → Complete
• Flag-based control (r_aw_inflight, r_aw_valid, r_w_active, r_b_pending)
• Zero bubbles (continuous flow)
• Immediate ready after completion
• AW/W channels can pipeline

<b>Performance Advantage:</b>
Streaming pipeline achieves near-100% bus utilization
by eliminating state machine transition overhead and
allowing AW/W channel pipelining.

<b>Backpressure Handling:</b>
• SRAM empty: sram_rd_valid = 0 → m_axi_wvalid = 0
• AXI slave not ready: m_axi_wready = 0
• Engine pauses data transfer automatically
• NO state machine needed!

<b>Actual RTL Flags (axi_write_engine.sv lines 171-200):</b>

assign datawr_ready = !r_aw_inflight && !r_aw_valid && !r_b_pending;

// Accept new request when ready
if (datawr_valid && datawr_ready) begin
    r_aw_addr <= datawr_addr;
    r_aw_len <= w_capped_burst_len;
    r_aw_channel_id <= datawr_channel_id;
    r_aw_valid <= 1'b1;
    r_aw_inflight <= 1'b1;
end

// AXI AW handshake
if (r_aw_valid && m_axi_awready) begin
    r_aw_valid <= 1'b0;
    r_expected_beats <= r_aw_len + 8'h1;
    r_w_active <= 1'b1;
end

// Clear inflight when B response received
if (m_axi_bvalid && m_axi_bready) begin
    r_aw_inflight <= 1'b0;
    r_b_pending <= 1'b0;
end

<b>W Channel Streaming (lines 255-258):</b>

assign m_axi_wvalid = r_w_active && sram_rd_valid;
assign m_axi_wdata  = sram_rd_data;  // Direct connection!
assign m_axi_wstrb  = {(DATA_WIDTH/8){1'b1}};
assign m_axi_wlast  = (r_beats_sent == (r_expected_beats - 8'h1));
@enduml
