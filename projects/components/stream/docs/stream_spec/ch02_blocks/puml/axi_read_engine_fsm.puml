@startuml axi_read_engine_fsm
!theme plain
title AXI Read Engine FSM - Low Performance Mode (axi_read_engine.sv)

skinparam state {
  BackgroundColor LightYellow
  BorderColor DarkOrange
  ArrowColor DarkOrange
  ArrowFontColor Black
  ArrowFontSize 10
}

[*] --> READ_IDLE

state READ_IDLE {
  READ_IDLE : Idle - waiting for read request
  READ_IDLE : • No active transaction
  READ_IDLE : • Ready to accept scheduler request
  READ_IDLE : • SRAM space available
}
state READ_CALCULATE_BURST {
  READ_CALCULATE_BURST : Calculate burst length
  READ_CALCULATE_BURST : Min(cfg_burst_len, MAX_BURST_LEN,
  READ_CALCULATE_BURST :     beats_remaining, sram_wr_free)
}
state READ_ISSUE_AR {
  READ_ISSUE_AR : Issue AXI AR transaction
  READ_ISSUE_AR : Set ARID = {txn_counter, channel_id[3:0]}
  READ_ISSUE_AR : Wait for ar_ready
}
state READ_STREAM_DATA {
  READ_STREAM_DATA : Receive AXI R data
  READ_STREAM_DATA : Write data to SRAM
  READ_STREAM_DATA : Increment SRAM write pointer
  READ_STREAM_DATA : Wait for rlast
}
state READ_COMPLETE_BURST {
  READ_COMPLETE_BURST : Burst completed
  READ_COMPLETE_BURST : Assert datard_done_strobe
  READ_COMPLETE_BURST : Report beats_done to scheduler
  READ_COMPLETE_BURST : Generate MonBus packet
}
state READ_ERROR {
  READ_ERROR : Error state
  READ_ERROR : AXI RRESP error
  READ_ERROR : Timeout expired
}

READ_IDLE -down-> READ_CALCULATE_BURST : datard_valid & datard_ready & sram_wr_free > 0
READ_IDLE -down-> READ_ERROR : error_conditions
READ_CALCULATE_BURST -down-> READ_ISSUE_AR : burst_len_calculated
READ_ISSUE_AR -down-> READ_STREAM_DATA : ar_valid & ar_ready
READ_ISSUE_AR -down-> READ_ERROR : ar_timeout
READ_STREAM_DATA -right-> READ_COMPLETE_BURST : r_valid & r_last
READ_STREAM_DATA -down-> READ_ERROR : r_valid & (rresp != OKAY) | r_timeout
READ_COMPLETE_BURST -up-> READ_IDLE : beats_remaining == 0
READ_COMPLETE_BURST -up-> READ_CALCULATE_BURST : beats_remaining > 0
READ_ERROR -up-> READ_IDLE : error_acknowledged

note bottom
<b>Signal Definitions (axi_read_engine.sv):</b>

<b>Scheduler Interface:</b>
datard_valid = scheduler requests read operation
datard_ready = engine grants access (from arbiter)
datard_addr = source address
datard_beats_remaining = total beats to read
datard_channel_id = channel ID (from arbiter)

datard_done_strobe = burst completion signal
datard_beats_done = beats transferred in this burst
datard_error = error occurred

<b>AXI AR Channel:</b>
m_axi_araddr = read address
m_axi_arlen = burst length - 1
m_axi_arsize = beat size (log2(DATA_WIDTH/8))
m_axi_arburst = INCR (2'b01)
m_axi_arid = {transaction_counter, datard_channel_id[3:0]}

<b>AXI R Channel:</b>
m_axi_rid = transaction ID (matches arid)
m_axi_rdata = read data
m_axi_rresp = response (OKAY = 2'b00)
m_axi_rlast = last beat in burst

<b>SRAM Interface:</b>
sram_wr_en = write enable to SRAM
sram_wr_addr = write address
sram_wr_data = write data (from m_axi_rdata)
sram_wr_free = free lines available for writes

<b>Burst Length Calculation:</b>

function calculate_burst_len():
    max_possible = cfg_burst_len
    if (max_possible > MAX_BURST_LEN)
        max_possible = MAX_BURST_LEN
    if (max_possible > datard_beats_remaining)
        max_possible = datard_beats_remaining
    if (max_possible > sram_wr_free)
        max_possible = sram_wr_free
    return max_possible

<b>State Functions:</b>

READ_IDLE:
- Wait for scheduler read request
- Arbiter grants one channel access
- Check SRAM has space for burst

READ_CALCULATE_BURST:
- Determine optimal burst length
- Consider performance mode limits
- Respect SRAM backpressure
- Ensure beats_remaining not exceeded

READ_ISSUE_AR:
- Send AXI AR transaction
- Encode channel ID in ARID lower bits
- Transaction counter in ARID upper bits
- Wait for ar_ready handshake

READ_STREAM_DATA:
- Accept R data beats
- Write each beat to SRAM
- Increment SRAM write pointer
- Continue until rlast asserted

READ_COMPLETE_BURST:
- Assert done_strobe to scheduler
- Report actual beats transferred
- Generate MonBus completion packet
- Check if more bursts needed

READ_ERROR:
- Handle AXI errors (RRESP != OKAY)
- Handle timeout conditions
- Generate MonBus error packet
- Signal error to scheduler

<b>Performance Modes:</b>

Low (PERFORMANCE = "LOW"):
- MAX_BURST_LEN = 8
- MAX_OUTSTANDING = 1 (sequential)
- Simple FSM as shown

Medium (PERFORMANCE = "MEDIUM"):
- MAX_BURST_LEN = 16
- MAX_OUTSTANDING = 4
- Pipelined AR/R channels
- Outstanding transaction tracking

High (PERFORMANCE = "HIGH"):
- MAX_BURST_LEN = 256
- MAX_OUTSTANDING = 16
- Full pipelining
- Dynamic burst optimization
@enduml
