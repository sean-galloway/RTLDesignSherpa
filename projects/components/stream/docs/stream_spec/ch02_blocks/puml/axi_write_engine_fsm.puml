@startuml axi_write_engine_fsm
!theme plain
title AXI Write Engine FSM - Low Performance Mode (axi_write_engine.sv)

skinparam state {
  BackgroundColor LightSalmon
  BorderColor DarkRed
  ArrowColor DarkRed
  ArrowFontColor Black
  ArrowFontSize 10
}

[*] --> WRITE_IDLE

state WRITE_IDLE {
  WRITE_IDLE : Idle - waiting for write request
  WRITE_IDLE : • No active transaction
  WRITE_IDLE : • Ready to accept scheduler request
  WRITE_IDLE : • SRAM data available
}
state WRITE_CALCULATE_BURST {
  WRITE_CALCULATE_BURST : Calculate burst length
  WRITE_CALCULATE_BURST : Min(cfg_burst_len, MAX_BURST_LEN,
  WRITE_CALCULATE_BURST :     beats_remaining, sram_rd_avail)
}
state WRITE_ISSUE_AW {
  WRITE_ISSUE_AW : Issue AXI AW transaction
  WRITE_ISSUE_AW : Set AWID = {txn_counter, channel_id[3:0]}
  WRITE_ISSUE_AW : Wait for aw_ready
}
state WRITE_STREAM_DATA {
  WRITE_STREAM_DATA : Send AXI W data
  WRITE_STREAM_DATA : Read data from SRAM
  WRITE_STREAM_DATA : Increment SRAM read pointer
  WRITE_STREAM_DATA : Assert wlast on final beat
}
state WRITE_WAIT_RESPONSE {
  WRITE_WAIT_RESPONSE : Wait for AXI B response
  WRITE_WAIT_RESPONSE : Verify BID matches
  WRITE_WAIT_RESPONSE : Check BRESP status
}
state WRITE_COMPLETE_BURST {
  WRITE_COMPLETE_BURST : Burst completed
  WRITE_COMPLETE_BURST : Assert datawr_done_strobe
  WRITE_COMPLETE_BURST : Report beats_done to scheduler
  WRITE_COMPLETE_BURST : Generate MonBus packet
}
state WRITE_ERROR {
  WRITE_ERROR : Error state
  WRITE_ERROR : AXI BRESP error
  WRITE_ERROR : Timeout expired
}

WRITE_IDLE -down-> WRITE_CALCULATE_BURST : datawr_valid & datawr_ready & sram_rd_avail > 0
WRITE_IDLE -down-> WRITE_ERROR : error_conditions
WRITE_CALCULATE_BURST -down-> WRITE_ISSUE_AW : burst_len_calculated
WRITE_ISSUE_AW -down-> WRITE_STREAM_DATA : aw_valid & aw_ready
WRITE_ISSUE_AW -down-> WRITE_ERROR : aw_timeout
WRITE_STREAM_DATA -right-> WRITE_WAIT_RESPONSE : w_valid & w_last & w_ready
WRITE_STREAM_DATA -down-> WRITE_ERROR : w_timeout
WRITE_WAIT_RESPONSE -right-> WRITE_COMPLETE_BURST : b_valid & (bresp == OKAY)
WRITE_WAIT_RESPONSE -down-> WRITE_ERROR : b_valid & (bresp != OKAY) | b_timeout
WRITE_COMPLETE_BURST -up-> WRITE_IDLE : beats_remaining == 0
WRITE_COMPLETE_BURST -up-> WRITE_CALCULATE_BURST : beats_remaining > 0
WRITE_ERROR -up-> WRITE_IDLE : error_acknowledged

note bottom
<b>Signal Definitions (axi_write_engine.sv):</b>

<b>Scheduler Interface:</b>
datawr_valid = scheduler requests write operation
datawr_ready = engine grants access (from arbiter)
datawr_addr = destination address
datawr_beats_remaining = total beats to write
datawr_channel_id = channel ID (from arbiter)

datawr_done_strobe = burst completion signal
datawr_beats_done = beats transferred in this burst
datawr_error = error occurred

<b>AXI AW Channel:</b>
m_axi_awaddr = write address
m_axi_awlen = burst length - 1
m_axi_awsize = beat size (log2(DATA_WIDTH/8))
m_axi_awburst = INCR (2'b01)
m_axi_awid = {transaction_counter, datawr_channel_id[3:0]}

<b>AXI W Channel:</b>
m_axi_wdata = write data (from SRAM)
m_axi_wstrb = byte strobes (all 1s for aligned)
m_axi_wlast = last beat in burst

<b>AXI B Channel:</b>
m_axi_bid = transaction ID (matches awid)
m_axi_bresp = response (OKAY = 2'b00)

<b>SRAM Interface:</b>
sram_rd_en = read enable from SRAM
sram_rd_addr = read address
sram_rd_data = read data
sram_rd_avail = available lines ready to drain

<b>Burst Length Calculation:</b>

function calculate_burst_len():
    max_possible = cfg_burst_len
    if (max_possible > MAX_BURST_LEN)
        max_possible = MAX_BURST_LEN
    if (max_possible > datawr_beats_remaining)
        max_possible = datawr_beats_remaining
    if (max_possible > sram_rd_avail)
        max_possible = sram_rd_avail
    return max_possible

<b>State Functions:</b>

WRITE_IDLE:
- Wait for scheduler write request
- Arbiter grants one channel access
- Check SRAM has data available

WRITE_CALCULATE_BURST:
- Determine optimal burst length
- Consider performance mode limits
- Respect SRAM data availability
- Ensure beats_remaining not exceeded

WRITE_ISSUE_AW:
- Send AXI AW transaction
- Encode channel ID in AWID lower bits
- Transaction counter in AWID upper bits
- Wait for aw_ready handshake

WRITE_STREAM_DATA:
- Read data from SRAM each cycle
- Send W data beats to AXI
- Increment SRAM read pointer
- Assert wlast on final beat

WRITE_WAIT_RESPONSE:
- Wait for AXI B response
- Verify BID matches AWID
- Check BRESP for errors
- Handle timeout conditions

WRITE_COMPLETE_BURST:
- Assert done_strobe to scheduler
- Report actual beats transferred
- Generate MonBus completion packet
- Check if more bursts needed

WRITE_ERROR:
- Handle AXI errors (BRESP != OKAY)
- Handle timeout conditions
- Generate MonBus error packet
- Signal error to scheduler

<b>Performance Modes:</b>

Low (PERFORMANCE = "LOW"):
- MAX_BURST_LEN = 16
- MAX_OUTSTANDING = 1 (sequential)
- Simple FSM as shown

Medium (PERFORMANCE = "MEDIUM"):
- MAX_BURST_LEN = 32
- MAX_OUTSTANDING = 4
- Pipelined AW/W/B channels
- Outstanding transaction tracking

High (PERFORMANCE = "HIGH"):
- MAX_BURST_LEN = 256
- MAX_OUTSTANDING = 16
- Full pipelining
- Dynamic burst optimization

<b>Asymmetric Burst Lengths:</b>
Write engine can use different burst lengths than read engine.
Example: Read = 8 beats, Write = 16 beats (2x)
SRAM buffer decouples read/write rates.
@enduml
