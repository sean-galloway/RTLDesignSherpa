//      // verilator_coverage annotation
        // Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
        //  https://github.com/SystemRDL/PeakRDL-regblock
        
        module stream_regs (
 004646         input wire clk,
%000004         input wire rst,
        
 000040         input wire s_cpuif_req,
 000028         input wire s_cpuif_req_is_wr,
%000000         input wire [9:0] s_cpuif_addr,
%000000         input wire [31:0] s_cpuif_wr_data,
%000002         input wire [31:0] s_cpuif_wr_biten,
%000000         output wire s_cpuif_req_stall_wr,
%000000         output wire s_cpuif_req_stall_rd,
 000020         output wire s_cpuif_rd_ack,
%000000         output wire s_cpuif_rd_err,
%000000         output wire [31:0] s_cpuif_rd_data,
 000020         output wire s_cpuif_wr_ack,
%000000         output wire s_cpuif_wr_err,
        
%000000         input stream_regs_pkg::stream_regs__in_t hwif_in,
%000000         output stream_regs_pkg::stream_regs__out_t hwif_out
            );
        
            //--------------------------------------------------------------------------
            // CPU Bus interface logic
            //--------------------------------------------------------------------------
 000040     logic cpuif_req;
 000028     logic cpuif_req_is_wr;
%000000     logic [9:0] cpuif_addr;
%000000     logic [31:0] cpuif_wr_data;
%000002     logic [31:0] cpuif_wr_biten;
%000000     logic cpuif_req_stall_wr;
%000000     logic cpuif_req_stall_rd;
        
 000020     logic cpuif_rd_ack;
%000000     logic cpuif_rd_err;
%000000     logic [31:0] cpuif_rd_data;
        
 000020     logic cpuif_wr_ack;
%000000     logic cpuif_wr_err;
        
            assign cpuif_req = s_cpuif_req;
            assign cpuif_req_is_wr = s_cpuif_req_is_wr;
            assign cpuif_addr = s_cpuif_addr;
            assign cpuif_wr_data = s_cpuif_wr_data;
            assign cpuif_wr_biten = s_cpuif_wr_biten;
            assign s_cpuif_req_stall_wr = cpuif_req_stall_wr;
            assign s_cpuif_req_stall_rd = cpuif_req_stall_rd;
            assign s_cpuif_rd_ack = cpuif_rd_ack;
            assign s_cpuif_rd_err = cpuif_rd_err;
            assign s_cpuif_rd_data = cpuif_rd_data;
            assign s_cpuif_wr_ack = cpuif_wr_ack;
            assign s_cpuif_wr_err = cpuif_wr_err;
        
 000040     logic cpuif_req_masked;
        
            // Read & write latencies are balanced. Stalls not required
            assign cpuif_req_stall_rd = '0;
            assign cpuif_req_stall_wr = '0;
            assign cpuif_req_masked = cpuif_req
                                    & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                                    & !(cpuif_req_is_wr & cpuif_req_stall_wr);
        
            //--------------------------------------------------------------------------
            // Address Decode
            //--------------------------------------------------------------------------
            typedef struct {
                logic GLOBAL_CTRL;
                logic GLOBAL_STATUS;
                logic VERSION;
                logic CHANNEL_ENABLE;
                logic CHANNEL_RESET;
                logic CHANNEL_IDLE;
                logic DESC_ENGINE_IDLE;
                logic SCHEDULER_IDLE;
                struct {
                    logic STATE;
                } CH_STATE[8];
                logic SCHED_TIMEOUT_CYCLES;
                logic SCHED_CONFIG;
                logic DESCENG_CONFIG;
                logic DESCENG_ADDR0_BASE;
                logic DESCENG_ADDR0_LIMIT;
                logic DESCENG_ADDR1_BASE;
                logic DESCENG_ADDR1_LIMIT;
                logic DAXMON_ENABLE;
                logic DAXMON_TIMEOUT;
                logic DAXMON_LATENCY_THRESH;
                logic DAXMON_PKT_MASK;
                logic DAXMON_ERR_CFG;
                logic DAXMON_MASK1;
                logic DAXMON_MASK2;
                logic DAXMON_MASK3;
                logic RDMON_ENABLE;
                logic RDMON_TIMEOUT;
                logic RDMON_LATENCY_THRESH;
                logic RDMON_PKT_MASK;
                logic RDMON_ERR_CFG;
                logic RDMON_MASK1;
                logic RDMON_MASK2;
                logic RDMON_MASK3;
                logic WRMON_ENABLE;
                logic WRMON_TIMEOUT;
                logic WRMON_LATENCY_THRESH;
                logic WRMON_PKT_MASK;
                logic WRMON_ERR_CFG;
                logic WRMON_MASK1;
                logic WRMON_MASK2;
                logic WRMON_MASK3;
                logic AXI_XFER_CONFIG;
                logic PERF_CONFIG;
            } decoded_reg_strb_t;
            decoded_reg_strb_t decoded_reg_strb;
 000040     logic decoded_req;
 000028     logic decoded_req_is_wr;
%000000     logic [31:0] decoded_wr_data;
%000002     logic [31:0] decoded_wr_biten;
        
%000002     always_comb begin
%000002         decoded_reg_strb.GLOBAL_CTRL = cpuif_req_masked & (cpuif_addr == 10'h100);
%000002         decoded_reg_strb.GLOBAL_STATUS = cpuif_req_masked & (cpuif_addr == 10'h104);
%000002         decoded_reg_strb.VERSION = cpuif_req_masked & (cpuif_addr == 10'h108);
%000002         decoded_reg_strb.CHANNEL_ENABLE = cpuif_req_masked & (cpuif_addr == 10'h120);
%000002         decoded_reg_strb.CHANNEL_RESET = cpuif_req_masked & (cpuif_addr == 10'h124);
%000002         decoded_reg_strb.CHANNEL_IDLE = cpuif_req_masked & (cpuif_addr == 10'h140);
%000002         decoded_reg_strb.DESC_ENGINE_IDLE = cpuif_req_masked & (cpuif_addr == 10'h144);
%000002         decoded_reg_strb.SCHEDULER_IDLE = cpuif_req_masked & (cpuif_addr == 10'h148);
%000002         for(int i0=0; i0<8; i0++) begin
 000016             decoded_reg_strb.CH_STATE[i0].STATE = cpuif_req_masked & (cpuif_addr == 10'h150 + (10)'(i0) * 10'h4);
                end
%000002         decoded_reg_strb.SCHED_TIMEOUT_CYCLES = cpuif_req_masked & (cpuif_addr == 10'h200);
%000002         decoded_reg_strb.SCHED_CONFIG = cpuif_req_masked & (cpuif_addr == 10'h204);
%000002         decoded_reg_strb.DESCENG_CONFIG = cpuif_req_masked & (cpuif_addr == 10'h220);
%000002         decoded_reg_strb.DESCENG_ADDR0_BASE = cpuif_req_masked & (cpuif_addr == 10'h224);
%000002         decoded_reg_strb.DESCENG_ADDR0_LIMIT = cpuif_req_masked & (cpuif_addr == 10'h228);
%000002         decoded_reg_strb.DESCENG_ADDR1_BASE = cpuif_req_masked & (cpuif_addr == 10'h22c);
%000002         decoded_reg_strb.DESCENG_ADDR1_LIMIT = cpuif_req_masked & (cpuif_addr == 10'h230);
%000002         decoded_reg_strb.DAXMON_ENABLE = cpuif_req_masked & (cpuif_addr == 10'h240);
%000002         decoded_reg_strb.DAXMON_TIMEOUT = cpuif_req_masked & (cpuif_addr == 10'h244);
%000002         decoded_reg_strb.DAXMON_LATENCY_THRESH = cpuif_req_masked & (cpuif_addr == 10'h248);
%000002         decoded_reg_strb.DAXMON_PKT_MASK = cpuif_req_masked & (cpuif_addr == 10'h24c);
%000002         decoded_reg_strb.DAXMON_ERR_CFG = cpuif_req_masked & (cpuif_addr == 10'h250);
%000002         decoded_reg_strb.DAXMON_MASK1 = cpuif_req_masked & (cpuif_addr == 10'h254);
%000002         decoded_reg_strb.DAXMON_MASK2 = cpuif_req_masked & (cpuif_addr == 10'h258);
%000002         decoded_reg_strb.DAXMON_MASK3 = cpuif_req_masked & (cpuif_addr == 10'h25c);
%000002         decoded_reg_strb.RDMON_ENABLE = cpuif_req_masked & (cpuif_addr == 10'h260);
%000002         decoded_reg_strb.RDMON_TIMEOUT = cpuif_req_masked & (cpuif_addr == 10'h264);
%000002         decoded_reg_strb.RDMON_LATENCY_THRESH = cpuif_req_masked & (cpuif_addr == 10'h268);
%000002         decoded_reg_strb.RDMON_PKT_MASK = cpuif_req_masked & (cpuif_addr == 10'h26c);
%000002         decoded_reg_strb.RDMON_ERR_CFG = cpuif_req_masked & (cpuif_addr == 10'h270);
%000002         decoded_reg_strb.RDMON_MASK1 = cpuif_req_masked & (cpuif_addr == 10'h274);
%000002         decoded_reg_strb.RDMON_MASK2 = cpuif_req_masked & (cpuif_addr == 10'h278);
%000002         decoded_reg_strb.RDMON_MASK3 = cpuif_req_masked & (cpuif_addr == 10'h27c);
%000002         decoded_reg_strb.WRMON_ENABLE = cpuif_req_masked & (cpuif_addr == 10'h280);
%000002         decoded_reg_strb.WRMON_TIMEOUT = cpuif_req_masked & (cpuif_addr == 10'h284);
%000002         decoded_reg_strb.WRMON_LATENCY_THRESH = cpuif_req_masked & (cpuif_addr == 10'h288);
%000002         decoded_reg_strb.WRMON_PKT_MASK = cpuif_req_masked & (cpuif_addr == 10'h28c);
%000002         decoded_reg_strb.WRMON_ERR_CFG = cpuif_req_masked & (cpuif_addr == 10'h290);
%000002         decoded_reg_strb.WRMON_MASK1 = cpuif_req_masked & (cpuif_addr == 10'h294);
%000002         decoded_reg_strb.WRMON_MASK2 = cpuif_req_masked & (cpuif_addr == 10'h298);
%000002         decoded_reg_strb.WRMON_MASK3 = cpuif_req_masked & (cpuif_addr == 10'h29c);
%000002         decoded_reg_strb.AXI_XFER_CONFIG = cpuif_req_masked & (cpuif_addr == 10'h2a0);
%000002         decoded_reg_strb.PERF_CONFIG = cpuif_req_masked & (cpuif_addr == 10'h2b0);
            end
        
            // Pass down signals to next stage
            assign decoded_req = cpuif_req_masked;
            assign decoded_req_is_wr = cpuif_req_is_wr;
            assign decoded_wr_data = cpuif_wr_data;
            assign decoded_wr_biten = cpuif_wr_biten;
        
            //--------------------------------------------------------------------------
            // Field logic
            //--------------------------------------------------------------------------
            typedef struct {
                struct {
                    struct {
                        logic next;
                        logic load_next;
                    } GLOBAL_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } GLOBAL_RST;
                } GLOBAL_CTRL;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } CH_EN;
                } CHANNEL_ENABLE;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } CH_RST;
                } CHANNEL_RESET;
                struct {
                    struct {
                        logic [15:0] next;
                        logic load_next;
                    } TIMEOUT_CYCLES;
                } SCHED_TIMEOUT_CYCLES;
                struct {
                    struct {
                        logic next;
                        logic load_next;
                    } SCHED_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } TIMEOUT_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } ERR_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } COMPL_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } PERF_EN;
                } SCHED_CONFIG;
                struct {
                    struct {
                        logic next;
                        logic load_next;
                    } DESCENG_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } PREFETCH_EN;
                    struct {
                        logic [3:0] next;
                        logic load_next;
                    } FIFO_THRESH;
                } DESCENG_CONFIG;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } ADDR0_BASE;
                } DESCENG_ADDR0_BASE;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } ADDR0_LIMIT;
                } DESCENG_ADDR0_LIMIT;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } ADDR1_BASE;
                } DESCENG_ADDR1_BASE;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } ADDR1_LIMIT;
                } DESCENG_ADDR1_LIMIT;
                struct {
                    struct {
                        logic next;
                        logic load_next;
                    } MON_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } ERR_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } COMPL_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } TIMEOUT_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } PERF_EN;
                } DAXMON_ENABLE;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } TIMEOUT_CYCLES;
                } DAXMON_TIMEOUT;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } LATENCY_THRESH;
                } DAXMON_LATENCY_THRESH;
                struct {
                    struct {
                        logic [15:0] next;
                        logic load_next;
                    } PKT_MASK;
                } DAXMON_PKT_MASK;
                struct {
                    struct {
                        logic [3:0] next;
                        logic load_next;
                    } ERR_SELECT;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } ERR_MASK;
                } DAXMON_ERR_CFG;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } TIMEOUT_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } COMPL_MASK;
                } DAXMON_MASK1;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } THRESH_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } PERF_MASK;
                } DAXMON_MASK2;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } ADDR_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } DEBUG_MASK;
                } DAXMON_MASK3;
                struct {
                    struct {
                        logic next;
                        logic load_next;
                    } MON_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } ERR_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } COMPL_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } TIMEOUT_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } PERF_EN;
                } RDMON_ENABLE;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } TIMEOUT_CYCLES;
                } RDMON_TIMEOUT;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } LATENCY_THRESH;
                } RDMON_LATENCY_THRESH;
                struct {
                    struct {
                        logic [15:0] next;
                        logic load_next;
                    } PKT_MASK;
                } RDMON_PKT_MASK;
                struct {
                    struct {
                        logic [3:0] next;
                        logic load_next;
                    } ERR_SELECT;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } ERR_MASK;
                } RDMON_ERR_CFG;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } TIMEOUT_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } COMPL_MASK;
                } RDMON_MASK1;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } THRESH_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } PERF_MASK;
                } RDMON_MASK2;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } ADDR_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } DEBUG_MASK;
                } RDMON_MASK3;
                struct {
                    struct {
                        logic next;
                        logic load_next;
                    } MON_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } ERR_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } COMPL_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } TIMEOUT_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } PERF_EN;
                } WRMON_ENABLE;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } TIMEOUT_CYCLES;
                } WRMON_TIMEOUT;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } LATENCY_THRESH;
                } WRMON_LATENCY_THRESH;
                struct {
                    struct {
                        logic [15:0] next;
                        logic load_next;
                    } PKT_MASK;
                } WRMON_PKT_MASK;
                struct {
                    struct {
                        logic [3:0] next;
                        logic load_next;
                    } ERR_SELECT;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } ERR_MASK;
                } WRMON_ERR_CFG;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } TIMEOUT_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } COMPL_MASK;
                } WRMON_MASK1;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } THRESH_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } PERF_MASK;
                } WRMON_MASK2;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } ADDR_MASK;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } DEBUG_MASK;
                } WRMON_MASK3;
                struct {
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } RD_XFER_BEATS;
                    struct {
                        logic [7:0] next;
                        logic load_next;
                    } WR_XFER_BEATS;
                } AXI_XFER_CONFIG;
                struct {
                    struct {
                        logic next;
                        logic load_next;
                    } PERF_EN;
                    struct {
                        logic next;
                        logic load_next;
                    } PERF_MODE;
                    struct {
                        logic next;
                        logic load_next;
                    } PERF_CLEAR;
                } PERF_CONFIG;
            } field_combo_t;
            field_combo_t field_combo;
        
            typedef struct {
                struct {
                    struct {
                        logic value;
                    } GLOBAL_EN;
                    struct {
                        logic value;
                    } GLOBAL_RST;
                } GLOBAL_CTRL;
                struct {
                    struct {
                        logic [7:0] value;
                    } CH_EN;
                } CHANNEL_ENABLE;
                struct {
                    struct {
                        logic [7:0] value;
                    } CH_RST;
                } CHANNEL_RESET;
                struct {
                    struct {
                        logic [15:0] value;
                    } TIMEOUT_CYCLES;
                } SCHED_TIMEOUT_CYCLES;
                struct {
                    struct {
                        logic value;
                    } SCHED_EN;
                    struct {
                        logic value;
                    } TIMEOUT_EN;
                    struct {
                        logic value;
                    } ERR_EN;
                    struct {
                        logic value;
                    } COMPL_EN;
                    struct {
                        logic value;
                    } PERF_EN;
                } SCHED_CONFIG;
                struct {
                    struct {
                        logic value;
                    } DESCENG_EN;
                    struct {
                        logic value;
                    } PREFETCH_EN;
                    struct {
                        logic [3:0] value;
                    } FIFO_THRESH;
                } DESCENG_CONFIG;
                struct {
                    struct {
                        logic [31:0] value;
                    } ADDR0_BASE;
                } DESCENG_ADDR0_BASE;
                struct {
                    struct {
                        logic [31:0] value;
                    } ADDR0_LIMIT;
                } DESCENG_ADDR0_LIMIT;
                struct {
                    struct {
                        logic [31:0] value;
                    } ADDR1_BASE;
                } DESCENG_ADDR1_BASE;
                struct {
                    struct {
                        logic [31:0] value;
                    } ADDR1_LIMIT;
                } DESCENG_ADDR1_LIMIT;
                struct {
                    struct {
                        logic value;
                    } MON_EN;
                    struct {
                        logic value;
                    } ERR_EN;
                    struct {
                        logic value;
                    } COMPL_EN;
                    struct {
                        logic value;
                    } TIMEOUT_EN;
                    struct {
                        logic value;
                    } PERF_EN;
                } DAXMON_ENABLE;
                struct {
                    struct {
                        logic [31:0] value;
                    } TIMEOUT_CYCLES;
                } DAXMON_TIMEOUT;
                struct {
                    struct {
                        logic [31:0] value;
                    } LATENCY_THRESH;
                } DAXMON_LATENCY_THRESH;
                struct {
                    struct {
                        logic [15:0] value;
                    } PKT_MASK;
                } DAXMON_PKT_MASK;
                struct {
                    struct {
                        logic [3:0] value;
                    } ERR_SELECT;
                    struct {
                        logic [7:0] value;
                    } ERR_MASK;
                } DAXMON_ERR_CFG;
                struct {
                    struct {
                        logic [7:0] value;
                    } TIMEOUT_MASK;
                    struct {
                        logic [7:0] value;
                    } COMPL_MASK;
                } DAXMON_MASK1;
                struct {
                    struct {
                        logic [7:0] value;
                    } THRESH_MASK;
                    struct {
                        logic [7:0] value;
                    } PERF_MASK;
                } DAXMON_MASK2;
                struct {
                    struct {
                        logic [7:0] value;
                    } ADDR_MASK;
                    struct {
                        logic [7:0] value;
                    } DEBUG_MASK;
                } DAXMON_MASK3;
                struct {
                    struct {
                        logic value;
                    } MON_EN;
                    struct {
                        logic value;
                    } ERR_EN;
                    struct {
                        logic value;
                    } COMPL_EN;
                    struct {
                        logic value;
                    } TIMEOUT_EN;
                    struct {
                        logic value;
                    } PERF_EN;
                } RDMON_ENABLE;
                struct {
                    struct {
                        logic [31:0] value;
                    } TIMEOUT_CYCLES;
                } RDMON_TIMEOUT;
                struct {
                    struct {
                        logic [31:0] value;
                    } LATENCY_THRESH;
                } RDMON_LATENCY_THRESH;
                struct {
                    struct {
                        logic [15:0] value;
                    } PKT_MASK;
                } RDMON_PKT_MASK;
                struct {
                    struct {
                        logic [3:0] value;
                    } ERR_SELECT;
                    struct {
                        logic [7:0] value;
                    } ERR_MASK;
                } RDMON_ERR_CFG;
                struct {
                    struct {
                        logic [7:0] value;
                    } TIMEOUT_MASK;
                    struct {
                        logic [7:0] value;
                    } COMPL_MASK;
                } RDMON_MASK1;
                struct {
                    struct {
                        logic [7:0] value;
                    } THRESH_MASK;
                    struct {
                        logic [7:0] value;
                    } PERF_MASK;
                } RDMON_MASK2;
                struct {
                    struct {
                        logic [7:0] value;
                    } ADDR_MASK;
                    struct {
                        logic [7:0] value;
                    } DEBUG_MASK;
                } RDMON_MASK3;
                struct {
                    struct {
                        logic value;
                    } MON_EN;
                    struct {
                        logic value;
                    } ERR_EN;
                    struct {
                        logic value;
                    } COMPL_EN;
                    struct {
                        logic value;
                    } TIMEOUT_EN;
                    struct {
                        logic value;
                    } PERF_EN;
                } WRMON_ENABLE;
                struct {
                    struct {
                        logic [31:0] value;
                    } TIMEOUT_CYCLES;
                } WRMON_TIMEOUT;
                struct {
                    struct {
                        logic [31:0] value;
                    } LATENCY_THRESH;
                } WRMON_LATENCY_THRESH;
                struct {
                    struct {
                        logic [15:0] value;
                    } PKT_MASK;
                } WRMON_PKT_MASK;
                struct {
                    struct {
                        logic [3:0] value;
                    } ERR_SELECT;
                    struct {
                        logic [7:0] value;
                    } ERR_MASK;
                } WRMON_ERR_CFG;
                struct {
                    struct {
                        logic [7:0] value;
                    } TIMEOUT_MASK;
                    struct {
                        logic [7:0] value;
                    } COMPL_MASK;
                } WRMON_MASK1;
                struct {
                    struct {
                        logic [7:0] value;
                    } THRESH_MASK;
                    struct {
                        logic [7:0] value;
                    } PERF_MASK;
                } WRMON_MASK2;
                struct {
                    struct {
                        logic [7:0] value;
                    } ADDR_MASK;
                    struct {
                        logic [7:0] value;
                    } DEBUG_MASK;
                } WRMON_MASK3;
                struct {
                    struct {
                        logic [7:0] value;
                    } RD_XFER_BEATS;
                    struct {
                        logic [7:0] value;
                    } WR_XFER_BEATS;
                } AXI_XFER_CONFIG;
                struct {
                    struct {
                        logic value;
                    } PERF_EN;
                    struct {
                        logic value;
                    } PERF_MODE;
                    struct {
                        logic value;
                    } PERF_CLEAR;
                } PERF_CONFIG;
            } field_storage_t;
            field_storage_t field_storage;
        
            // Field: stream_regs.GLOBAL_CTRL.GLOBAL_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.GLOBAL_CTRL.GLOBAL_EN.value;
 021934         load_next_c = '0;
 000036         if(decoded_reg_strb.GLOBAL_CTRL && decoded_req_is_wr) begin // SW write
 000036             next_c = (field_storage.GLOBAL_CTRL.GLOBAL_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
 000036             load_next_c = '1;
                end
 021934         field_combo.GLOBAL_CTRL.GLOBAL_EN.next = next_c;
 021934         field_combo.GLOBAL_CTRL.GLOBAL_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.GLOBAL_CTRL.GLOBAL_EN.value <= 1'h0;
 002302         end else begin
%000004             if(field_combo.GLOBAL_CTRL.GLOBAL_EN.load_next) begin
%000004                 field_storage.GLOBAL_CTRL.GLOBAL_EN.value <= field_combo.GLOBAL_CTRL.GLOBAL_EN.next;
                    end
                end
            end
            assign hwif_out.GLOBAL_CTRL.GLOBAL_EN.value = field_storage.GLOBAL_CTRL.GLOBAL_EN.value;
            // Field: stream_regs.GLOBAL_CTRL.GLOBAL_RST
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.GLOBAL_CTRL.GLOBAL_RST.value;
 021934         load_next_c = '0;
 000036         if(decoded_reg_strb.GLOBAL_CTRL && decoded_req_is_wr) begin // SW write
 000036             next_c = (field_storage.GLOBAL_CTRL.GLOBAL_RST.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
 000036             load_next_c = '1;
                end
 021934         field_combo.GLOBAL_CTRL.GLOBAL_RST.next = next_c;
 021934         field_combo.GLOBAL_CTRL.GLOBAL_RST.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.GLOBAL_CTRL.GLOBAL_RST.value <= 1'h0;
 002302         end else begin
%000004             if(field_combo.GLOBAL_CTRL.GLOBAL_RST.load_next) begin
%000004                 field_storage.GLOBAL_CTRL.GLOBAL_RST.value <= field_combo.GLOBAL_CTRL.GLOBAL_RST.next;
                    end
                end
            end
            assign hwif_out.GLOBAL_CTRL.GLOBAL_RST.value = field_storage.GLOBAL_CTRL.GLOBAL_RST.value;
            assign hwif_out.GLOBAL_CTRL.GLOBAL_RST.swmod = decoded_reg_strb.GLOBAL_CTRL && decoded_req_is_wr && |(decoded_wr_biten[1:1]);
            // Field: stream_regs.CHANNEL_ENABLE.CH_EN
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.CHANNEL_ENABLE.CH_EN.value;
 021934         load_next_c = '0;
 000036         if(decoded_reg_strb.CHANNEL_ENABLE && decoded_req_is_wr) begin // SW write
 000036             next_c = (field_storage.CHANNEL_ENABLE.CH_EN.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
 000036             load_next_c = '1;
                end
 021934         field_combo.CHANNEL_ENABLE.CH_EN.next = next_c;
 021934         field_combo.CHANNEL_ENABLE.CH_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.CHANNEL_ENABLE.CH_EN.value <= 8'h0;
 002302         end else begin
%000004             if(field_combo.CHANNEL_ENABLE.CH_EN.load_next) begin
%000004                 field_storage.CHANNEL_ENABLE.CH_EN.value <= field_combo.CHANNEL_ENABLE.CH_EN.next;
                    end
                end
            end
            assign hwif_out.CHANNEL_ENABLE.CH_EN.value = field_storage.CHANNEL_ENABLE.CH_EN.value;
            // Field: stream_regs.CHANNEL_RESET.CH_RST
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.CHANNEL_RESET.CH_RST.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.CHANNEL_RESET && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.CHANNEL_RESET.CH_RST.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.CHANNEL_RESET.CH_RST.next = next_c;
 021934         field_combo.CHANNEL_RESET.CH_RST.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.CHANNEL_RESET.CH_RST.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.CHANNEL_RESET.CH_RST.load_next) begin
%000000                 field_storage.CHANNEL_RESET.CH_RST.value <= field_combo.CHANNEL_RESET.CH_RST.next;
                    end
                end
            end
            assign hwif_out.CHANNEL_RESET.CH_RST.value = field_storage.CHANNEL_RESET.CH_RST.value;
            assign hwif_out.CHANNEL_RESET.CH_RST.swmod = decoded_reg_strb.CHANNEL_RESET && decoded_req_is_wr && |(decoded_wr_biten[7:0]);
            // Field: stream_regs.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES
 021934     always_comb begin
                automatic logic [15:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.SCHED_TIMEOUT_CYCLES && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.next = next_c;
 021934         field_combo.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.value <= 16'h3e8;
 002302         end else begin
%000000             if(field_combo.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.load_next) begin
%000000                 field_storage.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.value <= field_combo.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.next;
                    end
                end
            end
            assign hwif_out.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.value = field_storage.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.value;
            // Field: stream_regs.SCHED_CONFIG.SCHED_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.SCHED_CONFIG.SCHED_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.SCHED_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.SCHED_CONFIG.SCHED_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.SCHED_CONFIG.SCHED_EN.next = next_c;
 021934         field_combo.SCHED_CONFIG.SCHED_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.SCHED_CONFIG.SCHED_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.SCHED_CONFIG.SCHED_EN.load_next) begin
%000000                 field_storage.SCHED_CONFIG.SCHED_EN.value <= field_combo.SCHED_CONFIG.SCHED_EN.next;
                    end
                end
            end
            assign hwif_out.SCHED_CONFIG.SCHED_EN.value = field_storage.SCHED_CONFIG.SCHED_EN.value;
            // Field: stream_regs.SCHED_CONFIG.TIMEOUT_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.SCHED_CONFIG.TIMEOUT_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.SCHED_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.SCHED_CONFIG.TIMEOUT_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
%000000             load_next_c = '1;
                end
 021934         field_combo.SCHED_CONFIG.TIMEOUT_EN.next = next_c;
 021934         field_combo.SCHED_CONFIG.TIMEOUT_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.SCHED_CONFIG.TIMEOUT_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.SCHED_CONFIG.TIMEOUT_EN.load_next) begin
%000000                 field_storage.SCHED_CONFIG.TIMEOUT_EN.value <= field_combo.SCHED_CONFIG.TIMEOUT_EN.next;
                    end
                end
            end
            assign hwif_out.SCHED_CONFIG.TIMEOUT_EN.value = field_storage.SCHED_CONFIG.TIMEOUT_EN.value;
            // Field: stream_regs.SCHED_CONFIG.ERR_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.SCHED_CONFIG.ERR_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.SCHED_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.SCHED_CONFIG.ERR_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
%000000             load_next_c = '1;
                end
 021934         field_combo.SCHED_CONFIG.ERR_EN.next = next_c;
 021934         field_combo.SCHED_CONFIG.ERR_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.SCHED_CONFIG.ERR_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.SCHED_CONFIG.ERR_EN.load_next) begin
%000000                 field_storage.SCHED_CONFIG.ERR_EN.value <= field_combo.SCHED_CONFIG.ERR_EN.next;
                    end
                end
            end
            assign hwif_out.SCHED_CONFIG.ERR_EN.value = field_storage.SCHED_CONFIG.ERR_EN.value;
            // Field: stream_regs.SCHED_CONFIG.COMPL_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.SCHED_CONFIG.COMPL_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.SCHED_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.SCHED_CONFIG.COMPL_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
%000000             load_next_c = '1;
                end
 021934         field_combo.SCHED_CONFIG.COMPL_EN.next = next_c;
 021934         field_combo.SCHED_CONFIG.COMPL_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.SCHED_CONFIG.COMPL_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.SCHED_CONFIG.COMPL_EN.load_next) begin
%000000                 field_storage.SCHED_CONFIG.COMPL_EN.value <= field_combo.SCHED_CONFIG.COMPL_EN.next;
                    end
                end
            end
            assign hwif_out.SCHED_CONFIG.COMPL_EN.value = field_storage.SCHED_CONFIG.COMPL_EN.value;
            // Field: stream_regs.SCHED_CONFIG.PERF_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.SCHED_CONFIG.PERF_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.SCHED_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.SCHED_CONFIG.PERF_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
%000000             load_next_c = '1;
                end
 021934         field_combo.SCHED_CONFIG.PERF_EN.next = next_c;
 021934         field_combo.SCHED_CONFIG.PERF_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.SCHED_CONFIG.PERF_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.SCHED_CONFIG.PERF_EN.load_next) begin
%000000                 field_storage.SCHED_CONFIG.PERF_EN.value <= field_combo.SCHED_CONFIG.PERF_EN.next;
                    end
                end
            end
            assign hwif_out.SCHED_CONFIG.PERF_EN.value = field_storage.SCHED_CONFIG.PERF_EN.value;
            // Field: stream_regs.DESCENG_CONFIG.DESCENG_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DESCENG_CONFIG.DESCENG_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DESCENG_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DESCENG_CONFIG.DESCENG_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DESCENG_CONFIG.DESCENG_EN.next = next_c;
 021934         field_combo.DESCENG_CONFIG.DESCENG_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DESCENG_CONFIG.DESCENG_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.DESCENG_CONFIG.DESCENG_EN.load_next) begin
%000000                 field_storage.DESCENG_CONFIG.DESCENG_EN.value <= field_combo.DESCENG_CONFIG.DESCENG_EN.next;
                    end
                end
            end
            assign hwif_out.DESCENG_CONFIG.DESCENG_EN.value = field_storage.DESCENG_CONFIG.DESCENG_EN.value;
            // Field: stream_regs.DESCENG_CONFIG.PREFETCH_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DESCENG_CONFIG.PREFETCH_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DESCENG_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DESCENG_CONFIG.PREFETCH_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DESCENG_CONFIG.PREFETCH_EN.next = next_c;
 021934         field_combo.DESCENG_CONFIG.PREFETCH_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DESCENG_CONFIG.PREFETCH_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.DESCENG_CONFIG.PREFETCH_EN.load_next) begin
%000000                 field_storage.DESCENG_CONFIG.PREFETCH_EN.value <= field_combo.DESCENG_CONFIG.PREFETCH_EN.next;
                    end
                end
            end
            assign hwif_out.DESCENG_CONFIG.PREFETCH_EN.value = field_storage.DESCENG_CONFIG.PREFETCH_EN.value;
            // Field: stream_regs.DESCENG_CONFIG.FIFO_THRESH
 021934     always_comb begin
                automatic logic [3:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DESCENG_CONFIG.FIFO_THRESH.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DESCENG_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DESCENG_CONFIG.FIFO_THRESH.value & ~decoded_wr_biten[5:2]) | (decoded_wr_data[5:2] & decoded_wr_biten[5:2]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DESCENG_CONFIG.FIFO_THRESH.next = next_c;
 021934         field_combo.DESCENG_CONFIG.FIFO_THRESH.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DESCENG_CONFIG.FIFO_THRESH.value <= 4'h8;
 002302         end else begin
%000000             if(field_combo.DESCENG_CONFIG.FIFO_THRESH.load_next) begin
%000000                 field_storage.DESCENG_CONFIG.FIFO_THRESH.value <= field_combo.DESCENG_CONFIG.FIFO_THRESH.next;
                    end
                end
            end
            assign hwif_out.DESCENG_CONFIG.FIFO_THRESH.value = field_storage.DESCENG_CONFIG.FIFO_THRESH.value;
            // Field: stream_regs.DESCENG_ADDR0_BASE.ADDR0_BASE
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DESCENG_ADDR0_BASE.ADDR0_BASE.value;
 021934         load_next_c = '0;
 000036         if(decoded_reg_strb.DESCENG_ADDR0_BASE && decoded_req_is_wr) begin // SW write
 000036             next_c = (field_storage.DESCENG_ADDR0_BASE.ADDR0_BASE.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
 000036             load_next_c = '1;
                end
 021934         field_combo.DESCENG_ADDR0_BASE.ADDR0_BASE.next = next_c;
 021934         field_combo.DESCENG_ADDR0_BASE.ADDR0_BASE.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DESCENG_ADDR0_BASE.ADDR0_BASE.value <= 32'h0;
 002302         end else begin
%000004             if(field_combo.DESCENG_ADDR0_BASE.ADDR0_BASE.load_next) begin
%000004                 field_storage.DESCENG_ADDR0_BASE.ADDR0_BASE.value <= field_combo.DESCENG_ADDR0_BASE.ADDR0_BASE.next;
                    end
                end
            end
            assign hwif_out.DESCENG_ADDR0_BASE.ADDR0_BASE.value = field_storage.DESCENG_ADDR0_BASE.ADDR0_BASE.value;
            // Field: stream_regs.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.value;
 021934         load_next_c = '0;
 000036         if(decoded_reg_strb.DESCENG_ADDR0_LIMIT && decoded_req_is_wr) begin // SW write
 000036             next_c = (field_storage.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
 000036             load_next_c = '1;
                end
 021934         field_combo.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.next = next_c;
 021934         field_combo.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.value <= 32'hffffffff;
 002302         end else begin
%000004             if(field_combo.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.load_next) begin
%000004                 field_storage.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.value <= field_combo.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.next;
                    end
                end
            end
            assign hwif_out.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.value = field_storage.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.value;
            // Field: stream_regs.DESCENG_ADDR1_BASE.ADDR1_BASE
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DESCENG_ADDR1_BASE.ADDR1_BASE.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DESCENG_ADDR1_BASE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DESCENG_ADDR1_BASE.ADDR1_BASE.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DESCENG_ADDR1_BASE.ADDR1_BASE.next = next_c;
 021934         field_combo.DESCENG_ADDR1_BASE.ADDR1_BASE.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DESCENG_ADDR1_BASE.ADDR1_BASE.value <= 32'h0;
 002302         end else begin
%000000             if(field_combo.DESCENG_ADDR1_BASE.ADDR1_BASE.load_next) begin
%000000                 field_storage.DESCENG_ADDR1_BASE.ADDR1_BASE.value <= field_combo.DESCENG_ADDR1_BASE.ADDR1_BASE.next;
                    end
                end
            end
            assign hwif_out.DESCENG_ADDR1_BASE.ADDR1_BASE.value = field_storage.DESCENG_ADDR1_BASE.ADDR1_BASE.value;
            // Field: stream_regs.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DESCENG_ADDR1_LIMIT && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.next = next_c;
 021934         field_combo.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.value <= 32'hffffffff;
 002302         end else begin
%000000             if(field_combo.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.load_next) begin
%000000                 field_storage.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.value <= field_combo.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.next;
                    end
                end
            end
            assign hwif_out.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.value = field_storage.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.value;
            // Field: stream_regs.DAXMON_ENABLE.MON_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_ENABLE.MON_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_ENABLE.MON_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_ENABLE.MON_EN.next = next_c;
 021934         field_combo.DAXMON_ENABLE.MON_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_ENABLE.MON_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.DAXMON_ENABLE.MON_EN.load_next) begin
%000000                 field_storage.DAXMON_ENABLE.MON_EN.value <= field_combo.DAXMON_ENABLE.MON_EN.next;
                    end
                end
            end
            assign hwif_out.DAXMON_ENABLE.MON_EN.value = field_storage.DAXMON_ENABLE.MON_EN.value;
            // Field: stream_regs.DAXMON_ENABLE.ERR_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_ENABLE.ERR_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_ENABLE.ERR_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_ENABLE.ERR_EN.next = next_c;
 021934         field_combo.DAXMON_ENABLE.ERR_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_ENABLE.ERR_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.DAXMON_ENABLE.ERR_EN.load_next) begin
%000000                 field_storage.DAXMON_ENABLE.ERR_EN.value <= field_combo.DAXMON_ENABLE.ERR_EN.next;
                    end
                end
            end
            assign hwif_out.DAXMON_ENABLE.ERR_EN.value = field_storage.DAXMON_ENABLE.ERR_EN.value;
            // Field: stream_regs.DAXMON_ENABLE.COMPL_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_ENABLE.COMPL_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_ENABLE.COMPL_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_ENABLE.COMPL_EN.next = next_c;
 021934         field_combo.DAXMON_ENABLE.COMPL_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_ENABLE.COMPL_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.DAXMON_ENABLE.COMPL_EN.load_next) begin
%000000                 field_storage.DAXMON_ENABLE.COMPL_EN.value <= field_combo.DAXMON_ENABLE.COMPL_EN.next;
                    end
                end
            end
            assign hwif_out.DAXMON_ENABLE.COMPL_EN.value = field_storage.DAXMON_ENABLE.COMPL_EN.value;
            // Field: stream_regs.DAXMON_ENABLE.TIMEOUT_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_ENABLE.TIMEOUT_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_ENABLE.TIMEOUT_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_ENABLE.TIMEOUT_EN.next = next_c;
 021934         field_combo.DAXMON_ENABLE.TIMEOUT_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_ENABLE.TIMEOUT_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.DAXMON_ENABLE.TIMEOUT_EN.load_next) begin
%000000                 field_storage.DAXMON_ENABLE.TIMEOUT_EN.value <= field_combo.DAXMON_ENABLE.TIMEOUT_EN.next;
                    end
                end
            end
            assign hwif_out.DAXMON_ENABLE.TIMEOUT_EN.value = field_storage.DAXMON_ENABLE.TIMEOUT_EN.value;
            // Field: stream_regs.DAXMON_ENABLE.PERF_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_ENABLE.PERF_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_ENABLE.PERF_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_ENABLE.PERF_EN.next = next_c;
 021934         field_combo.DAXMON_ENABLE.PERF_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_ENABLE.PERF_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.DAXMON_ENABLE.PERF_EN.load_next) begin
%000000                 field_storage.DAXMON_ENABLE.PERF_EN.value <= field_combo.DAXMON_ENABLE.PERF_EN.next;
                    end
                end
            end
            assign hwif_out.DAXMON_ENABLE.PERF_EN.value = field_storage.DAXMON_ENABLE.PERF_EN.value;
            // Field: stream_regs.DAXMON_TIMEOUT.TIMEOUT_CYCLES
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_TIMEOUT.TIMEOUT_CYCLES.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_TIMEOUT && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_TIMEOUT.TIMEOUT_CYCLES.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_TIMEOUT.TIMEOUT_CYCLES.next = next_c;
 021934         field_combo.DAXMON_TIMEOUT.TIMEOUT_CYCLES.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_TIMEOUT.TIMEOUT_CYCLES.value <= 32'h2710;
 002302         end else begin
%000000             if(field_combo.DAXMON_TIMEOUT.TIMEOUT_CYCLES.load_next) begin
%000000                 field_storage.DAXMON_TIMEOUT.TIMEOUT_CYCLES.value <= field_combo.DAXMON_TIMEOUT.TIMEOUT_CYCLES.next;
                    end
                end
            end
            assign hwif_out.DAXMON_TIMEOUT.TIMEOUT_CYCLES.value = field_storage.DAXMON_TIMEOUT.TIMEOUT_CYCLES.value;
            // Field: stream_regs.DAXMON_LATENCY_THRESH.LATENCY_THRESH
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_LATENCY_THRESH.LATENCY_THRESH.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_LATENCY_THRESH && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_LATENCY_THRESH.LATENCY_THRESH.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_LATENCY_THRESH.LATENCY_THRESH.next = next_c;
 021934         field_combo.DAXMON_LATENCY_THRESH.LATENCY_THRESH.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_LATENCY_THRESH.LATENCY_THRESH.value <= 32'h1388;
 002302         end else begin
%000000             if(field_combo.DAXMON_LATENCY_THRESH.LATENCY_THRESH.load_next) begin
%000000                 field_storage.DAXMON_LATENCY_THRESH.LATENCY_THRESH.value <= field_combo.DAXMON_LATENCY_THRESH.LATENCY_THRESH.next;
                    end
                end
            end
            assign hwif_out.DAXMON_LATENCY_THRESH.LATENCY_THRESH.value = field_storage.DAXMON_LATENCY_THRESH.LATENCY_THRESH.value;
            // Field: stream_regs.DAXMON_PKT_MASK.PKT_MASK
 021934     always_comb begin
                automatic logic [15:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_PKT_MASK.PKT_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_PKT_MASK && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_PKT_MASK.PKT_MASK.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_PKT_MASK.PKT_MASK.next = next_c;
 021934         field_combo.DAXMON_PKT_MASK.PKT_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_PKT_MASK.PKT_MASK.value <= 16'hffff;
 002302         end else begin
%000000             if(field_combo.DAXMON_PKT_MASK.PKT_MASK.load_next) begin
%000000                 field_storage.DAXMON_PKT_MASK.PKT_MASK.value <= field_combo.DAXMON_PKT_MASK.PKT_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_PKT_MASK.PKT_MASK.value = field_storage.DAXMON_PKT_MASK.PKT_MASK.value;
            // Field: stream_regs.DAXMON_ERR_CFG.ERR_SELECT
 021934     always_comb begin
                automatic logic [3:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_ERR_CFG.ERR_SELECT.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_ERR_CFG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_ERR_CFG.ERR_SELECT.value & ~decoded_wr_biten[3:0]) | (decoded_wr_data[3:0] & decoded_wr_biten[3:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_ERR_CFG.ERR_SELECT.next = next_c;
 021934         field_combo.DAXMON_ERR_CFG.ERR_SELECT.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_ERR_CFG.ERR_SELECT.value <= 4'h0;
 002302         end else begin
%000000             if(field_combo.DAXMON_ERR_CFG.ERR_SELECT.load_next) begin
%000000                 field_storage.DAXMON_ERR_CFG.ERR_SELECT.value <= field_combo.DAXMON_ERR_CFG.ERR_SELECT.next;
                    end
                end
            end
            assign hwif_out.DAXMON_ERR_CFG.ERR_SELECT.value = field_storage.DAXMON_ERR_CFG.ERR_SELECT.value;
            // Field: stream_regs.DAXMON_ERR_CFG.ERR_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_ERR_CFG.ERR_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_ERR_CFG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_ERR_CFG.ERR_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_ERR_CFG.ERR_MASK.next = next_c;
 021934         field_combo.DAXMON_ERR_CFG.ERR_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_ERR_CFG.ERR_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.DAXMON_ERR_CFG.ERR_MASK.load_next) begin
%000000                 field_storage.DAXMON_ERR_CFG.ERR_MASK.value <= field_combo.DAXMON_ERR_CFG.ERR_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_ERR_CFG.ERR_MASK.value = field_storage.DAXMON_ERR_CFG.ERR_MASK.value;
            // Field: stream_regs.DAXMON_MASK1.TIMEOUT_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_MASK1.TIMEOUT_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_MASK1 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_MASK1.TIMEOUT_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_MASK1.TIMEOUT_MASK.next = next_c;
 021934         field_combo.DAXMON_MASK1.TIMEOUT_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_MASK1.TIMEOUT_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.DAXMON_MASK1.TIMEOUT_MASK.load_next) begin
%000000                 field_storage.DAXMON_MASK1.TIMEOUT_MASK.value <= field_combo.DAXMON_MASK1.TIMEOUT_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_MASK1.TIMEOUT_MASK.value = field_storage.DAXMON_MASK1.TIMEOUT_MASK.value;
            // Field: stream_regs.DAXMON_MASK1.COMPL_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_MASK1.COMPL_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_MASK1 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_MASK1.COMPL_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_MASK1.COMPL_MASK.next = next_c;
 021934         field_combo.DAXMON_MASK1.COMPL_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_MASK1.COMPL_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.DAXMON_MASK1.COMPL_MASK.load_next) begin
%000000                 field_storage.DAXMON_MASK1.COMPL_MASK.value <= field_combo.DAXMON_MASK1.COMPL_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_MASK1.COMPL_MASK.value = field_storage.DAXMON_MASK1.COMPL_MASK.value;
            // Field: stream_regs.DAXMON_MASK2.THRESH_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_MASK2.THRESH_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_MASK2 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_MASK2.THRESH_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_MASK2.THRESH_MASK.next = next_c;
 021934         field_combo.DAXMON_MASK2.THRESH_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_MASK2.THRESH_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.DAXMON_MASK2.THRESH_MASK.load_next) begin
%000000                 field_storage.DAXMON_MASK2.THRESH_MASK.value <= field_combo.DAXMON_MASK2.THRESH_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_MASK2.THRESH_MASK.value = field_storage.DAXMON_MASK2.THRESH_MASK.value;
            // Field: stream_regs.DAXMON_MASK2.PERF_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_MASK2.PERF_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_MASK2 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_MASK2.PERF_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_MASK2.PERF_MASK.next = next_c;
 021934         field_combo.DAXMON_MASK2.PERF_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_MASK2.PERF_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.DAXMON_MASK2.PERF_MASK.load_next) begin
%000000                 field_storage.DAXMON_MASK2.PERF_MASK.value <= field_combo.DAXMON_MASK2.PERF_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_MASK2.PERF_MASK.value = field_storage.DAXMON_MASK2.PERF_MASK.value;
            // Field: stream_regs.DAXMON_MASK3.ADDR_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_MASK3.ADDR_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_MASK3 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_MASK3.ADDR_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_MASK3.ADDR_MASK.next = next_c;
 021934         field_combo.DAXMON_MASK3.ADDR_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_MASK3.ADDR_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.DAXMON_MASK3.ADDR_MASK.load_next) begin
%000000                 field_storage.DAXMON_MASK3.ADDR_MASK.value <= field_combo.DAXMON_MASK3.ADDR_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_MASK3.ADDR_MASK.value = field_storage.DAXMON_MASK3.ADDR_MASK.value;
            // Field: stream_regs.DAXMON_MASK3.DEBUG_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.DAXMON_MASK3.DEBUG_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.DAXMON_MASK3 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.DAXMON_MASK3.DEBUG_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.DAXMON_MASK3.DEBUG_MASK.next = next_c;
 021934         field_combo.DAXMON_MASK3.DEBUG_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.DAXMON_MASK3.DEBUG_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.DAXMON_MASK3.DEBUG_MASK.load_next) begin
%000000                 field_storage.DAXMON_MASK3.DEBUG_MASK.value <= field_combo.DAXMON_MASK3.DEBUG_MASK.next;
                    end
                end
            end
            assign hwif_out.DAXMON_MASK3.DEBUG_MASK.value = field_storage.DAXMON_MASK3.DEBUG_MASK.value;
            // Field: stream_regs.RDMON_ENABLE.MON_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_ENABLE.MON_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_ENABLE.MON_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_ENABLE.MON_EN.next = next_c;
 021934         field_combo.RDMON_ENABLE.MON_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_ENABLE.MON_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.RDMON_ENABLE.MON_EN.load_next) begin
%000000                 field_storage.RDMON_ENABLE.MON_EN.value <= field_combo.RDMON_ENABLE.MON_EN.next;
                    end
                end
            end
            assign hwif_out.RDMON_ENABLE.MON_EN.value = field_storage.RDMON_ENABLE.MON_EN.value;
            // Field: stream_regs.RDMON_ENABLE.ERR_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_ENABLE.ERR_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_ENABLE.ERR_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_ENABLE.ERR_EN.next = next_c;
 021934         field_combo.RDMON_ENABLE.ERR_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_ENABLE.ERR_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.RDMON_ENABLE.ERR_EN.load_next) begin
%000000                 field_storage.RDMON_ENABLE.ERR_EN.value <= field_combo.RDMON_ENABLE.ERR_EN.next;
                    end
                end
            end
            assign hwif_out.RDMON_ENABLE.ERR_EN.value = field_storage.RDMON_ENABLE.ERR_EN.value;
            // Field: stream_regs.RDMON_ENABLE.COMPL_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_ENABLE.COMPL_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_ENABLE.COMPL_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_ENABLE.COMPL_EN.next = next_c;
 021934         field_combo.RDMON_ENABLE.COMPL_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_ENABLE.COMPL_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.RDMON_ENABLE.COMPL_EN.load_next) begin
%000000                 field_storage.RDMON_ENABLE.COMPL_EN.value <= field_combo.RDMON_ENABLE.COMPL_EN.next;
                    end
                end
            end
            assign hwif_out.RDMON_ENABLE.COMPL_EN.value = field_storage.RDMON_ENABLE.COMPL_EN.value;
            // Field: stream_regs.RDMON_ENABLE.TIMEOUT_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_ENABLE.TIMEOUT_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_ENABLE.TIMEOUT_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_ENABLE.TIMEOUT_EN.next = next_c;
 021934         field_combo.RDMON_ENABLE.TIMEOUT_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_ENABLE.TIMEOUT_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.RDMON_ENABLE.TIMEOUT_EN.load_next) begin
%000000                 field_storage.RDMON_ENABLE.TIMEOUT_EN.value <= field_combo.RDMON_ENABLE.TIMEOUT_EN.next;
                    end
                end
            end
            assign hwif_out.RDMON_ENABLE.TIMEOUT_EN.value = field_storage.RDMON_ENABLE.TIMEOUT_EN.value;
            // Field: stream_regs.RDMON_ENABLE.PERF_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_ENABLE.PERF_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_ENABLE.PERF_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_ENABLE.PERF_EN.next = next_c;
 021934         field_combo.RDMON_ENABLE.PERF_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_ENABLE.PERF_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.RDMON_ENABLE.PERF_EN.load_next) begin
%000000                 field_storage.RDMON_ENABLE.PERF_EN.value <= field_combo.RDMON_ENABLE.PERF_EN.next;
                    end
                end
            end
            assign hwif_out.RDMON_ENABLE.PERF_EN.value = field_storage.RDMON_ENABLE.PERF_EN.value;
            // Field: stream_regs.RDMON_TIMEOUT.TIMEOUT_CYCLES
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_TIMEOUT.TIMEOUT_CYCLES.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_TIMEOUT && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_TIMEOUT.TIMEOUT_CYCLES.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_TIMEOUT.TIMEOUT_CYCLES.next = next_c;
 021934         field_combo.RDMON_TIMEOUT.TIMEOUT_CYCLES.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_TIMEOUT.TIMEOUT_CYCLES.value <= 32'h2710;
 002302         end else begin
%000000             if(field_combo.RDMON_TIMEOUT.TIMEOUT_CYCLES.load_next) begin
%000000                 field_storage.RDMON_TIMEOUT.TIMEOUT_CYCLES.value <= field_combo.RDMON_TIMEOUT.TIMEOUT_CYCLES.next;
                    end
                end
            end
            assign hwif_out.RDMON_TIMEOUT.TIMEOUT_CYCLES.value = field_storage.RDMON_TIMEOUT.TIMEOUT_CYCLES.value;
            // Field: stream_regs.RDMON_LATENCY_THRESH.LATENCY_THRESH
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_LATENCY_THRESH.LATENCY_THRESH.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_LATENCY_THRESH && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_LATENCY_THRESH.LATENCY_THRESH.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_LATENCY_THRESH.LATENCY_THRESH.next = next_c;
 021934         field_combo.RDMON_LATENCY_THRESH.LATENCY_THRESH.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_LATENCY_THRESH.LATENCY_THRESH.value <= 32'h1388;
 002302         end else begin
%000000             if(field_combo.RDMON_LATENCY_THRESH.LATENCY_THRESH.load_next) begin
%000000                 field_storage.RDMON_LATENCY_THRESH.LATENCY_THRESH.value <= field_combo.RDMON_LATENCY_THRESH.LATENCY_THRESH.next;
                    end
                end
            end
            assign hwif_out.RDMON_LATENCY_THRESH.LATENCY_THRESH.value = field_storage.RDMON_LATENCY_THRESH.LATENCY_THRESH.value;
            // Field: stream_regs.RDMON_PKT_MASK.PKT_MASK
 021934     always_comb begin
                automatic logic [15:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_PKT_MASK.PKT_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_PKT_MASK && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_PKT_MASK.PKT_MASK.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_PKT_MASK.PKT_MASK.next = next_c;
 021934         field_combo.RDMON_PKT_MASK.PKT_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_PKT_MASK.PKT_MASK.value <= 16'hffff;
 002302         end else begin
%000000             if(field_combo.RDMON_PKT_MASK.PKT_MASK.load_next) begin
%000000                 field_storage.RDMON_PKT_MASK.PKT_MASK.value <= field_combo.RDMON_PKT_MASK.PKT_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_PKT_MASK.PKT_MASK.value = field_storage.RDMON_PKT_MASK.PKT_MASK.value;
            // Field: stream_regs.RDMON_ERR_CFG.ERR_SELECT
 021934     always_comb begin
                automatic logic [3:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_ERR_CFG.ERR_SELECT.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_ERR_CFG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_ERR_CFG.ERR_SELECT.value & ~decoded_wr_biten[3:0]) | (decoded_wr_data[3:0] & decoded_wr_biten[3:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_ERR_CFG.ERR_SELECT.next = next_c;
 021934         field_combo.RDMON_ERR_CFG.ERR_SELECT.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_ERR_CFG.ERR_SELECT.value <= 4'h0;
 002302         end else begin
%000000             if(field_combo.RDMON_ERR_CFG.ERR_SELECT.load_next) begin
%000000                 field_storage.RDMON_ERR_CFG.ERR_SELECT.value <= field_combo.RDMON_ERR_CFG.ERR_SELECT.next;
                    end
                end
            end
            assign hwif_out.RDMON_ERR_CFG.ERR_SELECT.value = field_storage.RDMON_ERR_CFG.ERR_SELECT.value;
            // Field: stream_regs.RDMON_ERR_CFG.ERR_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_ERR_CFG.ERR_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_ERR_CFG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_ERR_CFG.ERR_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_ERR_CFG.ERR_MASK.next = next_c;
 021934         field_combo.RDMON_ERR_CFG.ERR_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_ERR_CFG.ERR_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.RDMON_ERR_CFG.ERR_MASK.load_next) begin
%000000                 field_storage.RDMON_ERR_CFG.ERR_MASK.value <= field_combo.RDMON_ERR_CFG.ERR_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_ERR_CFG.ERR_MASK.value = field_storage.RDMON_ERR_CFG.ERR_MASK.value;
            // Field: stream_regs.RDMON_MASK1.TIMEOUT_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_MASK1.TIMEOUT_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_MASK1 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_MASK1.TIMEOUT_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_MASK1.TIMEOUT_MASK.next = next_c;
 021934         field_combo.RDMON_MASK1.TIMEOUT_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_MASK1.TIMEOUT_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.RDMON_MASK1.TIMEOUT_MASK.load_next) begin
%000000                 field_storage.RDMON_MASK1.TIMEOUT_MASK.value <= field_combo.RDMON_MASK1.TIMEOUT_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_MASK1.TIMEOUT_MASK.value = field_storage.RDMON_MASK1.TIMEOUT_MASK.value;
            // Field: stream_regs.RDMON_MASK1.COMPL_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_MASK1.COMPL_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_MASK1 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_MASK1.COMPL_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_MASK1.COMPL_MASK.next = next_c;
 021934         field_combo.RDMON_MASK1.COMPL_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_MASK1.COMPL_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.RDMON_MASK1.COMPL_MASK.load_next) begin
%000000                 field_storage.RDMON_MASK1.COMPL_MASK.value <= field_combo.RDMON_MASK1.COMPL_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_MASK1.COMPL_MASK.value = field_storage.RDMON_MASK1.COMPL_MASK.value;
            // Field: stream_regs.RDMON_MASK2.THRESH_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_MASK2.THRESH_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_MASK2 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_MASK2.THRESH_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_MASK2.THRESH_MASK.next = next_c;
 021934         field_combo.RDMON_MASK2.THRESH_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_MASK2.THRESH_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.RDMON_MASK2.THRESH_MASK.load_next) begin
%000000                 field_storage.RDMON_MASK2.THRESH_MASK.value <= field_combo.RDMON_MASK2.THRESH_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_MASK2.THRESH_MASK.value = field_storage.RDMON_MASK2.THRESH_MASK.value;
            // Field: stream_regs.RDMON_MASK2.PERF_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_MASK2.PERF_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_MASK2 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_MASK2.PERF_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_MASK2.PERF_MASK.next = next_c;
 021934         field_combo.RDMON_MASK2.PERF_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_MASK2.PERF_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.RDMON_MASK2.PERF_MASK.load_next) begin
%000000                 field_storage.RDMON_MASK2.PERF_MASK.value <= field_combo.RDMON_MASK2.PERF_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_MASK2.PERF_MASK.value = field_storage.RDMON_MASK2.PERF_MASK.value;
            // Field: stream_regs.RDMON_MASK3.ADDR_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_MASK3.ADDR_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_MASK3 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_MASK3.ADDR_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_MASK3.ADDR_MASK.next = next_c;
 021934         field_combo.RDMON_MASK3.ADDR_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_MASK3.ADDR_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.RDMON_MASK3.ADDR_MASK.load_next) begin
%000000                 field_storage.RDMON_MASK3.ADDR_MASK.value <= field_combo.RDMON_MASK3.ADDR_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_MASK3.ADDR_MASK.value = field_storage.RDMON_MASK3.ADDR_MASK.value;
            // Field: stream_regs.RDMON_MASK3.DEBUG_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.RDMON_MASK3.DEBUG_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.RDMON_MASK3 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.RDMON_MASK3.DEBUG_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.RDMON_MASK3.DEBUG_MASK.next = next_c;
 021934         field_combo.RDMON_MASK3.DEBUG_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.RDMON_MASK3.DEBUG_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.RDMON_MASK3.DEBUG_MASK.load_next) begin
%000000                 field_storage.RDMON_MASK3.DEBUG_MASK.value <= field_combo.RDMON_MASK3.DEBUG_MASK.next;
                    end
                end
            end
            assign hwif_out.RDMON_MASK3.DEBUG_MASK.value = field_storage.RDMON_MASK3.DEBUG_MASK.value;
            // Field: stream_regs.WRMON_ENABLE.MON_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_ENABLE.MON_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_ENABLE.MON_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_ENABLE.MON_EN.next = next_c;
 021934         field_combo.WRMON_ENABLE.MON_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_ENABLE.MON_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.WRMON_ENABLE.MON_EN.load_next) begin
%000000                 field_storage.WRMON_ENABLE.MON_EN.value <= field_combo.WRMON_ENABLE.MON_EN.next;
                    end
                end
            end
            assign hwif_out.WRMON_ENABLE.MON_EN.value = field_storage.WRMON_ENABLE.MON_EN.value;
            // Field: stream_regs.WRMON_ENABLE.ERR_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_ENABLE.ERR_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_ENABLE.ERR_EN.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_ENABLE.ERR_EN.next = next_c;
 021934         field_combo.WRMON_ENABLE.ERR_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_ENABLE.ERR_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.WRMON_ENABLE.ERR_EN.load_next) begin
%000000                 field_storage.WRMON_ENABLE.ERR_EN.value <= field_combo.WRMON_ENABLE.ERR_EN.next;
                    end
                end
            end
            assign hwif_out.WRMON_ENABLE.ERR_EN.value = field_storage.WRMON_ENABLE.ERR_EN.value;
            // Field: stream_regs.WRMON_ENABLE.COMPL_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_ENABLE.COMPL_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_ENABLE.COMPL_EN.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_ENABLE.COMPL_EN.next = next_c;
 021934         field_combo.WRMON_ENABLE.COMPL_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_ENABLE.COMPL_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.WRMON_ENABLE.COMPL_EN.load_next) begin
%000000                 field_storage.WRMON_ENABLE.COMPL_EN.value <= field_combo.WRMON_ENABLE.COMPL_EN.next;
                    end
                end
            end
            assign hwif_out.WRMON_ENABLE.COMPL_EN.value = field_storage.WRMON_ENABLE.COMPL_EN.value;
            // Field: stream_regs.WRMON_ENABLE.TIMEOUT_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_ENABLE.TIMEOUT_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_ENABLE.TIMEOUT_EN.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_ENABLE.TIMEOUT_EN.next = next_c;
 021934         field_combo.WRMON_ENABLE.TIMEOUT_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_ENABLE.TIMEOUT_EN.value <= 1'h1;
 002302         end else begin
%000000             if(field_combo.WRMON_ENABLE.TIMEOUT_EN.load_next) begin
%000000                 field_storage.WRMON_ENABLE.TIMEOUT_EN.value <= field_combo.WRMON_ENABLE.TIMEOUT_EN.next;
                    end
                end
            end
            assign hwif_out.WRMON_ENABLE.TIMEOUT_EN.value = field_storage.WRMON_ENABLE.TIMEOUT_EN.value;
            // Field: stream_regs.WRMON_ENABLE.PERF_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_ENABLE.PERF_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_ENABLE && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_ENABLE.PERF_EN.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_ENABLE.PERF_EN.next = next_c;
 021934         field_combo.WRMON_ENABLE.PERF_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_ENABLE.PERF_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.WRMON_ENABLE.PERF_EN.load_next) begin
%000000                 field_storage.WRMON_ENABLE.PERF_EN.value <= field_combo.WRMON_ENABLE.PERF_EN.next;
                    end
                end
            end
            assign hwif_out.WRMON_ENABLE.PERF_EN.value = field_storage.WRMON_ENABLE.PERF_EN.value;
            // Field: stream_regs.WRMON_TIMEOUT.TIMEOUT_CYCLES
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_TIMEOUT.TIMEOUT_CYCLES.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_TIMEOUT && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_TIMEOUT.TIMEOUT_CYCLES.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_TIMEOUT.TIMEOUT_CYCLES.next = next_c;
 021934         field_combo.WRMON_TIMEOUT.TIMEOUT_CYCLES.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_TIMEOUT.TIMEOUT_CYCLES.value <= 32'h2710;
 002302         end else begin
%000000             if(field_combo.WRMON_TIMEOUT.TIMEOUT_CYCLES.load_next) begin
%000000                 field_storage.WRMON_TIMEOUT.TIMEOUT_CYCLES.value <= field_combo.WRMON_TIMEOUT.TIMEOUT_CYCLES.next;
                    end
                end
            end
            assign hwif_out.WRMON_TIMEOUT.TIMEOUT_CYCLES.value = field_storage.WRMON_TIMEOUT.TIMEOUT_CYCLES.value;
            // Field: stream_regs.WRMON_LATENCY_THRESH.LATENCY_THRESH
 021934     always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_LATENCY_THRESH.LATENCY_THRESH.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_LATENCY_THRESH && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_LATENCY_THRESH.LATENCY_THRESH.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_LATENCY_THRESH.LATENCY_THRESH.next = next_c;
 021934         field_combo.WRMON_LATENCY_THRESH.LATENCY_THRESH.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_LATENCY_THRESH.LATENCY_THRESH.value <= 32'h1388;
 002302         end else begin
%000000             if(field_combo.WRMON_LATENCY_THRESH.LATENCY_THRESH.load_next) begin
%000000                 field_storage.WRMON_LATENCY_THRESH.LATENCY_THRESH.value <= field_combo.WRMON_LATENCY_THRESH.LATENCY_THRESH.next;
                    end
                end
            end
            assign hwif_out.WRMON_LATENCY_THRESH.LATENCY_THRESH.value = field_storage.WRMON_LATENCY_THRESH.LATENCY_THRESH.value;
            // Field: stream_regs.WRMON_PKT_MASK.PKT_MASK
 021934     always_comb begin
                automatic logic [15:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_PKT_MASK.PKT_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_PKT_MASK && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_PKT_MASK.PKT_MASK.value & ~decoded_wr_biten[15:0]) | (decoded_wr_data[15:0] & decoded_wr_biten[15:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_PKT_MASK.PKT_MASK.next = next_c;
 021934         field_combo.WRMON_PKT_MASK.PKT_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_PKT_MASK.PKT_MASK.value <= 16'hffff;
 002302         end else begin
%000000             if(field_combo.WRMON_PKT_MASK.PKT_MASK.load_next) begin
%000000                 field_storage.WRMON_PKT_MASK.PKT_MASK.value <= field_combo.WRMON_PKT_MASK.PKT_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_PKT_MASK.PKT_MASK.value = field_storage.WRMON_PKT_MASK.PKT_MASK.value;
            // Field: stream_regs.WRMON_ERR_CFG.ERR_SELECT
 021934     always_comb begin
                automatic logic [3:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_ERR_CFG.ERR_SELECT.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_ERR_CFG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_ERR_CFG.ERR_SELECT.value & ~decoded_wr_biten[3:0]) | (decoded_wr_data[3:0] & decoded_wr_biten[3:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_ERR_CFG.ERR_SELECT.next = next_c;
 021934         field_combo.WRMON_ERR_CFG.ERR_SELECT.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_ERR_CFG.ERR_SELECT.value <= 4'h0;
 002302         end else begin
%000000             if(field_combo.WRMON_ERR_CFG.ERR_SELECT.load_next) begin
%000000                 field_storage.WRMON_ERR_CFG.ERR_SELECT.value <= field_combo.WRMON_ERR_CFG.ERR_SELECT.next;
                    end
                end
            end
            assign hwif_out.WRMON_ERR_CFG.ERR_SELECT.value = field_storage.WRMON_ERR_CFG.ERR_SELECT.value;
            // Field: stream_regs.WRMON_ERR_CFG.ERR_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_ERR_CFG.ERR_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_ERR_CFG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_ERR_CFG.ERR_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_ERR_CFG.ERR_MASK.next = next_c;
 021934         field_combo.WRMON_ERR_CFG.ERR_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_ERR_CFG.ERR_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.WRMON_ERR_CFG.ERR_MASK.load_next) begin
%000000                 field_storage.WRMON_ERR_CFG.ERR_MASK.value <= field_combo.WRMON_ERR_CFG.ERR_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_ERR_CFG.ERR_MASK.value = field_storage.WRMON_ERR_CFG.ERR_MASK.value;
            // Field: stream_regs.WRMON_MASK1.TIMEOUT_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_MASK1.TIMEOUT_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_MASK1 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_MASK1.TIMEOUT_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_MASK1.TIMEOUT_MASK.next = next_c;
 021934         field_combo.WRMON_MASK1.TIMEOUT_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_MASK1.TIMEOUT_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.WRMON_MASK1.TIMEOUT_MASK.load_next) begin
%000000                 field_storage.WRMON_MASK1.TIMEOUT_MASK.value <= field_combo.WRMON_MASK1.TIMEOUT_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_MASK1.TIMEOUT_MASK.value = field_storage.WRMON_MASK1.TIMEOUT_MASK.value;
            // Field: stream_regs.WRMON_MASK1.COMPL_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_MASK1.COMPL_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_MASK1 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_MASK1.COMPL_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_MASK1.COMPL_MASK.next = next_c;
 021934         field_combo.WRMON_MASK1.COMPL_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_MASK1.COMPL_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.WRMON_MASK1.COMPL_MASK.load_next) begin
%000000                 field_storage.WRMON_MASK1.COMPL_MASK.value <= field_combo.WRMON_MASK1.COMPL_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_MASK1.COMPL_MASK.value = field_storage.WRMON_MASK1.COMPL_MASK.value;
            // Field: stream_regs.WRMON_MASK2.THRESH_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_MASK2.THRESH_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_MASK2 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_MASK2.THRESH_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_MASK2.THRESH_MASK.next = next_c;
 021934         field_combo.WRMON_MASK2.THRESH_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_MASK2.THRESH_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.WRMON_MASK2.THRESH_MASK.load_next) begin
%000000                 field_storage.WRMON_MASK2.THRESH_MASK.value <= field_combo.WRMON_MASK2.THRESH_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_MASK2.THRESH_MASK.value = field_storage.WRMON_MASK2.THRESH_MASK.value;
            // Field: stream_regs.WRMON_MASK2.PERF_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_MASK2.PERF_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_MASK2 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_MASK2.PERF_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_MASK2.PERF_MASK.next = next_c;
 021934         field_combo.WRMON_MASK2.PERF_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_MASK2.PERF_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.WRMON_MASK2.PERF_MASK.load_next) begin
%000000                 field_storage.WRMON_MASK2.PERF_MASK.value <= field_combo.WRMON_MASK2.PERF_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_MASK2.PERF_MASK.value = field_storage.WRMON_MASK2.PERF_MASK.value;
            // Field: stream_regs.WRMON_MASK3.ADDR_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_MASK3.ADDR_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_MASK3 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_MASK3.ADDR_MASK.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_MASK3.ADDR_MASK.next = next_c;
 021934         field_combo.WRMON_MASK3.ADDR_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_MASK3.ADDR_MASK.value <= 8'hff;
 002302         end else begin
%000000             if(field_combo.WRMON_MASK3.ADDR_MASK.load_next) begin
%000000                 field_storage.WRMON_MASK3.ADDR_MASK.value <= field_combo.WRMON_MASK3.ADDR_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_MASK3.ADDR_MASK.value = field_storage.WRMON_MASK3.ADDR_MASK.value;
            // Field: stream_regs.WRMON_MASK3.DEBUG_MASK
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.WRMON_MASK3.DEBUG_MASK.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.WRMON_MASK3 && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.WRMON_MASK3.DEBUG_MASK.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
%000000             load_next_c = '1;
                end
 021934         field_combo.WRMON_MASK3.DEBUG_MASK.next = next_c;
 021934         field_combo.WRMON_MASK3.DEBUG_MASK.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.WRMON_MASK3.DEBUG_MASK.value <= 8'h0;
 002302         end else begin
%000000             if(field_combo.WRMON_MASK3.DEBUG_MASK.load_next) begin
%000000                 field_storage.WRMON_MASK3.DEBUG_MASK.value <= field_combo.WRMON_MASK3.DEBUG_MASK.next;
                    end
                end
            end
            assign hwif_out.WRMON_MASK3.DEBUG_MASK.value = field_storage.WRMON_MASK3.DEBUG_MASK.value;
            // Field: stream_regs.AXI_XFER_CONFIG.RD_XFER_BEATS
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.AXI_XFER_CONFIG.RD_XFER_BEATS.value;
 021934         load_next_c = '0;
 000036         if(decoded_reg_strb.AXI_XFER_CONFIG && decoded_req_is_wr) begin // SW write
 000036             next_c = (field_storage.AXI_XFER_CONFIG.RD_XFER_BEATS.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
 000036             load_next_c = '1;
                end
 021934         field_combo.AXI_XFER_CONFIG.RD_XFER_BEATS.next = next_c;
 021934         field_combo.AXI_XFER_CONFIG.RD_XFER_BEATS.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.AXI_XFER_CONFIG.RD_XFER_BEATS.value <= 8'hf;
 002302         end else begin
%000004             if(field_combo.AXI_XFER_CONFIG.RD_XFER_BEATS.load_next) begin
%000004                 field_storage.AXI_XFER_CONFIG.RD_XFER_BEATS.value <= field_combo.AXI_XFER_CONFIG.RD_XFER_BEATS.next;
                    end
                end
            end
            assign hwif_out.AXI_XFER_CONFIG.RD_XFER_BEATS.value = field_storage.AXI_XFER_CONFIG.RD_XFER_BEATS.value;
            // Field: stream_regs.AXI_XFER_CONFIG.WR_XFER_BEATS
 021934     always_comb begin
                automatic logic [7:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.AXI_XFER_CONFIG.WR_XFER_BEATS.value;
 021934         load_next_c = '0;
 000036         if(decoded_reg_strb.AXI_XFER_CONFIG && decoded_req_is_wr) begin // SW write
 000036             next_c = (field_storage.AXI_XFER_CONFIG.WR_XFER_BEATS.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
 000036             load_next_c = '1;
                end
 021934         field_combo.AXI_XFER_CONFIG.WR_XFER_BEATS.next = next_c;
 021934         field_combo.AXI_XFER_CONFIG.WR_XFER_BEATS.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.AXI_XFER_CONFIG.WR_XFER_BEATS.value <= 8'hf;
 002302         end else begin
%000004             if(field_combo.AXI_XFER_CONFIG.WR_XFER_BEATS.load_next) begin
%000004                 field_storage.AXI_XFER_CONFIG.WR_XFER_BEATS.value <= field_combo.AXI_XFER_CONFIG.WR_XFER_BEATS.next;
                    end
                end
            end
            assign hwif_out.AXI_XFER_CONFIG.WR_XFER_BEATS.value = field_storage.AXI_XFER_CONFIG.WR_XFER_BEATS.value;
            // Field: stream_regs.PERF_CONFIG.PERF_EN
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.PERF_CONFIG.PERF_EN.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.PERF_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.PERF_CONFIG.PERF_EN.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
%000000             load_next_c = '1;
                end
 021934         field_combo.PERF_CONFIG.PERF_EN.next = next_c;
 021934         field_combo.PERF_CONFIG.PERF_EN.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.PERF_CONFIG.PERF_EN.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.PERF_CONFIG.PERF_EN.load_next) begin
%000000                 field_storage.PERF_CONFIG.PERF_EN.value <= field_combo.PERF_CONFIG.PERF_EN.next;
                    end
                end
            end
            assign hwif_out.PERF_CONFIG.PERF_EN.value = field_storage.PERF_CONFIG.PERF_EN.value;
            // Field: stream_regs.PERF_CONFIG.PERF_MODE
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.PERF_CONFIG.PERF_MODE.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.PERF_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.PERF_CONFIG.PERF_MODE.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
%000000             load_next_c = '1;
                end
 021934         field_combo.PERF_CONFIG.PERF_MODE.next = next_c;
 021934         field_combo.PERF_CONFIG.PERF_MODE.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.PERF_CONFIG.PERF_MODE.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.PERF_CONFIG.PERF_MODE.load_next) begin
%000000                 field_storage.PERF_CONFIG.PERF_MODE.value <= field_combo.PERF_CONFIG.PERF_MODE.next;
                    end
                end
            end
            assign hwif_out.PERF_CONFIG.PERF_MODE.value = field_storage.PERF_CONFIG.PERF_MODE.value;
            // Field: stream_regs.PERF_CONFIG.PERF_CLEAR
 021934     always_comb begin
                automatic logic [0:0] next_c;
                automatic logic load_next_c;
 021934         next_c = field_storage.PERF_CONFIG.PERF_CLEAR.value;
 021934         load_next_c = '0;
%000000         if(decoded_reg_strb.PERF_CONFIG && decoded_req_is_wr) begin // SW write
%000000             next_c = (field_storage.PERF_CONFIG.PERF_CLEAR.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
%000000             load_next_c = '1;
                end
 021934         field_combo.PERF_CONFIG.PERF_CLEAR.next = next_c;
 021934         field_combo.PERF_CONFIG.PERF_CLEAR.load_next = load_next_c;
            end
 002324     always_ff @(posedge clk) begin
 000022         if(rst) begin
 000022             field_storage.PERF_CONFIG.PERF_CLEAR.value <= 1'h0;
 002302         end else begin
%000000             if(field_combo.PERF_CONFIG.PERF_CLEAR.load_next) begin
%000000                 field_storage.PERF_CONFIG.PERF_CLEAR.value <= field_combo.PERF_CONFIG.PERF_CLEAR.next;
                    end
                end
            end
            assign hwif_out.PERF_CONFIG.PERF_CLEAR.value = field_storage.PERF_CONFIG.PERF_CLEAR.value;
            assign hwif_out.PERF_CONFIG.PERF_CLEAR.swmod = decoded_reg_strb.PERF_CONFIG && decoded_req_is_wr && |(decoded_wr_biten[2:2]);
        
            //--------------------------------------------------------------------------
            // Write response
            //--------------------------------------------------------------------------
            assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
            // Writes are always granted with no error response
            assign cpuif_wr_err = '0;
        
            //--------------------------------------------------------------------------
            // Readback
            //--------------------------------------------------------------------------
        
%000000     logic readback_err;
 000020     logic readback_done;
%000000     logic [31:0] readback_data;
        
            // Assign readback values to a flattened array
            logic [31:0] readback_array[49];
            assign readback_array[0][0:0] = (decoded_reg_strb.GLOBAL_CTRL && !decoded_req_is_wr) ? field_storage.GLOBAL_CTRL.GLOBAL_EN.value : '0;
            assign readback_array[0][1:1] = (decoded_reg_strb.GLOBAL_CTRL && !decoded_req_is_wr) ? field_storage.GLOBAL_CTRL.GLOBAL_RST.value : '0;
            assign readback_array[0][31:2] = (decoded_reg_strb.GLOBAL_CTRL && !decoded_req_is_wr) ? 30'h0 : '0;
            assign readback_array[1][0:0] = (decoded_reg_strb.GLOBAL_STATUS && !decoded_req_is_wr) ? hwif_in.GLOBAL_STATUS.SYSTEM_IDLE.next : '0;
            assign readback_array[1][31:1] = (decoded_reg_strb.GLOBAL_STATUS && !decoded_req_is_wr) ? 31'h0 : '0;
            assign readback_array[2][7:0] = (decoded_reg_strb.VERSION && !decoded_req_is_wr) ? 8'h5a : '0;
            assign readback_array[2][15:8] = (decoded_reg_strb.VERSION && !decoded_req_is_wr) ? 8'h0 : '0;
            assign readback_array[2][23:16] = (decoded_reg_strb.VERSION && !decoded_req_is_wr) ? 8'h8 : '0;
            assign readback_array[2][31:24] = (decoded_reg_strb.VERSION && !decoded_req_is_wr) ? 8'h0 : '0;
            assign readback_array[3][7:0] = (decoded_reg_strb.CHANNEL_ENABLE && !decoded_req_is_wr) ? field_storage.CHANNEL_ENABLE.CH_EN.value : '0;
            assign readback_array[3][31:8] = (decoded_reg_strb.CHANNEL_ENABLE && !decoded_req_is_wr) ? 24'h0 : '0;
            assign readback_array[4][7:0] = (decoded_reg_strb.CHANNEL_RESET && !decoded_req_is_wr) ? field_storage.CHANNEL_RESET.CH_RST.value : '0;
            assign readback_array[4][31:8] = (decoded_reg_strb.CHANNEL_RESET && !decoded_req_is_wr) ? 24'h0 : '0;
            assign readback_array[5][7:0] = (decoded_reg_strb.CHANNEL_IDLE && !decoded_req_is_wr) ? hwif_in.CHANNEL_IDLE.CH_IDLE.next : '0;
            assign readback_array[5][31:8] = (decoded_reg_strb.CHANNEL_IDLE && !decoded_req_is_wr) ? 24'h0 : '0;
            assign readback_array[6][7:0] = (decoded_reg_strb.DESC_ENGINE_IDLE && !decoded_req_is_wr) ? hwif_in.DESC_ENGINE_IDLE.DESC_IDLE.next : '0;
            assign readback_array[6][31:8] = (decoded_reg_strb.DESC_ENGINE_IDLE && !decoded_req_is_wr) ? 24'h0 : '0;
            assign readback_array[7][7:0] = (decoded_reg_strb.SCHEDULER_IDLE && !decoded_req_is_wr) ? hwif_in.SCHEDULER_IDLE.SCHED_IDLE.next : '0;
            assign readback_array[7][31:8] = (decoded_reg_strb.SCHEDULER_IDLE && !decoded_req_is_wr) ? 24'h0 : '0;
            for(genvar i0=0; i0<8; i0++) begin
                assign readback_array[i0 * 1 + 8][6:0] = (decoded_reg_strb.CH_STATE[i0].STATE && !decoded_req_is_wr) ? hwif_in.CH_STATE[i0].STATE.STATE.next : '0;
                assign readback_array[i0 * 1 + 8][31:7] = (decoded_reg_strb.CH_STATE[i0].STATE && !decoded_req_is_wr) ? 25'h0 : '0;
            end
            assign readback_array[16][15:0] = (decoded_reg_strb.SCHED_TIMEOUT_CYCLES && !decoded_req_is_wr) ? field_storage.SCHED_TIMEOUT_CYCLES.TIMEOUT_CYCLES.value : '0;
            assign readback_array[16][31:16] = (decoded_reg_strb.SCHED_TIMEOUT_CYCLES && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[17][0:0] = (decoded_reg_strb.SCHED_CONFIG && !decoded_req_is_wr) ? field_storage.SCHED_CONFIG.SCHED_EN.value : '0;
            assign readback_array[17][1:1] = (decoded_reg_strb.SCHED_CONFIG && !decoded_req_is_wr) ? field_storage.SCHED_CONFIG.TIMEOUT_EN.value : '0;
            assign readback_array[17][2:2] = (decoded_reg_strb.SCHED_CONFIG && !decoded_req_is_wr) ? field_storage.SCHED_CONFIG.ERR_EN.value : '0;
            assign readback_array[17][3:3] = (decoded_reg_strb.SCHED_CONFIG && !decoded_req_is_wr) ? field_storage.SCHED_CONFIG.COMPL_EN.value : '0;
            assign readback_array[17][4:4] = (decoded_reg_strb.SCHED_CONFIG && !decoded_req_is_wr) ? field_storage.SCHED_CONFIG.PERF_EN.value : '0;
            assign readback_array[17][31:5] = (decoded_reg_strb.SCHED_CONFIG && !decoded_req_is_wr) ? 27'h0 : '0;
            assign readback_array[18][0:0] = (decoded_reg_strb.DESCENG_CONFIG && !decoded_req_is_wr) ? field_storage.DESCENG_CONFIG.DESCENG_EN.value : '0;
            assign readback_array[18][1:1] = (decoded_reg_strb.DESCENG_CONFIG && !decoded_req_is_wr) ? field_storage.DESCENG_CONFIG.PREFETCH_EN.value : '0;
            assign readback_array[18][5:2] = (decoded_reg_strb.DESCENG_CONFIG && !decoded_req_is_wr) ? field_storage.DESCENG_CONFIG.FIFO_THRESH.value : '0;
            assign readback_array[18][31:6] = (decoded_reg_strb.DESCENG_CONFIG && !decoded_req_is_wr) ? 26'h0 : '0;
            assign readback_array[19][31:0] = (decoded_reg_strb.DESCENG_ADDR0_BASE && !decoded_req_is_wr) ? field_storage.DESCENG_ADDR0_BASE.ADDR0_BASE.value : '0;
            assign readback_array[20][31:0] = (decoded_reg_strb.DESCENG_ADDR0_LIMIT && !decoded_req_is_wr) ? field_storage.DESCENG_ADDR0_LIMIT.ADDR0_LIMIT.value : '0;
            assign readback_array[21][31:0] = (decoded_reg_strb.DESCENG_ADDR1_BASE && !decoded_req_is_wr) ? field_storage.DESCENG_ADDR1_BASE.ADDR1_BASE.value : '0;
            assign readback_array[22][31:0] = (decoded_reg_strb.DESCENG_ADDR1_LIMIT && !decoded_req_is_wr) ? field_storage.DESCENG_ADDR1_LIMIT.ADDR1_LIMIT.value : '0;
            assign readback_array[23][0:0] = (decoded_reg_strb.DAXMON_ENABLE && !decoded_req_is_wr) ? field_storage.DAXMON_ENABLE.MON_EN.value : '0;
            assign readback_array[23][1:1] = (decoded_reg_strb.DAXMON_ENABLE && !decoded_req_is_wr) ? field_storage.DAXMON_ENABLE.ERR_EN.value : '0;
            assign readback_array[23][2:2] = (decoded_reg_strb.DAXMON_ENABLE && !decoded_req_is_wr) ? field_storage.DAXMON_ENABLE.COMPL_EN.value : '0;
            assign readback_array[23][3:3] = (decoded_reg_strb.DAXMON_ENABLE && !decoded_req_is_wr) ? field_storage.DAXMON_ENABLE.TIMEOUT_EN.value : '0;
            assign readback_array[23][4:4] = (decoded_reg_strb.DAXMON_ENABLE && !decoded_req_is_wr) ? field_storage.DAXMON_ENABLE.PERF_EN.value : '0;
            assign readback_array[23][31:5] = (decoded_reg_strb.DAXMON_ENABLE && !decoded_req_is_wr) ? 27'h0 : '0;
            assign readback_array[24][31:0] = (decoded_reg_strb.DAXMON_TIMEOUT && !decoded_req_is_wr) ? field_storage.DAXMON_TIMEOUT.TIMEOUT_CYCLES.value : '0;
            assign readback_array[25][31:0] = (decoded_reg_strb.DAXMON_LATENCY_THRESH && !decoded_req_is_wr) ? field_storage.DAXMON_LATENCY_THRESH.LATENCY_THRESH.value : '0;
            assign readback_array[26][15:0] = (decoded_reg_strb.DAXMON_PKT_MASK && !decoded_req_is_wr) ? field_storage.DAXMON_PKT_MASK.PKT_MASK.value : '0;
            assign readback_array[26][31:16] = (decoded_reg_strb.DAXMON_PKT_MASK && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[27][3:0] = (decoded_reg_strb.DAXMON_ERR_CFG && !decoded_req_is_wr) ? field_storage.DAXMON_ERR_CFG.ERR_SELECT.value : '0;
            assign readback_array[27][7:4] = (decoded_reg_strb.DAXMON_ERR_CFG && !decoded_req_is_wr) ? 4'h0 : '0;
            assign readback_array[27][15:8] = (decoded_reg_strb.DAXMON_ERR_CFG && !decoded_req_is_wr) ? field_storage.DAXMON_ERR_CFG.ERR_MASK.value : '0;
            assign readback_array[27][31:16] = (decoded_reg_strb.DAXMON_ERR_CFG && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[28][7:0] = (decoded_reg_strb.DAXMON_MASK1 && !decoded_req_is_wr) ? field_storage.DAXMON_MASK1.TIMEOUT_MASK.value : '0;
            assign readback_array[28][15:8] = (decoded_reg_strb.DAXMON_MASK1 && !decoded_req_is_wr) ? field_storage.DAXMON_MASK1.COMPL_MASK.value : '0;
            assign readback_array[28][31:16] = (decoded_reg_strb.DAXMON_MASK1 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[29][7:0] = (decoded_reg_strb.DAXMON_MASK2 && !decoded_req_is_wr) ? field_storage.DAXMON_MASK2.THRESH_MASK.value : '0;
            assign readback_array[29][15:8] = (decoded_reg_strb.DAXMON_MASK2 && !decoded_req_is_wr) ? field_storage.DAXMON_MASK2.PERF_MASK.value : '0;
            assign readback_array[29][31:16] = (decoded_reg_strb.DAXMON_MASK2 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[30][7:0] = (decoded_reg_strb.DAXMON_MASK3 && !decoded_req_is_wr) ? field_storage.DAXMON_MASK3.ADDR_MASK.value : '0;
            assign readback_array[30][15:8] = (decoded_reg_strb.DAXMON_MASK3 && !decoded_req_is_wr) ? field_storage.DAXMON_MASK3.DEBUG_MASK.value : '0;
            assign readback_array[30][31:16] = (decoded_reg_strb.DAXMON_MASK3 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[31][0:0] = (decoded_reg_strb.RDMON_ENABLE && !decoded_req_is_wr) ? field_storage.RDMON_ENABLE.MON_EN.value : '0;
            assign readback_array[31][1:1] = (decoded_reg_strb.RDMON_ENABLE && !decoded_req_is_wr) ? field_storage.RDMON_ENABLE.ERR_EN.value : '0;
            assign readback_array[31][2:2] = (decoded_reg_strb.RDMON_ENABLE && !decoded_req_is_wr) ? field_storage.RDMON_ENABLE.COMPL_EN.value : '0;
            assign readback_array[31][3:3] = (decoded_reg_strb.RDMON_ENABLE && !decoded_req_is_wr) ? field_storage.RDMON_ENABLE.TIMEOUT_EN.value : '0;
            assign readback_array[31][4:4] = (decoded_reg_strb.RDMON_ENABLE && !decoded_req_is_wr) ? field_storage.RDMON_ENABLE.PERF_EN.value : '0;
            assign readback_array[31][31:5] = (decoded_reg_strb.RDMON_ENABLE && !decoded_req_is_wr) ? 27'h0 : '0;
            assign readback_array[32][31:0] = (decoded_reg_strb.RDMON_TIMEOUT && !decoded_req_is_wr) ? field_storage.RDMON_TIMEOUT.TIMEOUT_CYCLES.value : '0;
            assign readback_array[33][31:0] = (decoded_reg_strb.RDMON_LATENCY_THRESH && !decoded_req_is_wr) ? field_storage.RDMON_LATENCY_THRESH.LATENCY_THRESH.value : '0;
            assign readback_array[34][15:0] = (decoded_reg_strb.RDMON_PKT_MASK && !decoded_req_is_wr) ? field_storage.RDMON_PKT_MASK.PKT_MASK.value : '0;
            assign readback_array[34][31:16] = (decoded_reg_strb.RDMON_PKT_MASK && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[35][3:0] = (decoded_reg_strb.RDMON_ERR_CFG && !decoded_req_is_wr) ? field_storage.RDMON_ERR_CFG.ERR_SELECT.value : '0;
            assign readback_array[35][7:4] = (decoded_reg_strb.RDMON_ERR_CFG && !decoded_req_is_wr) ? 4'h0 : '0;
            assign readback_array[35][15:8] = (decoded_reg_strb.RDMON_ERR_CFG && !decoded_req_is_wr) ? field_storage.RDMON_ERR_CFG.ERR_MASK.value : '0;
            assign readback_array[35][31:16] = (decoded_reg_strb.RDMON_ERR_CFG && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[36][7:0] = (decoded_reg_strb.RDMON_MASK1 && !decoded_req_is_wr) ? field_storage.RDMON_MASK1.TIMEOUT_MASK.value : '0;
            assign readback_array[36][15:8] = (decoded_reg_strb.RDMON_MASK1 && !decoded_req_is_wr) ? field_storage.RDMON_MASK1.COMPL_MASK.value : '0;
            assign readback_array[36][31:16] = (decoded_reg_strb.RDMON_MASK1 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[37][7:0] = (decoded_reg_strb.RDMON_MASK2 && !decoded_req_is_wr) ? field_storage.RDMON_MASK2.THRESH_MASK.value : '0;
            assign readback_array[37][15:8] = (decoded_reg_strb.RDMON_MASK2 && !decoded_req_is_wr) ? field_storage.RDMON_MASK2.PERF_MASK.value : '0;
            assign readback_array[37][31:16] = (decoded_reg_strb.RDMON_MASK2 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[38][7:0] = (decoded_reg_strb.RDMON_MASK3 && !decoded_req_is_wr) ? field_storage.RDMON_MASK3.ADDR_MASK.value : '0;
            assign readback_array[38][15:8] = (decoded_reg_strb.RDMON_MASK3 && !decoded_req_is_wr) ? field_storage.RDMON_MASK3.DEBUG_MASK.value : '0;
            assign readback_array[38][31:16] = (decoded_reg_strb.RDMON_MASK3 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[39][0:0] = (decoded_reg_strb.WRMON_ENABLE && !decoded_req_is_wr) ? field_storage.WRMON_ENABLE.MON_EN.value : '0;
            assign readback_array[39][1:1] = (decoded_reg_strb.WRMON_ENABLE && !decoded_req_is_wr) ? field_storage.WRMON_ENABLE.ERR_EN.value : '0;
            assign readback_array[39][2:2] = (decoded_reg_strb.WRMON_ENABLE && !decoded_req_is_wr) ? field_storage.WRMON_ENABLE.COMPL_EN.value : '0;
            assign readback_array[39][3:3] = (decoded_reg_strb.WRMON_ENABLE && !decoded_req_is_wr) ? field_storage.WRMON_ENABLE.TIMEOUT_EN.value : '0;
            assign readback_array[39][4:4] = (decoded_reg_strb.WRMON_ENABLE && !decoded_req_is_wr) ? field_storage.WRMON_ENABLE.PERF_EN.value : '0;
            assign readback_array[39][31:5] = (decoded_reg_strb.WRMON_ENABLE && !decoded_req_is_wr) ? 27'h0 : '0;
            assign readback_array[40][31:0] = (decoded_reg_strb.WRMON_TIMEOUT && !decoded_req_is_wr) ? field_storage.WRMON_TIMEOUT.TIMEOUT_CYCLES.value : '0;
            assign readback_array[41][31:0] = (decoded_reg_strb.WRMON_LATENCY_THRESH && !decoded_req_is_wr) ? field_storage.WRMON_LATENCY_THRESH.LATENCY_THRESH.value : '0;
            assign readback_array[42][15:0] = (decoded_reg_strb.WRMON_PKT_MASK && !decoded_req_is_wr) ? field_storage.WRMON_PKT_MASK.PKT_MASK.value : '0;
            assign readback_array[42][31:16] = (decoded_reg_strb.WRMON_PKT_MASK && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[43][3:0] = (decoded_reg_strb.WRMON_ERR_CFG && !decoded_req_is_wr) ? field_storage.WRMON_ERR_CFG.ERR_SELECT.value : '0;
            assign readback_array[43][7:4] = (decoded_reg_strb.WRMON_ERR_CFG && !decoded_req_is_wr) ? 4'h0 : '0;
            assign readback_array[43][15:8] = (decoded_reg_strb.WRMON_ERR_CFG && !decoded_req_is_wr) ? field_storage.WRMON_ERR_CFG.ERR_MASK.value : '0;
            assign readback_array[43][31:16] = (decoded_reg_strb.WRMON_ERR_CFG && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[44][7:0] = (decoded_reg_strb.WRMON_MASK1 && !decoded_req_is_wr) ? field_storage.WRMON_MASK1.TIMEOUT_MASK.value : '0;
            assign readback_array[44][15:8] = (decoded_reg_strb.WRMON_MASK1 && !decoded_req_is_wr) ? field_storage.WRMON_MASK1.COMPL_MASK.value : '0;
            assign readback_array[44][31:16] = (decoded_reg_strb.WRMON_MASK1 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[45][7:0] = (decoded_reg_strb.WRMON_MASK2 && !decoded_req_is_wr) ? field_storage.WRMON_MASK2.THRESH_MASK.value : '0;
            assign readback_array[45][15:8] = (decoded_reg_strb.WRMON_MASK2 && !decoded_req_is_wr) ? field_storage.WRMON_MASK2.PERF_MASK.value : '0;
            assign readback_array[45][31:16] = (decoded_reg_strb.WRMON_MASK2 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[46][7:0] = (decoded_reg_strb.WRMON_MASK3 && !decoded_req_is_wr) ? field_storage.WRMON_MASK3.ADDR_MASK.value : '0;
            assign readback_array[46][15:8] = (decoded_reg_strb.WRMON_MASK3 && !decoded_req_is_wr) ? field_storage.WRMON_MASK3.DEBUG_MASK.value : '0;
            assign readback_array[46][31:16] = (decoded_reg_strb.WRMON_MASK3 && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[47][7:0] = (decoded_reg_strb.AXI_XFER_CONFIG && !decoded_req_is_wr) ? field_storage.AXI_XFER_CONFIG.RD_XFER_BEATS.value : '0;
            assign readback_array[47][15:8] = (decoded_reg_strb.AXI_XFER_CONFIG && !decoded_req_is_wr) ? field_storage.AXI_XFER_CONFIG.WR_XFER_BEATS.value : '0;
            assign readback_array[47][31:16] = (decoded_reg_strb.AXI_XFER_CONFIG && !decoded_req_is_wr) ? 16'h0 : '0;
            assign readback_array[48][0:0] = (decoded_reg_strb.PERF_CONFIG && !decoded_req_is_wr) ? field_storage.PERF_CONFIG.PERF_EN.value : '0;
            assign readback_array[48][1:1] = (decoded_reg_strb.PERF_CONFIG && !decoded_req_is_wr) ? field_storage.PERF_CONFIG.PERF_MODE.value : '0;
            assign readback_array[48][2:2] = (decoded_reg_strb.PERF_CONFIG && !decoded_req_is_wr) ? field_storage.PERF_CONFIG.PERF_CLEAR.value : '0;
            assign readback_array[48][31:3] = (decoded_reg_strb.PERF_CONFIG && !decoded_req_is_wr) ? 29'h0 : '0;
        
            // Reduce the array
%000002     always_comb begin
                automatic logic [31:0] readback_data_var;
%000002         readback_done = decoded_req & ~decoded_req_is_wr;
%000002         readback_err = '0;
%000002         readback_data_var = '0;
%000002         for(int i=0; i<49; i++) readback_data_var |= readback_array[i];
%000002         readback_data = readback_data_var;
            end
        
            assign cpuif_rd_ack = readback_done;
            assign cpuif_rd_data = readback_data;
            assign cpuif_rd_err = readback_err;
        endmodule
        
