# HPET (High Precision Event Timer) Module

## Overview

The HPET module is a fully parameterized, scalable timer peripheral with APB interface, supporting 2-8 independent timer channels. The implementation features **PeakRDL-generated register blocks** for automated register map generation from SystemRDL specifications, optional **clock domain crossing (CDC)** for dual-clock operation, and comprehensive interrupt handling.

**Status**: ✅ **Production Ready** - All configurations tested and passing (4/4 basic tests across all variants)

## Key Features

### Core Functionality
- **Scalable Design**: 2, 3, or 8 timer channels (configurable via `NUM_TIMERS` parameter)
- **64-bit Main Counter**: High-precision incrementing counter
- **Per-Timer Features**:
  - One-shot and periodic modes
  - 32-bit or 64-bit comparator values
  - Independent interrupt generation
  - Flexible interrupt enable/disable

### Advanced Features
- **PeakRDL Integration**: Register blocks auto-generated from SystemRDL specification
- **Optional CDC**: Selectable clock domain crossing for async operation
- **Dual Clock Domains**: APB (low frequency) and HPET timer (high frequency)
- **Live Counter Readback**: Software can read incrementing counter in real-time
- **Sticky Interrupts**: W1C (Write-1-to-Clear) semantics with proper edge detection
- **Parameter Validation**: Runtime reporting of actual timer count via HPET_ID register

## Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                          apb_hpet (Top Level)                        │
│                                                                      │
│  ┌────────────────┐    ┌──────────────────┐    ┌──────────────┐   │
│  │  APB Slave     │───▶│ Config Registers │───▶│  HPET Core   │   │
│  │  (CDC/Non-CDC) │    │  (PeakRDL-based) │    │  (Timers)    │   │
│  └────────────────┘    └──────────────────┘    └──────────────┘   │
│         ▲                       ▲                       ▲           │
│    pclk │                  hpet_clk (conditional)       │           │
│         │                                               │           │
│         └───────────────────────────────────────────────┘           │
│                    (CDC_ENABLE determines clocking)                 │
└─────────────────────────────────────────────────────────────────────┘
```

### Module Hierarchy

1. **`apb_hpet.sv`** (Top Level)
   - Instantiates APB slave (CDC or non-CDC via generate block)
   - Instantiates configuration registers
   - Instantiates HPET core
   - Manages clock domain selection based on `CDC_ENABLE`

2. **`apb_slave.sv` / `apb_slave_cdc.sv`** (APB Interface)
   - Converts APB protocol to cmd/rsp interface
   - CDC version handles async clock crossing

3. **`hpet_config_regs.sv`** (Register Wrapper)
   - Wraps PeakRDL-generated register block
   - Maps hwif signals to HPET core interface
   - Handles edge detection for interrupts and counter writes

4. **`hpet_regs.sv` + `hpet_regs_pkg.sv`** (Auto-Generated)
   - Generated by PeakRDL from `hpet_regs.rdl`
   - Contains all register logic and hardware interfaces

5. **`hpet_core.sv`** (Timer Logic)
   - Main 64-bit counter
   - Per-timer comparators and interrupt logic

## PeakRDL Integration

### What is PeakRDL?

PeakRDL is an open-source toolchain that generates SystemVerilog register blocks from SystemRDL specifications. This provides:

- **Single Source of Truth**: Register map defined once in `hpet_regs.rdl`
- **Automatic Generation**: RTL, packages, and documentation auto-generated
- **Verified Semantics**: Field access rights (RW, RO, W1C, etc.) handled correctly
- **Hardware Interface**: Clean `hwif` structs for connecting to custom logic

### Register Generation Flow

```
hpet_regs.rdl (SystemRDL)
        │
        ├──▶ peakrdl regblock hpet_regs.rdl
        │
        ├──▶ hpet_regs.sv         (Register block RTL)
        ├──▶ hpet_regs_pkg.sv     (Type definitions)
        └──▶ generated/docs/*.md  (Documentation)
```

### Key PeakRDL Features Used

1. **Hardware Interfaces (`hwif_in`/`hwif_out`)**:
   ```systemverilog
   // PeakRDL generates these structs
   hpet_regs__in_t  hwif_in;   // Hardware → Registers
   hpet_regs__out_t hwif_out;  // Registers → Hardware
   ```

2. **Live Counter Readback**:
   ```systemrdl
   field {
       sw = rw;           // Software can read/write
       hw = w;            // Hardware writes live value
       precedence = sw;   // SW write takes priority
   } counter_lo[31:0];
   ```

3. **Sticky Interrupts with W1C**:
   ```systemrdl
   field {
       sw = rw;
       hw = w;
       hwset;             // Edge-based set
       onwrite = woclr;   // Write-1-to-clear
       sticky;            // Latches until cleared
       swmod;             // Detect SW modifications
   } timer_int_status[NUM_TIMERS-1:0];
   ```

4. **Runtime Parameters**:
   ```systemrdl
   field {
       sw = r;
       hw = w;            // Hardware drives actual value
       reset = NUM_TIMERS - 1;
   } num_tim_cap[12:8];
   ```

### Regenerating Registers

To modify the register map:

1. Edit `rtl/amba/components/hpet/peakrdl/hpet_regs.rdl`
2. Regenerate:
   ```bash
   cd rtl/amba/components/hpet/peakrdl
   peakrdl regblock hpet_regs.rdl -o .. --cpuif passthrough
   ```
3. Generated files:
   - `../hpet_regs.sv` (register block)
   - `../hpet_regs_pkg.sv` (package)
   - `generated/docs/hpet_regs.md` (documentation)

**Note**: `hpet_config_regs.sv` wrapper adapts PeakRDL hwif to HPET core interface.

## Parameters

### Top-Level Parameters (`apb_hpet`)

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `VENDOR_ID` | int | 1 | Vendor identifier (reported in HPET_ID) |
| `REVISION_ID` | int | 1 | Revision identifier (reported in HPET_ID) |
| `NUM_TIMERS` | int | 2 | Number of timer channels (2-8) |
| `CDC_ENABLE` | int | 0 | Clock domain crossing enable (0=same clock, 1=async clocks) |

### CDC_ENABLE Behavior

#### CDC_ENABLE = 0 (Default - Same Clock Domain)
- **APB Interface**: Uses `pclk` and `presetn`
- **Config Registers**: Uses `pclk` and `presetn`
- **HPET Core**: Uses `pclk` and `presetn`
- **APB Slave**: Instantiates `apb_slave` (no CDC)
- **Use Case**: Simple single-clock systems, minimal latency

#### CDC_ENABLE = 1 (Dual Clock Domain)
- **APB Interface**: Uses `pclk` and `presetn` (low frequency)
- **Config Registers**: Uses `hpet_clk` and `hpet_resetn` (high frequency)
- **HPET Core**: Uses `hpet_clk` and `hpet_resetn` (high frequency)
- **APB Slave**: Instantiates `apb_slave_cdc` (with handshake-based CDC)
- **Use Case**: High-precision timing with slow APB bus

### Configuration Examples

**Intel-like (2 timers, no CDC):**
```systemverilog
apb_hpet #(
    .NUM_TIMERS(2),
    .VENDOR_ID(16'h8086),
    .REVISION_ID(8'h01),
    .CDC_ENABLE(0)
) u_hpet (...);
```

**AMD-like (3 timers, with CDC):**
```systemverilog
apb_hpet #(
    .NUM_TIMERS(3),
    .VENDOR_ID(16'h1022),
    .REVISION_ID(8'h02),
    .CDC_ENABLE(1)
) u_hpet (...);
```

**Custom (8 timers, high-speed with CDC):**
```systemverilog
apb_hpet #(
    .NUM_TIMERS(8),
    .VENDOR_ID(16'hABCD),
    .REVISION_ID(8'h10),
    .CDC_ENABLE(1)
) u_hpet (...);
```

## Register Map

**Base Address**: Configurable (module uses relative addressing)
**Address Width**: 12 bits (4KB address space)
**Data Width**: 32 bits

### Global Registers (0x000-0x0FF)

| Offset | Name | Access | Description |
|--------|------|--------|-------------|
| 0x000 | HPET_ID | RO | Capabilities and identification |
| 0x004 | HPET_CONFIG | RW | Global configuration |
| 0x008 | HPET_STATUS | RW/W1C | Interrupt status (W1C) |
| 0x00C | RESERVED | - | Reserved |
| 0x010 | HPET_COUNTER_LO | RW | Main counter low 32 bits |
| 0x014 | HPET_COUNTER_HI | RW | Main counter high 32 bits |

### Timer Registers (0x100-0x1FF)

Each timer occupies 32 bytes (0x20) starting at 0x100:

| Offset | Register | Access | Description |
|--------|----------|--------|-------------|
| +0x00 | TIMER_CONFIG | RW | Timer configuration |
| +0x04 | TIMER_COMPARATOR_LO | RW | Comparator low 32 bits |
| +0x08 | TIMER_COMPARATOR_HI | RW | Comparator high 32 bits |
| +0x0C | RESERVED | - | Reserved for expansion |

**Timer Base Addresses**:
- Timer 0: 0x100-0x11F
- Timer 1: 0x120-0x13F
- Timer 2: 0x140-0x15F (if NUM_TIMERS ≥ 3)
- Timer 3: 0x160-0x17F (if NUM_TIMERS ≥ 4)
- Timer 4: 0x180-0x19F (if NUM_TIMERS ≥ 5)
- Timer 5: 0x1A0-0x1BF (if NUM_TIMERS ≥ 6)
- Timer 6: 0x1C0-0x1DF (if NUM_TIMERS ≥ 7)
- Timer 7: 0x1E0-0x1FF (if NUM_TIMERS = 8)

### Register Bit Fields

#### HPET_ID (0x000) - Read Only
```
[31:24] VENDOR_ID     - Vendor identifier (parameter)
[23:16] REV_ID        - Revision identifier (parameter)
[15:13] Reserved
[12:8]  NUM_TIM_CAP   - Number of timers - 1 (hardware-driven)
[7]     COUNT_SIZE_CAP - 1 = 64-bit counter capable
[6]     Reserved
[5]     LEG_RT_CAP    - 1 = Legacy replacement capable
[4:0]   Reserved
```

**Note**: `NUM_TIM_CAP` is **hardware-written** to reflect actual `NUM_TIMERS` parameter at runtime.

#### HPET_CONFIG (0x004) - Read/Write
```
[31:2] Reserved
[1]    LEGACY_REPLACEMENT - Enable legacy timer mode
[0]    HPET_ENABLE        - Enable main counter
```

#### HPET_STATUS (0x008) - Read/Write (W1C)
```
[31:NUM_TIMERS] Reserved
[NUM_TIMERS-1:0] TIMER_INT_STATUS - Interrupt status (write 1 to clear)
```

**PeakRDL Semantics**:
- **Sticky**: Interrupts latch until cleared
- **W1C**: Write 1 to clear interrupt
- **Edge-triggered**: Hardware sets on rising edge of timer interrupt

#### TIMER_CONFIG (+0x00) - Read/Write
```
[31:7] Reserved
[6]    TIMER_VALUE_SET    - Write 1 to update comparator
[5]    TIMER_SIZE         - 0=32-bit, 1=64-bit comparator
[4]    TIMER_TYPE         - 0=one-shot, 1=periodic
[3]    TIMER_INT_ENABLE   - Interrupt enable
[2]    TIMER_ENABLE       - Timer enable
[1:0]  Reserved
```

## Usage Examples

### Example 1: Basic Timer Setup (No CDC)

```systemverilog
module my_system (
    input  logic        clk,
    input  logic        rst_n,
    // APB interface
    output logic [1:0]  timer_irq
);

    // Instantiate HPET with 2 timers, no CDC
    apb_hpet #(
        .NUM_TIMERS(2),
        .VENDOR_ID(16'h8086),
        .REVISION_ID(8'h01),
        .CDC_ENABLE(0)  // Same clock domain
    ) u_hpet (
        // Clocks - both use same clock
        .pclk           (clk),
        .presetn        (rst_n),
        .hpet_clk       (clk),      // Not used when CDC_ENABLE=0
        .hpet_resetn    (rst_n),    // Not used when CDC_ENABLE=0

        // APB interface
        .s_apb_PSEL     (apb_psel),
        .s_apb_PENABLE  (apb_penable),
        .s_apb_PREADY   (apb_pready),
        .s_apb_PADDR    (apb_paddr),
        .s_apb_PWRITE   (apb_pwrite),
        .s_apb_PWDATA   (apb_pwdata),
        .s_apb_PSTRB    (apb_pstrb),
        .s_apb_PPROT    (apb_pprot),
        .s_apb_PRDATA   (apb_prdata),
        .s_apb_PSLVERR  (apb_pslverr),

        // Interrupts
        .timer_irq      (timer_irq)
    );
endmodule
```

### Example 2: High-Precision Timer with CDC

```systemverilog
module high_precision_system (
    input  logic        apb_clk,        // 50 MHz APB clock
    input  logic        apb_rst_n,
    input  logic        hpet_clk,       // 100 MHz timer clock
    input  logic        hpet_rst_n,
    output logic [7:0]  timer_irq
);

    // Instantiate HPET with 8 timers and CDC
    apb_hpet #(
        .NUM_TIMERS(8),
        .VENDOR_ID(16'hABCD),
        .REVISION_ID(8'h10),
        .CDC_ENABLE(1)  // Enable CDC for async clocks
    ) u_hpet (
        // APB clock domain (slow)
        .pclk           (apb_clk),
        .presetn        (apb_rst_n),

        // HPET clock domain (fast, for precise timing)
        .hpet_clk       (hpet_clk),
        .hpet_resetn    (hpet_rst_n),

        // APB interface (apb_clk domain)
        .s_apb_PSEL     (apb_psel),
        // ... other APB signals

        // Interrupts (hpet_clk domain when CDC_ENABLE=1)
        .timer_irq      (timer_irq)
    );
endmodule
```

### Example 3: Software Usage

```c
// Register definitions
#define HPET_BASE        0x10000000
#define HPET_ID          (HPET_BASE + 0x000)
#define HPET_CONFIG      (HPET_BASE + 0x004)
#define HPET_STATUS      (HPET_BASE + 0x008)
#define HPET_COUNTER_LO  (HPET_BASE + 0x010)
#define HPET_COUNTER_HI  (HPET_BASE + 0x014)
#define TIMER0_CONFIG    (HPET_BASE + 0x100)
#define TIMER0_COMP_LO   (HPET_BASE + 0x104)
#define TIMER0_COMP_HI   (HPET_BASE + 0x108)

// Initialize HPET
void hpet_init(void) {
    // Read capabilities
    uint32_t id = READ_REG(HPET_ID);
    uint32_t num_timers = ((id >> 8) & 0x1F) + 1;

    // Enable HPET
    WRITE_REG(HPET_CONFIG, 0x1);  // HPET_ENABLE
}

// Configure timer 0 for one-shot
void timer0_oneshot(uint32_t ticks) {
    // Disable timer
    WRITE_REG(TIMER0_CONFIG, 0x00);

    // Set comparator (32-bit mode)
    WRITE_REG(TIMER0_COMP_LO, ticks);

    // Enable timer: one-shot, 32-bit, interrupt enabled
    WRITE_REG(TIMER0_CONFIG, 0x0C);  // INT_EN | ENABLE
}

// Clear interrupt
void timer0_clear_irq(void) {
    WRITE_REG(HPET_STATUS, 0x1);  // W1C bit 0
}

// Read live counter
uint64_t hpet_read_counter(void) {
    uint32_t lo, hi1, hi2;

    // Handle potential rollover
    do {
        hi1 = READ_REG(HPET_COUNTER_HI);
        lo  = READ_REG(HPET_COUNTER_LO);
        hi2 = READ_REG(HPET_COUNTER_HI);
    } while (hi1 != hi2);

    return ((uint64_t)hi2 << 32) | lo;
}
```

## Testing

### Test Configurations

The test suite validates all parameter combinations:

| Config | Timers | Vendor | Rev | CDC | Description |
|--------|--------|--------|-----|-----|-------------|
| 1 | 2 | 0x8086 | 0x01 | 0 | Intel-like, no CDC |
| 2 | 3 | 0x1022 | 0x02 | 0 | AMD-like, no CDC |
| 3 | 8 | 0xABCD | 0x10 | 0 | Custom, no CDC |
| 4 | 2 | 0x8086 | 0x01 | 1 | Intel-like, CDC |
| 5 | 3 | 0x1022 | 0x02 | 1 | AMD-like, CDC |
| 6 | 8 | 0xABCD | 0x10 | 1 | Custom, CDC |

### Running Tests

```bash
# Run all HPET tests
pytest val/integ_amba/test_apb_hpet.py -v

# Run specific configuration
pytest 'val/integ_amba/test_apb_hpet.py::test_hpet[2-32902-1-0-full-2-timer Intel-like]' -v

# Run CDC tests only
pytest -k "CDC" val/integ_amba/test_apb_hpet.py -v
```

### Test Coverage

All configurations pass **4/4 basic tests**:
1. ✅ **Register Access**: Read/write all registers
2. ✅ **Counter Functionality**: Counter increment, SW write, live readback
3. ✅ **Timer One-Shot**: Configure and trigger timer interrupt
4. ✅ **Interrupt Clearing**: W1C semantics and edge detection

## File Structure

```
rtl/amba/components/hpet/
├── README.md                          (This file)
├── apb_hpet.sv                        (Top-level module)
├── hpet_core.sv                       (Timer core logic)
├── hpet_config_regs.sv                (PeakRDL wrapper)
├── hpet_regs.sv                       (Auto-generated register block)
├── hpet_regs_pkg.sv                   (Auto-generated package)
├── peakrdl/
│   ├── README.md                      (PeakRDL usage guide)
│   ├── hpet_regs.rdl                  (SystemRDL specification)
│   └── generated/
│       └── docs/
│           └── hpet_regs.md           (Auto-generated documentation)
└── filelists/
    └── *.f                            (Simulation file lists)

val/integ_amba/
└── test_apb_hpet.py                   (Pytest test runner)
```

## Design Decisions

### Why PeakRDL?

1. **Single Source of Truth**: Register map defined once in SystemRDL
2. **Verified Semantics**: Field access (RW, RO, W1C) guaranteed correct
3. **Maintainability**: Changes to register map automatically propagate
4. **Documentation**: Auto-generated register documentation
5. **Industry Standard**: SystemRDL is IP-XACT successor

### Why Optional CDC?

1. **Flexibility**: Support both simple (same clock) and complex (dual clock) systems
2. **Performance**: No CDC overhead when not needed
3. **Precision**: High-speed timer clock independent of slow APB bus
4. **Resource**: CDC components only instantiated when enabled

### Why Hardware-Writable num_tim_cap?

Allows single PeakRDL generation (NUM_TIMERS=8) to correctly report timer count when instantiated with different parameters (2, 3, or 8 timers).

## Known Limitations

1. **Timer Spacing**: Timer registers use 32-byte spacing (only 12 bytes used per timer)
   - **Reason**: Allows future expansion without address map changes

2. **PeakRDL Generation**: Requires manual regeneration when modifying `hpet_regs.rdl`
   - **Mitigation**: Clear documentation in `peakrdl/README.md`

3. **CDC Latency**: CDC version adds ~2-4 cycles latency for APB transactions
   - **Expected**: Handshake-based CDC requires round-trip synchronization

## Version History

- **v2.0** (2025-10-16): PeakRDL integration complete
  - Auto-generated register blocks from SystemRDL
  - Added CDC_ENABLE parameter for optional clock domain crossing
  - Hardware-writable HPET_ID.num_tim_cap for runtime reporting
  - Live counter readback with hw=w, precedence=sw
  - Sticky interrupt semantics with hwset + swmod
  - All 6 test configurations passing (4/4 basic tests each)

- **v1.0**: Hand-coded register blocks (deprecated)

## References

- **PeakRDL**: https://github.com/SystemRDL/PeakRDL-regblock
- **SystemRDL**: https://github.com/SystemRDL/systemrdl-compiler
- **HPET Spec**: Intel IA-PC HPET Specification (for reference, not strictly compliant)
- **Test Documentation**: `val/integ_amba/test_apb_hpet.py` docstrings

## Contributing

When modifying the HPET module:

1. **Register Changes**: Edit `peakrdl/hpet_regs.rdl`, then regenerate
2. **RTL Changes**: Update `apb_hpet.sv`, `hpet_core.sv`, or wrapper
3. **Testing**: Run full test suite (all 6 configurations)
4. **Documentation**: Update this README and inline comments

---

**Maintained by**: RTL Design Sherpa Project
**Last Updated**: 2025-10-16
**Status**: Production Ready ✅
