@startuml address_alignment_fsm
!theme plain
title Address Alignment FSM (scheduler.sv)

skinparam state {
  BackgroundColor LightGreen
  BorderColor DarkGreen
  ArrowColor DarkGreen
  ArrowFontColor Black
  ArrowFontSize 10
}

[*] --> ALIGN_IDLE

state ALIGN_IDLE {
  ALIGN_IDLE : Wait for descriptor with data address
  ALIGN_IDLE : Reset alignment state and bus signals
  ALIGN_IDLE : Ready for new alignment calculation
}
state ANALYZE_ADDRESS {
  ANALYZE_ADDRESS : Extract address offset[5:0] = data_addr[5:0]
  ANALYZE_ADDRESS : Calculate w_is_aligned = (offset == 0)
  ANALYZE_ADDRESS : Calculate w_bytes_to_boundary = 64 - offset
  ANALYZE_ADDRESS : Determine alignment strategy in 1 cycle
}
state CALC_FIRST_TRANSFER {
  CALC_FIRST_TRANSFER : Calculate alignment transfer parameters
  CALC_FIRST_TRANSFER : Generate first_chunk_enables[15:0] pattern
  CALC_FIRST_TRANSFER : Set first_transfer_bytes, first_start_chunk
  CALC_FIRST_TRANSFER : Calculate w_remaining_after_first
}
state CALC_STREAMING {
  CALC_STREAMING : Calculate optimal streaming parameters
  CALC_STREAMING : Set streaming_chunk_enables = 16'hFFFF
  CALC_STREAMING : Calculate optimal_burst_len and streaming_bytes
  CALC_STREAMING : Determine w_final_bytes remainder
}
state CALC_FINAL_TRANSFER {
  CALC_FINAL_TRANSFER : Calculate final partial transfer
  CALC_FINAL_TRANSFER : Generate final_chunk_enables[15:0] pattern
  CALC_FINAL_TRANSFER : Set final_transfer_bytes, final_valid_chunks
  CALC_FINAL_TRANSFER : Handle stream boundary conditions
}
state ALIGNMENT_COMPLETE {
  ALIGNMENT_COMPLETE : Set data_alignment_valid = 1
  ALIGNMENT_COMPLETE : Provide alignment_info_t to engines
  ALIGNMENT_COMPLETE : Calculate total_transfers and efficiency
  ALIGNMENT_COMPLETE : Monitor transfer sequence progress
}
state ALIGNMENT_ERROR {
  ALIGNMENT_ERROR : Handle alignment calculation errors
  ALIGNMENT_ERROR : Invalid address or length combinations
}

ALIGN_IDLE -down-> ANALYZE_ADDRESS : (r_current_state == SCHED_DESCRIPTOR_ACTIVE) & (r_data_length > 0)
ANALYZE_ADDRESS -down-> CALC_FIRST_TRANSFER : !w_is_aligned & (w_bytes_to_boundary <= r_data_length)
ANALYZE_ADDRESS -right-> CALC_STREAMING : w_is_aligned & (w_remaining_after_first > 64)
ANALYZE_ADDRESS -down-> CALC_FINAL_TRANSFER : w_remaining_after_first <= 64
ANALYZE_ADDRESS -down-> ALIGNMENT_ERROR : invalid_alignment_parameters
CALC_FIRST_TRANSFER -right-> CALC_STREAMING : w_remaining_after_first > 64
CALC_FIRST_TRANSFER -down-> CALC_FINAL_TRANSFER : 0 < w_remaining_after_first <= 64
CALC_FIRST_TRANSFER -down-> ALIGNMENT_COMPLETE : w_remaining_after_first == 0
CALC_STREAMING -down-> CALC_FINAL_TRANSFER : w_final_bytes > 0
CALC_STREAMING -right-> ALIGNMENT_COMPLETE : w_final_bytes == 0
CALC_FINAL_TRANSFER -up-> ALIGNMENT_COMPLETE : final_transfer_calculated
ALIGNMENT_COMPLETE -up-> ALIGN_IDLE : data_sequence_complete | (r_current_state != SCHED_DESCRIPTOR_ACTIVE)
ALIGNMENT_ERROR -up-> ALIGN_IDLE : error_acknowledged

note bottom
<b>Parallel FSM Operation:</b>

This alignment FSM runs in parallel with the main scheduler FSM during the
SCHED_DESCRIPTOR_ACTIVE state, providing alignment information before engines
begin AXI transactions.

<b>Signal Definitions:</b>

(r_current_state == SCHED_DESCRIPTOR_ACTIVE) & (r_data_length > 0) = 
    New descriptor with data address received by main scheduler FSM

!w_is_aligned = data_address[5:0] != 6'h0 (not 64-byte aligned)
w_is_aligned = data_address[5:0] == 6'h0 (already 64-byte aligned)

w_bytes_to_boundary = 64 - data_address[5:0] (bytes to next 64B boundary)
w_remaining_after_first = data_length after alignment transfer
w_final_bytes = remaining bytes after streaming transfers

data_sequence_complete = all transfers in sequence completed by engines
(r_current_state != SCHED_DESCRIPTOR_ACTIVE) = main scheduler moved to next state

<b>Alignment Information Bus:</b>
```systemverilog
typedef struct packed {
    logic                    is_aligned;           // Pre-calculated
    logic [5:0]              addr_offset;          // Pre-calculated  
    logic [31:0]             first_transfer_bytes; // Pre-calculated
    logic [NUM_CHUNKS-1:0]   first_chunk_enables;  // Pre-calculated
    logic [7:0]              optimal_burst_len;    // Pre-calculated
    logic [31:0]             final_transfer_bytes; // Pre-calculated
    logic [NUM_CHUNKS-1:0]   final_chunk_enables;  // Pre-calculated
    logic [3:0]              total_transfers;      // Pre-calculated
    alignment_strategy_t     alignment_strategy;   // Strategy selection
} alignment_info_t;

output alignment_info_t      data_alignment_info;   // To engines
output logic                 data_alignment_valid;  // Info valid
input  logic                 data_alignment_ready;  // Engines ready
```

<b>Performance Benefits:</b>

<b>1. Hidden Latency Calculation:</b>
- Alignment analysis during descriptor processing (non-critical path)
- AXI engines get pre-calculated results immediately
- No calculation overhead in AXI transaction timing

<b>2. Optimal Transfer Planning:</b>
- Complete transfer sequence pre-calculated
- Chunk enables generated in advance
- Burst lengths optimized for alignment

<b>3. Resource Efficiency:</b>
- Single alignment calculation unit
- Eliminates duplicated logic in engines
- Clean critical path in AXI interfaces

<b>State Functions:</b>

ALIGN_IDLE: Ready for new alignment calculation
ANALYZE_ADDRESS: Single-cycle address analysis and strategy selection
CALC_FIRST_TRANSFER: Generate alignment transfer parameters
CALC_STREAMING: Calculate optimal streaming burst parameters  
CALC_FINAL_TRANSFER: Handle final partial transfer
ALIGNMENT_COMPLETE: Provide complete alignment information to engines
ALIGNMENT_ERROR: Handle invalid alignment scenarios
@enduml