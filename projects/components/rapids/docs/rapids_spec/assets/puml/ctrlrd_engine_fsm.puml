@startuml ctrlrd_engine_fsm
!theme plain
title Control Read Engine FSM (ctrlrd_engine.sv)

skinparam state {
  BackgroundColor LightCyan
  BorderColor DarkCyan
  ArrowColor DarkCyan
  ArrowFontColor Black
  ArrowFontSize 10
}

[*] --> READ_IDLE

state READ_IDLE {
  READ_IDLE : ctrlrd_engine_idle = true when:
  READ_IDLE : • FSM in READ_IDLE state
  READ_IDLE : • Ctrlrd request FIFO empty
  READ_IDLE : • No active AXI transactions
  READ_IDLE : • !r_channel_reset_active
}
state READ_ISSUE_ADDR {
  READ_ISSUE_ADDR : Issue AXI read address phase
  READ_ISSUE_ADDR : Initialize retry counter
  READ_ISSUE_ADDR : Store expected data and mask
}
state READ_WAIT_DATA {
  READ_WAIT_DATA : Wait for AXI read data response
  READ_WAIT_DATA : Monitor response with our channel ID
  READ_WAIT_DATA : Capture read data for comparison
}
state READ_COMPARE {
  READ_COMPARE : Compare (read_data & mask) == (expected_data & mask)
  READ_COMPARE : Check for AXI response errors
  READ_COMPARE : Determine retry or completion
}
state READ_RETRY_WAIT {
  READ_RETRY_WAIT : Wait for 1µs tick_1us pulse
  READ_RETRY_WAIT : Decrement retry counter
  READ_RETRY_WAIT : Prepare for next read attempt
}
state READ_MATCH {
  READ_MATCH : Read data matched expected value
  READ_MATCH : Assert ctrlrd_ready without error
  READ_MATCH : Return to IDLE on handshake
}
state READ_ERROR {
  READ_ERROR : Error conditions:
  READ_ERROR : • Max retries exceeded
  READ_ERROR : • AXI response error (SLVERR/DECERR)
  READ_ERROR : Assert ctrlrd_ready with error flag
}

READ_IDLE -down-> READ_ISSUE_ADDR : w_ctrlrd_req_skid_valid_out & !w_null_address & !r_channel_reset_active
READ_IDLE -right-> READ_MATCH : w_ctrlrd_req_skid_valid_out & w_null_address
READ_ISSUE_ADDR -down-> READ_WAIT_DATA : ar_valid & ar_ready
READ_ISSUE_ADDR -right-> READ_ERROR : ar_timeout
READ_WAIT_DATA -down-> READ_COMPARE : w_transaction_complete
READ_WAIT_DATA -right-> READ_ERROR : r_timeout
READ_COMPARE -down-> READ_MATCH : w_data_match & !w_axi_response_error
READ_COMPARE -right-> READ_RETRY_WAIT : !w_data_match & w_retries_remaining & !w_axi_response_error
READ_COMPARE -down-> READ_ERROR : !w_data_match & !w_retries_remaining | w_axi_response_error
READ_RETRY_WAIT -up-> READ_ISSUE_ADDR : tick_1us & r_retry_wait_complete
READ_MATCH -up-> READ_IDLE : ctrlrd_valid & ctrlrd_ready | r_channel_reset_active
READ_ERROR -up-> READ_IDLE : ctrlrd_valid & ctrlrd_ready | r_channel_reset_active

note bottom
<b>Signal Definitions (ctrlrd_engine.sv):</b>

w_ctrlrd_req_skid_valid_out = control read request available in skid buffer
w_null_address = (ctrlrd_pkt_addr == 64'h0) // Skip operation - immediate success
r_channel_reset_active = channel reset state flag

w_transaction_complete = w_our_axi_response & r_valid
w_our_axi_response = r_valid & (r_id == r_expected_axi_id)
w_axi_response_error = (r_resp != 2'b00) // Not OKAY

<b>Masked Comparison Logic:</b>
w_masked_expected = r_expected_data & r_mask
w_masked_actual = r_axi_read_data & r_mask
w_data_match = (w_masked_expected == w_masked_actual)

<b>Retry Management:</b>
r_retry_counter = cfg_ctrlrd_max_try[8:0] (loaded at READ_ISSUE_ADDR)
w_retries_remaining = (r_retry_counter > 0)
tick_1us = 1µs pulse from counter_freq_invariant at scheduler_group level
r_retry_wait_complete = tick_1us pulse received in READ_RETRY_WAIT state

<b>Handshake Signals:</b>
ctrlrd_ready asserts in:
- READ_MATCH state: ctrlrd_ready = 1, ctrlrd_error = 0 (success)
- READ_ERROR state: ctrlrd_ready = 1, ctrlrd_error = 1 (failure)

ctrlrd_error valid when: ctrlrd_valid & ctrlrd_ready (both asserted)

<b>State Functions:</b>

READ_IDLE:
- Monitor control read request FIFO
- Null address handling (immediate success, no AXI transaction)
- Channel reset coordination

READ_ISSUE_ADDR:
- Initialize retry counter from cfg_ctrlrd_max_try[8:0]
- Store expected_data and mask for comparison
- Issue AXI read address phase
- Timeout monitoring

READ_WAIT_DATA:
- Wait for AXI read data response
- Channel ID matching (r_id == r_expected_axi_id)
- Capture read data for comparison

READ_COMPARE:
- Masked comparison: (read_data & mask) == (expected_data & mask)
- Check AXI response (OKAY/SLVERR/DECERR)
- Decision:
  → Match + OKAY → READ_MATCH (success)
  → Mismatch + retries remaining → READ_RETRY_WAIT
  → Mismatch + no retries → READ_ERROR
  → AXI error → READ_ERROR

READ_RETRY_WAIT:
- Wait for 1µs tick_1us pulse
- Decrement retry counter
- Return to READ_ISSUE_ADDR for next attempt

READ_MATCH:
- Assert ctrlrd_ready = 1, ctrlrd_error = 0
- Provide read result in ctrlrd_result[31:0]
- Wait for scheduler handshake (ctrlrd_valid & ctrlrd_ready)

READ_ERROR:
- Assert ctrlrd_ready = 1, ctrlrd_error = 1
- Error reasons:
  • Max retries exceeded without match
  • AXI response error (SLVERR/DECERR)
  • Timeout on AR or R channel
- Wait for scheduler handshake (ctrlrd_valid & ctrlrd_ready)

<b>Multi-Channel AXI Support:</b>
- Shared AXI interface with ID-based response routing
- Channel ID encoded in lower bits of AXI ID
- Response filtering by expected channel ID

<b>Null Address Handling:</b>
- Address 0x0 operations skipped immediately
- Immediate success without AXI transaction
- Supports conditional control read patterns

<b>1µs Delay Integration:</b>
- tick_1us from counter_freq_invariant at scheduler_group level
- Shared across all ctrlrd engines
- Frequency-invariant 1µs period regardless of clock frequency

<b>Retry Mechanism:</b>
- Configurable max retries: cfg_ctrlrd_max_try[8:0] (0-511)
- 1µs delay between retry attempts
- Exponential backoff NOT used (fixed 1µs delay)
- Retry counter decrements each attempt

<b>Channel Reset Behavior:</b>
- Graceful shutdown from any state
- Safe state transitions during reset
- READ_MATCH/READ_ERROR allow handshake completion

<b>Monitor Integration:</b>
- Control read completion events
- Data mismatch retry attempts
- Max retry error reporting
- AXI response error reporting
@enduml
