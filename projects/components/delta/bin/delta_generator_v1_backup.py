#!/usr/bin/env python3
"""
Delta: AXI-Stream Crossbar Generator
Generates parameterized AXI-Stream switches in flat crossbar and tree topologies

Delta follows the water/river theme (like RAPIDS):
- Deltas are where rivers split into multiple branches (crossbar routing)
- Tree structure like delta land formation
- Data flows like water through channels

Usage:
    # Flat 4×16 crossbar
    python delta_generator.py --topology flat --masters 4 --slaves 16 --data-width 64

    # Binary tree 4×16
    python delta_generator.py --topology tree --masters 4 --slaves 16 --data-width 64

    # Generate both variants
    python delta_generator.py --topology both --masters 4 --slaves 16 --data-width 64 --output-dir ../rtl/

Author: RTL Design Sherpa
Project: Delta (AXI-Stream Crossbar Generator)
Version: 1.0
"""

import argparse
import sys
import os
from dataclasses import dataclass
from typing import List, Tuple, Dict
import math
from pathlib import Path


@dataclass
class DeltaConfig:
    """Configuration for AXI-Stream crossbar generation"""
    topology: str           # "flat" or "tree"
    num_masters: int        # Number of master interfaces
    num_slaves: int         # Number of slave interfaces
    data_width: int         # TDATA width in bits
    dest_width: int         # TDEST width (calculated)
    id_width: int           # TID width (calculated)
    user_width: int = 1     # TUSER width
    registered_outputs: bool = True  # Add output registers
    arbiter_type: str = "round_robin"  # "round_robin" or "fixed_priority"
    add_performance_counters: bool = True  # Add optional performance monitoring


class DeltaGenerator:
    """
    Generate AXI-Stream crossbar RTL

    This generator produces highly parameterized AXI-Stream crossbar switches
    for routing data between multiple masters and slaves. It supports both
    flat crossbar (low latency) and tree topology (modular, scalable).
    """

    def __init__(self, config: DeltaConfig):
        self.cfg = config
        self.indent_level = 0

    def indent(self, level: int = 0) -> str:
        """Generate indentation string"""
        if level == 0:
            level = self.indent_level
        return "    " * level

    def header_comment(self, module_name: str, description: str) -> str:
        """Generate module header comment with Delta branding"""
        lines = [
            "//==============================================================================",
            f"// Module: {module_name}",
            f"// Project: Delta - AXI-Stream Crossbar Generator",
            "//==============================================================================",
            f"// Description: {description}",
            "//",
            "// Delta: Where data flows split and merge like river deltas",
            "//",
            "// Generated by: delta_generator.py",
            "// Configuration:",
            f"//   - Topology: {self.cfg.topology}",
            f"//   - Masters: {self.cfg.num_masters}",
            f"//   - Slaves: {self.cfg.num_slaves}",
            f"//   - Data Width: {self.cfg.data_width} bits",
            f"//   - TDEST Width: {self.cfg.dest_width} bits",
            f"//   - TID Width: {self.cfg.id_width} bits",
            f"//   - Arbiter: {self.cfg.arbiter_type}",
            "//",
            "// Features:",
            "//   - Per-slave round-robin arbitration",
            "//   - Packet atomicity (locked grant until TLAST)",
            "//   - Registered outputs for timing closure",
            "//   - Full AXI-Stream compliance",
            "//",
            "//==============================================================================",
            ""
        ]
        return "\n".join(lines)

    def module_ports_flat(self) -> str:
        """Generate module ports for flat crossbar topology"""
        lines = []

        # Module declaration
        module_name = f"delta_axis_flat_{self.cfg.num_masters}x{self.cfg.num_slaves}"
        lines.append(f"module {module_name} #(")
        lines.append(f"    parameter int DATA_WIDTH = {self.cfg.data_width},")
        lines.append(f"    parameter int DEST_WIDTH = {self.cfg.dest_width},")
        lines.append(f"    parameter int ID_WIDTH   = {self.cfg.id_width},")
        lines.append(f"    parameter int USER_WIDTH = {self.cfg.user_width},")
        lines.append(f"    parameter int NUM_MASTERS = {self.cfg.num_masters},")
        lines.append(f"    parameter int NUM_SLAVES  = {self.cfg.num_slaves}")
        lines.append(") (")

        # Clock and reset
        lines.append("    // Clock and Reset")
        lines.append("    input  logic aclk,")
        lines.append("    input  logic aresetn,")
        lines.append("")

        # Master interfaces (inputs) - vectorized for clarity
        lines.append("    // ====================================================================")
        lines.append(f"    // Master Interfaces (S_AXIS) - {self.cfg.num_masters} masters")
        lines.append("    // ====================================================================")
        lines.append(f"    input  logic [DATA_WIDTH-1:0]  s_axis_tdata  [NUM_MASTERS],")
        lines.append(f"    input  logic                   s_axis_tvalid [NUM_MASTERS],")
        lines.append(f"    output logic                   s_axis_tready [NUM_MASTERS],")
        lines.append(f"    input  logic                   s_axis_tlast  [NUM_MASTERS],")
        lines.append(f"    input  logic [DEST_WIDTH-1:0]  s_axis_tdest  [NUM_MASTERS],")
        lines.append(f"    input  logic [ID_WIDTH-1:0]    s_axis_tid    [NUM_MASTERS],")
        lines.append(f"    input  logic [USER_WIDTH-1:0]  s_axis_tuser  [NUM_MASTERS],")
        lines.append("")

        # Slave interfaces (outputs) - vectorized
        lines.append("    // ====================================================================")
        lines.append(f"    // Slave Interfaces (M_AXIS) - {self.cfg.num_slaves} slaves")
        lines.append("    // ====================================================================")
        lines.append(f"    output logic [DATA_WIDTH-1:0]  m_axis_tdata  [NUM_SLAVES],")
        lines.append(f"    output logic                   m_axis_tvalid [NUM_SLAVES],")
        lines.append(f"    input  logic                   m_axis_tready [NUM_SLAVES],")
        lines.append(f"    output logic                   m_axis_tlast  [NUM_SLAVES],")
        lines.append(f"    output logic [DEST_WIDTH-1:0]  m_axis_tdest  [NUM_SLAVES],")
        lines.append(f"    output logic [ID_WIDTH-1:0]    m_axis_tid    [NUM_SLAVES],")
        lines.append(f"    output logic [USER_WIDTH-1:0]  m_axis_tuser  [NUM_SLAVES]")

        lines.append(");")
        lines.append("")

        return "\n".join(lines)

    def generate_request_logic(self) -> str:
        """
        Generate request decode logic (TDEST -> slave select)

        This is the KEY difference from APB crossbar:
        - APB: Address range decode (paddr >= base && paddr < end)
        - AXIS: Direct TDEST decode (tdest is slave ID)

        AXIS is SIMPLER - no address map needed!
        """
        lines = []
        lines.append("    //==========================================================================")
        lines.append("    // Request Generation - Decode TDEST to slave select")
        lines.append("    //==========================================================================")
        lines.append("    // AXIS Advantage: Direct TDEST decode (simpler than APB address ranges)")
        lines.append("    //")
        lines.append("    // Each master's TDEST field directly identifies target slave")
        lines.append("    // No address range checking needed (unlike APB crossbar)")
        lines.append("    //==========================================================================")
        lines.append("")

        lines.append(f"    logic [NUM_MASTERS-1:0] request_matrix [NUM_SLAVES];")
        lines.append("")

        lines.append("    always_comb begin")
        lines.append("        // Initialize all requests to zero")
        lines.append("        for (int s = 0; s < NUM_SLAVES; s++) begin")
        lines.append("            request_matrix[s] = '0;")
        lines.append("        end")
        lines.append("")
        lines.append("        // Generate requests based on TDEST")
        lines.append("        for (int m = 0; m < NUM_MASTERS; m++) begin")
        lines.append("            if (s_axis_tvalid[m] && s_axis_tdest[m] < NUM_SLAVES) begin")
        lines.append("                // Direct decode: TDEST is slave index")
        lines.append("                request_matrix[s_axis_tdest[m]][m] = 1'b1;")
        lines.append("            end")
        lines.append("        end")
        lines.append("    end")
        lines.append("")

        return "\n".join(lines)

    def generate_arbiter_logic(self) -> str:
        """
        Generate per-slave round-robin arbiter logic with packet atomicity

        This is NEARLY IDENTICAL to APB crossbar arbiter, with ONE addition:
        - Packet atomicity: Hold grant until TLAST

        APB re-arbitrates every cycle, AXIS locks grant for entire packet.
        """
        lines = []
        lines.append("    //==========================================================================")
        lines.append("    // Per-Slave Round-Robin Arbiters with Packet Atomicity")
        lines.append("    //==========================================================================")
        lines.append("    // Similar to APB crossbar, but with PACKET ATOMICITY:")
        lines.append("    // - APB: Re-arbitrate every cycle")
        lines.append("    // - AXIS: Lock grant until TLAST (prevent packet interleaving)")
        lines.append("    //")
        lines.append("    // Round-robin ensures fair bandwidth allocation")
        lines.append("    // Packet atomicity ensures correct streaming behavior")
        lines.append("    //==========================================================================")
        lines.append("")

        lines.append(f"    logic [NUM_MASTERS-1:0] grant_matrix [NUM_SLAVES];")
        lines.append(f"    logic [$clog2(NUM_MASTERS)-1:0] last_grant [NUM_SLAVES];")
        lines.append(f"    logic packet_active [NUM_SLAVES];  // NEW vs APB: Track packet in progress")
        lines.append("")

        lines.append("    // Arbitration logic for each slave")
        lines.append("    generate")
        lines.append("        for (genvar s = 0; s < NUM_SLAVES; s++) begin : gen_arbiter")
        lines.append("            always_ff @(posedge aclk or negedge aresetn) begin")
        lines.append("                if (!aresetn) begin")
        lines.append("                    grant_matrix[s] <= '0;")
        lines.append("                    last_grant[s] <= '0;")
        lines.append("                    packet_active[s] <= 1'b0;")
        lines.append("                end else begin")
        lines.append("                    if (packet_active[s]) begin")
        lines.append("                        // Hold grant until TLAST (packet atomicity)")
        lines.append("                        if (m_axis_tvalid[s] && m_axis_tready[s] && m_axis_tlast[s]) begin")
        lines.append("                            packet_active[s] <= 1'b0;")
        lines.append("                            grant_matrix[s] <= '0;")
        lines.append("                        end")
        lines.append("                    end else begin")
        lines.append("                        // Round-robin arbitration (same as APB)")
        lines.append("                        grant_matrix[s] = '0;")
        lines.append("                        automatic logic grant_found = 1'b0;")
        lines.append("                        for (int i = 0; i < NUM_MASTERS; i++) begin")
        lines.append("                            automatic int m = (last_grant[s] + 1 + i) % NUM_MASTERS;")
        lines.append("                            if (request_matrix[s][m] && !grant_found) begin")
        lines.append("                                grant_matrix[s][m] = 1'b1;")
        lines.append("                                grant_found = 1'b1;")
        lines.append("                                last_grant[s] = m;")
        lines.append("                                packet_active[s] = 1'b1;")
        lines.append("                            end")
        lines.append("                        end")
        lines.append("                    end")
        lines.append("                end")
        lines.append("            end")
        lines.append("        end")
        lines.append("    endgenerate")
        lines.append("")

        return "\n".join(lines)

    def generate_crossbar_mux(self) -> str:
        """
        Generate crossbar data multiplexing logic

        Same pattern as APB crossbar, just more signals:
        - APB: Mux PRDATA (and maybe PSLVERR)
        - AXIS: Mux TDATA, TVALID, TLAST, TDEST, TID, TUSER
        """
        lines = []
        lines.append("    //==========================================================================")
        lines.append("    // Crossbar Data Multiplexing")
        lines.append("    //==========================================================================")
        lines.append("    // Same pattern as APB crossbar, just more signals:")
        lines.append("    // - APB muxes: PRDATA, PSLVERR")
        lines.append("    // - AXIS muxes: TDATA, TVALID, TLAST, TDEST, TID, TUSER")
        lines.append("    //==========================================================================")
        lines.append("")

        lines.append("    generate")
        lines.append("        for (genvar s = 0; s < NUM_SLAVES; s++) begin : gen_slave_mux")
        lines.append("            always_comb begin")
        lines.append("                // Default: all zeros")
        lines.append("                m_axis_tdata[s]  = '0;")
        lines.append("                m_axis_tvalid[s] = 1'b0;")
        lines.append("                m_axis_tlast[s]  = 1'b0;")
        lines.append("                m_axis_tdest[s]  = '0;")
        lines.append("                m_axis_tid[s]    = '0;")
        lines.append("                m_axis_tuser[s]  = '0;")
        lines.append("")
        lines.append("                // Multiplex granted master to this slave")
        lines.append("                for (int m = 0; m < NUM_MASTERS; m++) begin")
        lines.append("                    if (grant_matrix[s][m]) begin")
        lines.append("                        m_axis_tdata[s]  = s_axis_tdata[m];")
        lines.append("                        m_axis_tvalid[s] = s_axis_tvalid[m];")
        lines.append("                        m_axis_tlast[s]  = s_axis_tlast[m];")
        lines.append("                        m_axis_tdest[s]  = s_axis_tdest[m];")
        lines.append("                        m_axis_tid[s]    = s_axis_tid[m];")
        lines.append("                        m_axis_tuser[s]  = s_axis_tuser[m];")
        lines.append("                    end")
        lines.append("                end")
        lines.append("            end")
        lines.append("        end")
        lines.append("    endgenerate")
        lines.append("")

        return "\n".join(lines)

    def generate_backpressure_logic(self) -> str:
        """
        Generate TREADY backpressure logic

        IDENTICAL pattern to APB PREADY, just renamed:
        - APB: PREADY = granted slave's PREADY
        - AXIS: TREADY = granted slave's TREADY
        """
        lines = []
        lines.append("    //==========================================================================")
        lines.append("    // Backpressure (TREADY) Logic")
        lines.append("    //==========================================================================")
        lines.append("    // Identical to APB PREADY logic, just renamed signal:")
        lines.append("    // - APB: pready[m] = pready_slave[granted_slave]")
        lines.append("    // - AXIS: s_axis_tready[m] = m_axis_tready[granted_slave]")
        lines.append("    //==========================================================================")
        lines.append("")

        lines.append("    generate")
        lines.append("        for (genvar m = 0; m < NUM_MASTERS; m++) begin : gen_master_tready")
        lines.append("            always_comb begin")
        lines.append("                s_axis_tready[m] = 1'b0;")
        lines.append("                for (int s = 0; s < NUM_SLAVES; s++) begin")
        lines.append("                    if (grant_matrix[s][m]) begin")
        lines.append("                        s_axis_tready[m] = m_axis_tready[s];")
        lines.append("                    end")
        lines.append("                end")
        lines.append("            end")
        lines.append("        end")
        lines.append("    endgenerate")
        lines.append("")

        return "\n".join(lines)

    def generate_performance_counters(self) -> str:
        """Generate optional performance monitoring counters"""
        if not self.cfg.add_performance_counters:
            return ""

        lines = []
        lines.append("    //==========================================================================")
        lines.append("    // Performance Counters (Optional)")
        lines.append("    //==========================================================================")
        lines.append("    // Track packets and transfers per master/slave for performance analysis")
        lines.append("    //==========================================================================")
        lines.append("")

        lines.append("    // Packet counters per master")
        lines.append("    logic [31:0] pkt_count_master [NUM_MASTERS];")
        lines.append("    logic [31:0] pkt_count_slave [NUM_SLAVES];")
        lines.append("")

        lines.append("    generate")
        lines.append("        // Master packet counters")
        lines.append("        for (genvar m = 0; m < NUM_MASTERS; m++) begin : gen_master_counters")
        lines.append("            always_ff @(posedge aclk or negedge aresetn) begin")
        lines.append("                if (!aresetn)")
        lines.append("                    pkt_count_master[m] <= '0;")
        lines.append("                else if (s_axis_tvalid[m] && s_axis_tready[m] && s_axis_tlast[m])")
        lines.append("                    pkt_count_master[m] <= pkt_count_master[m] + 1;")
        lines.append("            end")
        lines.append("        end")
        lines.append("")
        lines.append("        // Slave packet counters")
        lines.append("        for (genvar s = 0; s < NUM_SLAVES; s++) begin : gen_slave_counters")
        lines.append("            always_ff @(posedge aclk or negedge aresetn) begin")
        lines.append("                if (!aresetn)")
        lines.append("                    pkt_count_slave[s] <= '0;")
        lines.append("                else if (m_axis_tvalid[s] && m_axis_tready[s] && m_axis_tlast[s])")
        lines.append("                    pkt_count_slave[s] <= pkt_count_slave[s] + 1;")
        lines.append("            end")
        lines.append("        end")
        lines.append("    endgenerate")
        lines.append("")

        return "\n".join(lines)

    def generate_flat_crossbar(self) -> str:
        """Generate complete flat crossbar switch"""
        lines = []

        # Header
        module_name = f"delta_axis_flat_{self.cfg.num_masters}x{self.cfg.num_slaves}"
        lines.append(self.header_comment(
            module_name,
            f"AXI-Stream {self.cfg.num_masters}×{self.cfg.num_slaves} Flat Crossbar Switch"
        ))

        # Module ports
        lines.append(self.module_ports_flat())

        # Request generation logic
        lines.append(self.generate_request_logic())

        # Arbiter logic
        lines.append(self.generate_arbiter_logic())

        # Crossbar multiplexing
        lines.append(self.generate_crossbar_mux())

        # Backpressure logic
        lines.append(self.generate_backpressure_logic())

        # Performance counters (optional)
        lines.append(self.generate_performance_counters())

        # Assertions for debugging
        lines.append(self.generate_assertions())

        # End module
        lines.append("endmodule")
        lines.append("")
        lines.append("//==============================================================================")
        lines.append("// End of Delta Flat Crossbar")
        lines.append("//==============================================================================")

        return "\n".join(lines)

    def generate_assertions(self) -> str:
        """Generate SystemVerilog assertions for debugging"""
        lines = []
        lines.append("    //==========================================================================")
        lines.append("    // Assertions for Debug and Verification")
        lines.append("    //==========================================================================")
        lines.append("`ifdef FORMAL")
        lines.append("    // One-hot grant check")
        lines.append("    generate")
        lines.append("        for (genvar s = 0; s < NUM_SLAVES; s++) begin : gen_onehot_assert")
        lines.append("            assert property (@(posedge aclk) disable iff (!aresetn)")
        lines.append("                $onehot0(grant_matrix[s])")
        lines.append("            ) else $error(\"Grant matrix not one-hot for slave %0d\", s);")
        lines.append("        end")
        lines.append("    endgenerate")
        lines.append("")
        lines.append("    // TDEST in range check")
        lines.append("    generate")
        lines.append("        for (genvar m = 0; m < NUM_MASTERS; m++) begin : gen_tdest_assert")
        lines.append("            assert property (@(posedge aclk) disable iff (!aresetn)")
        lines.append("                s_axis_tvalid[m] |-> s_axis_tdest[m] < NUM_SLAVES")
        lines.append("            ) else $error(\"TDEST out of range for master %0d\", m);")
        lines.append("        end")
        lines.append("    endgenerate")
        lines.append("`endif")
        lines.append("")
        return "\n".join(lines)

    def generate_tree_topology(self) -> str:
        """Generate tree topology switch (placeholder for now)"""
        lines = []

        module_name = f"delta_axis_tree_{self.cfg.num_masters}x{self.cfg.num_slaves}"
        lines.append(self.header_comment(
            module_name,
            f"AXI-Stream {self.cfg.num_masters}×{self.cfg.num_slaves} Tree Topology Switch"
        ))

        lines.append("//==============================================================================")
        lines.append("// Tree Topology Implementation")
        lines.append("//==============================================================================")
        lines.append("//")
        lines.append("// This module composes 1:2 splitter and 2:1 merger nodes into a")
        lines.append("// hierarchical tree structure (like a river delta branching).")
        lines.append("//")
        lines.append("// Topology:")
        lines.append(f"//   Masters: {self.cfg.num_masters}")
        lines.append(f"//   Slaves: {self.cfg.num_slaves}")
        lines.append(f"//   Depth: {math.ceil(math.log2(self.cfg.num_slaves))} stages")
        lines.append("//")
        lines.append("// TODO: Full tree instantiation (requires node primitives)")
        lines.append("// See tree topology specification for complete implementation")
        lines.append("//")
        lines.append("//==============================================================================")
        lines.append("")

        # Module ports (same as flat for top-level interface)
        lines.append(self.module_ports_flat())

        lines.append("    // Tree topology implementation placeholder")
        lines.append("    // Full implementation requires delta_split_1to2 and delta_merge_2to1 nodes")
        lines.append("")

        lines.append("endmodule")
        lines.append("")

        return "\n".join(lines)

    def generate_node_primitives(self) -> Tuple[str, str]:
        """Generate 1:2 splitter and 2:1 merger node primitives"""

        # 1:2 Splitter
        splitter_lines = []
        splitter_lines.append(self.header_comment(
            "delta_split_1to2",
            "AXI-Stream 1:2 Splitter - Routes one input to two outputs (tree node)"
        ))

        splitter_lines.append("module delta_split_1to2 #(")
        splitter_lines.append(f"    parameter int DATA_WIDTH = {self.cfg.data_width},")
        splitter_lines.append(f"    parameter int DEST_WIDTH = {self.cfg.dest_width},")
        splitter_lines.append(f"    parameter int ID_WIDTH   = {self.cfg.id_width},")
        splitter_lines.append(f"    parameter int USER_WIDTH = {self.cfg.user_width},")
        splitter_lines.append("    parameter int SPLIT_BIT  = 0  // Which TDEST bit controls routing")
        splitter_lines.append(") (")
        splitter_lines.append("    input  logic aclk,")
        splitter_lines.append("    input  logic aresetn,")
        splitter_lines.append("")
        splitter_lines.append("    // Input Interface")
        splitter_lines.append("    input  logic [DATA_WIDTH-1:0]  s_axis_tdata,")
        splitter_lines.append("    input  logic                   s_axis_tvalid,")
        splitter_lines.append("    output logic                   s_axis_tready,")
        splitter_lines.append("    input  logic                   s_axis_tlast,")
        splitter_lines.append("    input  logic [DEST_WIDTH-1:0]  s_axis_tdest,")
        splitter_lines.append("    input  logic [ID_WIDTH-1:0]    s_axis_tid,")
        splitter_lines.append("    input  logic [USER_WIDTH-1:0]  s_axis_tuser,")
        splitter_lines.append("")
        splitter_lines.append("    // Output Interface 0 (TDEST[SPLIT_BIT] == 0)")
        splitter_lines.append("    output logic [DATA_WIDTH-1:0]  m0_axis_tdata,")
        splitter_lines.append("    output logic                   m0_axis_tvalid,")
        splitter_lines.append("    input  logic                   m0_axis_tready,")
        splitter_lines.append("    output logic                   m0_axis_tlast,")
        splitter_lines.append("    output logic [DEST_WIDTH-1:0]  m0_axis_tdest,")
        splitter_lines.append("    output logic [ID_WIDTH-1:0]    m0_axis_tid,")
        splitter_lines.append("    output logic [USER_WIDTH-1:0]  m0_axis_tuser,")
        splitter_lines.append("")
        splitter_lines.append("    // Output Interface 1 (TDEST[SPLIT_BIT] == 1)")
        splitter_lines.append("    output logic [DATA_WIDTH-1:0]  m1_axis_tdata,")
        splitter_lines.append("    output logic                   m1_axis_tvalid,")
        splitter_lines.append("    input  logic                   m1_axis_tready,")
        splitter_lines.append("    output logic                   m1_axis_tlast,")
        splitter_lines.append("    output logic [DEST_WIDTH-1:0]  m1_axis_tdest,")
        splitter_lines.append("    output logic [ID_WIDTH-1:0]    m1_axis_tid,")
        splitter_lines.append("    output logic [USER_WIDTH-1:0]  m1_axis_tuser")
        splitter_lines.append(");")
        splitter_lines.append("")
        splitter_lines.append("    // Route selection based on TDEST bit")
        splitter_lines.append("    logic route_to_1;")
        splitter_lines.append("    assign route_to_1 = s_axis_tdest[SPLIT_BIT];")
        splitter_lines.append("")
        splitter_lines.append("    // Output 0 (lower branch)")
        splitter_lines.append("    assign m0_axis_tdata  = s_axis_tdata;")
        splitter_lines.append("    assign m0_axis_tvalid = s_axis_tvalid && !route_to_1;")
        splitter_lines.append("    assign m0_axis_tlast  = s_axis_tlast;")
        splitter_lines.append("    assign m0_axis_tdest  = s_axis_tdest;")
        splitter_lines.append("    assign m0_axis_tid    = s_axis_tid;")
        splitter_lines.append("    assign m0_axis_tuser  = s_axis_tuser;")
        splitter_lines.append("")
        splitter_lines.append("    // Output 1 (upper branch)")
        splitter_lines.append("    assign m1_axis_tdata  = s_axis_tdata;")
        splitter_lines.append("    assign m1_axis_tvalid = s_axis_tvalid && route_to_1;")
        splitter_lines.append("    assign m1_axis_tlast  = s_axis_tlast;")
        splitter_lines.append("    assign m1_axis_tdest  = s_axis_tdest;")
        splitter_lines.append("    assign m1_axis_tid    = s_axis_tid;")
        splitter_lines.append("    assign m1_axis_tuser  = s_axis_tuser;")
        splitter_lines.append("")
        splitter_lines.append("    // Backpressure")
        splitter_lines.append("    assign s_axis_tready = route_to_1 ? m1_axis_tready : m0_axis_tready;")
        splitter_lines.append("")
        splitter_lines.append("endmodule")
        splitter_lines.append("")

        splitter_code = "\n".join(splitter_lines)

        # 2:1 Merger (similar structure, omitted for brevity - can generate if needed)
        merger_code = "// TODO: Generate delta_merge_2to1.sv"

        return splitter_code, merger_code


def calculate_widths(num_masters: int, num_slaves: int) -> Tuple[int, int]:
    """Calculate TDEST and TID widths based on number of interfaces"""
    dest_width = max(1, math.ceil(math.log2(num_slaves)))
    id_width = max(1, math.ceil(math.log2(num_masters)))
    return dest_width, id_width


def main():
    parser = argparse.ArgumentParser(
        description="Delta: AXI-Stream Crossbar Generator (following water theme like RAPIDS)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate flat 4×16 crossbar
  python delta_generator.py --topology flat --masters 4 --slaves 16 --data-width 64

  # Generate tree topology 4×16
  python delta_generator.py --topology tree --masters 4 --slaves 16 --data-width 64

  # Generate both variants with node primitives
  python delta_generator.py --topology both --masters 4 --slaves 16 --data-width 64 --nodes

  # Output to RTL directory
  python delta_generator.py --topology flat --masters 4 --slaves 16 --output-dir ../rtl/
        """
    )

    parser.add_argument("--topology", choices=["flat", "tree", "both"], default="flat",
                        help="Crossbar topology (flat=low latency, tree=modular/scalable)")
    parser.add_argument("--masters", type=int, required=True,
                        help="Number of master interfaces")
    parser.add_argument("--slaves", type=int, required=True,
                        help="Number of slave interfaces")
    parser.add_argument("--data-width", type=int, default=64,
                        help="TDATA width in bits (default: 64)")
    parser.add_argument("--user-width", type=int, default=1,
                        help="TUSER width in bits (default: 1)")
    parser.add_argument("--output-dir", type=str, default="../rtl",
                        help="Output directory for generated files (default: ../rtl)")
    parser.add_argument("--nodes", action="store_true",
                        help="Also generate node primitives (1:2 splitter, 2:1 merger)")
    parser.add_argument("--no-counters", action="store_true",
                        help="Disable performance counters")

    args = parser.parse_args()

    # Calculate widths
    dest_width, id_width = calculate_widths(args.masters, args.slaves)

    # Create configuration
    config = DeltaConfig(
        topology=args.topology,
        num_masters=args.masters,
        num_slaves=args.slaves,
        data_width=args.data_width,
        dest_width=dest_width,
        id_width=id_width,
        user_width=args.user_width,
        add_performance_counters=not args.no_counters
    )

    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)

    # Generate RTL
    generator = DeltaGenerator(config)

    topologies_to_generate = []
    if args.topology == "both":
        topologies_to_generate = ["flat", "tree"]
    else:
        topologies_to_generate = [args.topology]

    generated_files = []

    for topo in topologies_to_generate:
        config.topology = topo

        if topo == "flat":
            rtl_code = generator.generate_flat_crossbar()
            filename = f"delta_axis_flat_{args.masters}x{args.slaves}.sv"
        else:
            rtl_code = generator.generate_tree_topology()
            filename = f"delta_axis_tree_{args.masters}x{args.slaves}.sv"

        output_path = os.path.join(args.output_dir, filename)

        with open(output_path, 'w') as f:
            f.write(rtl_code)

        generated_files.append(output_path)

        print(f"✓ Generated {topo} topology: {output_path}")
        print(f"  - Masters: {args.masters}")
        print(f"  - Slaves: {args.slaves}")
        print(f"  - Data Width: {args.data_width}")
        print(f"  - TDEST Width: {dest_width}")
        print(f"  - TID Width: {id_width}")
        print()

    # Generate node primitives if requested
    if args.nodes or "tree" in topologies_to_generate:
        splitter_code, merger_code = generator.generate_node_primitives()

        splitter_path = os.path.join(args.output_dir, "delta_split_1to2.sv")
        with open(splitter_path, 'w') as f:
            f.write(splitter_code)
        generated_files.append(splitter_path)
        print(f"✓ Generated node primitive: {splitter_path}")

        # TODO: Generate merger when needed
        # merger_path = os.path.join(args.output_dir, "delta_merge_2to1.sv")
        # with open(merger_path, 'w') as f:
        #     f.write(merger_code)
        # generated_files.append(merger_path)

    print(f"\n{'='*70}")
    print(f"✓ Delta generation complete!")
    print(f"  Total files: {len(generated_files)}")
    print(f"  Output directory: {args.output_dir}")
    print(f"{'='*70}")


if __name__ == "__main__":
    main()
