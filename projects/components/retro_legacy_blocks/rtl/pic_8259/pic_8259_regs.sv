// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module pic_8259_regs (
        input wire clk,
        input wire rst,

        input wire s_cpuif_req,
        input wire s_cpuif_req_is_wr,
        input wire [5:0] s_cpuif_addr,
        input wire [31:0] s_cpuif_wr_data,
        input wire [31:0] s_cpuif_wr_biten,
        output wire s_cpuif_req_stall_wr,
        output wire s_cpuif_req_stall_rd,
        output wire s_cpuif_rd_ack,
        output wire s_cpuif_rd_err,
        output wire [31:0] s_cpuif_rd_data,
        output wire s_cpuif_wr_ack,
        output wire s_cpuif_wr_err,

        input pic_8259_regs_pkg::pic_8259_regs__in_t hwif_in,
        output pic_8259_regs_pkg::pic_8259_regs__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [5:0] cpuif_addr;
    logic [31:0] cpuif_wr_data;
    logic [31:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [31:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    assign cpuif_req = s_cpuif_req;
    assign cpuif_req_is_wr = s_cpuif_req_is_wr;
    assign cpuif_addr = s_cpuif_addr;
    assign cpuif_wr_data = s_cpuif_wr_data;
    assign cpuif_wr_biten = s_cpuif_wr_biten;
    assign s_cpuif_req_stall_wr = cpuif_req_stall_wr;
    assign s_cpuif_req_stall_rd = cpuif_req_stall_rd;
    assign s_cpuif_rd_ack = cpuif_rd_ack;
    assign s_cpuif_rd_err = cpuif_rd_err;
    assign s_cpuif_rd_data = cpuif_rd_data;
    assign s_cpuif_wr_ack = cpuif_wr_ack;
    assign s_cpuif_wr_err = cpuif_wr_err;

    logic cpuif_req_masked;

    // Read & write latencies are balanced. Stalls not required
    assign cpuif_req_stall_rd = '0;
    assign cpuif_req_stall_wr = '0;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic PIC_CONFIG;
        logic PIC_ICW1;
        logic PIC_ICW2;
        logic PIC_ICW3;
        logic PIC_ICW4;
        logic PIC_OCW1;
        logic PIC_OCW2;
        logic PIC_OCW3;
        logic PIC_IRR;
        logic PIC_ISR;
        logic PIC_STATUS;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_req;
    logic decoded_req_is_wr;
    logic [31:0] decoded_wr_data;
    logic [31:0] decoded_wr_biten;

    always_comb begin
        decoded_reg_strb.PIC_CONFIG = cpuif_req_masked & (cpuif_addr == 6'h0);
        decoded_reg_strb.PIC_ICW1 = cpuif_req_masked & (cpuif_addr == 6'h4);
        decoded_reg_strb.PIC_ICW2 = cpuif_req_masked & (cpuif_addr == 6'h8);
        decoded_reg_strb.PIC_ICW3 = cpuif_req_masked & (cpuif_addr == 6'hc);
        decoded_reg_strb.PIC_ICW4 = cpuif_req_masked & (cpuif_addr == 6'h10);
        decoded_reg_strb.PIC_OCW1 = cpuif_req_masked & (cpuif_addr == 6'h14);
        decoded_reg_strb.PIC_OCW2 = cpuif_req_masked & (cpuif_addr == 6'h18);
        decoded_reg_strb.PIC_OCW3 = cpuif_req_masked & (cpuif_addr == 6'h1c);
        decoded_reg_strb.PIC_IRR = cpuif_req_masked & (cpuif_addr == 6'h20);
        decoded_reg_strb.PIC_ISR = cpuif_req_masked & (cpuif_addr == 6'h24);
        decoded_reg_strb.PIC_STATUS = cpuif_req_masked & (cpuif_addr == 6'h28);
    end

    // Pass down signals to next stage
    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic next;
                logic load_next;
            } pic_enable;
            struct {
                logic next;
                logic load_next;
            } init_mode;
            struct {
                logic next;
                logic load_next;
            } auto_reset_init;
        } PIC_CONFIG;
        struct {
            struct {
                logic next;
                logic load_next;
            } ic4;
            struct {
                logic next;
                logic load_next;
            } sngl;
            struct {
                logic next;
                logic load_next;
            } adi;
            struct {
                logic next;
                logic load_next;
            } ltim;
            struct {
                logic next;
                logic load_next;
            } icw1_marker;
        } PIC_ICW1;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } vector_base;
        } PIC_ICW2;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } cascade;
        } PIC_ICW3;
        struct {
            struct {
                logic next;
                logic load_next;
            } upm;
            struct {
                logic next;
                logic load_next;
            } aeoi;
            struct {
                logic [1:0] next;
                logic load_next;
            } buf_mode;
            struct {
                logic next;
                logic load_next;
            } sfnm;
        } PIC_ICW4;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } imr;
        } PIC_OCW1;
        struct {
            struct {
                logic [2:0] next;
                logic load_next;
            } irq_level;
            struct {
                logic [2:0] next;
                logic load_next;
            } eoi_cmd;
        } PIC_OCW2;
        struct {
            struct {
                logic [1:0] next;
                logic load_next;
            } read_reg_cmd;
            struct {
                logic next;
                logic load_next;
            } poll_cmd;
            struct {
                logic [1:0] next;
                logic load_next;
            } ocw3_marker;
            struct {
                logic [1:0] next;
                logic load_next;
            } smm_cmd;
        } PIC_OCW3;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic value;
            } pic_enable;
            struct {
                logic value;
            } init_mode;
            struct {
                logic value;
            } auto_reset_init;
        } PIC_CONFIG;
        struct {
            struct {
                logic value;
            } ic4;
            struct {
                logic value;
            } sngl;
            struct {
                logic value;
            } adi;
            struct {
                logic value;
            } ltim;
            struct {
                logic value;
            } icw1_marker;
        } PIC_ICW1;
        struct {
            struct {
                logic [7:0] value;
            } vector_base;
        } PIC_ICW2;
        struct {
            struct {
                logic [7:0] value;
            } cascade;
        } PIC_ICW3;
        struct {
            struct {
                logic value;
            } upm;
            struct {
                logic value;
            } aeoi;
            struct {
                logic [1:0] value;
            } buf_mode;
            struct {
                logic value;
            } sfnm;
        } PIC_ICW4;
        struct {
            struct {
                logic [7:0] value;
            } imr;
        } PIC_OCW1;
        struct {
            struct {
                logic [2:0] value;
            } irq_level;
            struct {
                logic [2:0] value;
            } eoi_cmd;
        } PIC_OCW2;
        struct {
            struct {
                logic [1:0] value;
            } read_reg_cmd;
            struct {
                logic value;
            } poll_cmd;
            struct {
                logic [1:0] value;
            } ocw3_marker;
            struct {
                logic [1:0] value;
            } smm_cmd;
        } PIC_OCW3;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: pic_8259_regs.PIC_CONFIG.pic_enable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_CONFIG.pic_enable.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_CONFIG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_CONFIG.pic_enable.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.PIC_CONFIG.pic_enable.next = next_c;
        field_combo.PIC_CONFIG.pic_enable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_CONFIG.pic_enable.value <= 1'h0;
        end else begin
            if(field_combo.PIC_CONFIG.pic_enable.load_next) begin
                field_storage.PIC_CONFIG.pic_enable.value <= field_combo.PIC_CONFIG.pic_enable.next;
            end
        end
    end
    assign hwif_out.PIC_CONFIG.pic_enable.value = field_storage.PIC_CONFIG.pic_enable.value;
    // Field: pic_8259_regs.PIC_CONFIG.init_mode
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_CONFIG.init_mode.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_CONFIG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_CONFIG.init_mode.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.PIC_CONFIG.init_mode.next;
            load_next_c = '1;
        end
        field_combo.PIC_CONFIG.init_mode.next = next_c;
        field_combo.PIC_CONFIG.init_mode.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_CONFIG.init_mode.value <= 1'h0;
        end else begin
            if(field_combo.PIC_CONFIG.init_mode.load_next) begin
                field_storage.PIC_CONFIG.init_mode.value <= field_combo.PIC_CONFIG.init_mode.next;
            end
        end
    end
    assign hwif_out.PIC_CONFIG.init_mode.value = field_storage.PIC_CONFIG.init_mode.value;
    // Field: pic_8259_regs.PIC_CONFIG.auto_reset_init
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_CONFIG.auto_reset_init.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_CONFIG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_CONFIG.auto_reset_init.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.PIC_CONFIG.auto_reset_init.next = next_c;
        field_combo.PIC_CONFIG.auto_reset_init.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_CONFIG.auto_reset_init.value <= 1'h1;
        end else begin
            if(field_combo.PIC_CONFIG.auto_reset_init.load_next) begin
                field_storage.PIC_CONFIG.auto_reset_init.value <= field_combo.PIC_CONFIG.auto_reset_init.next;
            end
        end
    end
    assign hwif_out.PIC_CONFIG.auto_reset_init.value = field_storage.PIC_CONFIG.auto_reset_init.value;
    // Field: pic_8259_regs.PIC_ICW1.ic4
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW1.ic4.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW1.ic4.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW1.ic4.next = next_c;
        field_combo.PIC_ICW1.ic4.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW1.ic4.value <= 1'h0;
        end else begin
            if(field_combo.PIC_ICW1.ic4.load_next) begin
                field_storage.PIC_ICW1.ic4.value <= field_combo.PIC_ICW1.ic4.next;
            end
        end
    end
    assign hwif_out.PIC_ICW1.ic4.value = field_storage.PIC_ICW1.ic4.value;
    // Field: pic_8259_regs.PIC_ICW1.sngl
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW1.sngl.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW1.sngl.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW1.sngl.next = next_c;
        field_combo.PIC_ICW1.sngl.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW1.sngl.value <= 1'h0;
        end else begin
            if(field_combo.PIC_ICW1.sngl.load_next) begin
                field_storage.PIC_ICW1.sngl.value <= field_combo.PIC_ICW1.sngl.next;
            end
        end
    end
    assign hwif_out.PIC_ICW1.sngl.value = field_storage.PIC_ICW1.sngl.value;
    // Field: pic_8259_regs.PIC_ICW1.adi
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW1.adi.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW1.adi.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW1.adi.next = next_c;
        field_combo.PIC_ICW1.adi.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW1.adi.value <= 1'h0;
        end else begin
            if(field_combo.PIC_ICW1.adi.load_next) begin
                field_storage.PIC_ICW1.adi.value <= field_combo.PIC_ICW1.adi.next;
            end
        end
    end
    assign hwif_out.PIC_ICW1.adi.value = field_storage.PIC_ICW1.adi.value;
    // Field: pic_8259_regs.PIC_ICW1.ltim
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW1.ltim.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW1.ltim.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW1.ltim.next = next_c;
        field_combo.PIC_ICW1.ltim.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW1.ltim.value <= 1'h0;
        end else begin
            if(field_combo.PIC_ICW1.ltim.load_next) begin
                field_storage.PIC_ICW1.ltim.value <= field_combo.PIC_ICW1.ltim.next;
            end
        end
    end
    assign hwif_out.PIC_ICW1.ltim.value = field_storage.PIC_ICW1.ltim.value;
    // Field: pic_8259_regs.PIC_ICW1.icw1_marker
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW1.icw1_marker.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW1.icw1_marker.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW1.icw1_marker.next = next_c;
        field_combo.PIC_ICW1.icw1_marker.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW1.icw1_marker.value <= 1'h1;
        end else begin
            if(field_combo.PIC_ICW1.icw1_marker.load_next) begin
                field_storage.PIC_ICW1.icw1_marker.value <= field_combo.PIC_ICW1.icw1_marker.next;
            end
        end
    end
    assign hwif_out.PIC_ICW1.icw1_marker.value = field_storage.PIC_ICW1.icw1_marker.value;
    // Field: pic_8259_regs.PIC_ICW2.vector_base
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW2.vector_base.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW2.vector_base.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW2.vector_base.next = next_c;
        field_combo.PIC_ICW2.vector_base.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW2.vector_base.value <= 8'h0;
        end else begin
            if(field_combo.PIC_ICW2.vector_base.load_next) begin
                field_storage.PIC_ICW2.vector_base.value <= field_combo.PIC_ICW2.vector_base.next;
            end
        end
    end
    assign hwif_out.PIC_ICW2.vector_base.value = field_storage.PIC_ICW2.vector_base.value;
    // Field: pic_8259_regs.PIC_ICW3.cascade
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW3.cascade.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW3 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW3.cascade.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW3.cascade.next = next_c;
        field_combo.PIC_ICW3.cascade.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW3.cascade.value <= 8'h0;
        end else begin
            if(field_combo.PIC_ICW3.cascade.load_next) begin
                field_storage.PIC_ICW3.cascade.value <= field_combo.PIC_ICW3.cascade.next;
            end
        end
    end
    assign hwif_out.PIC_ICW3.cascade.value = field_storage.PIC_ICW3.cascade.value;
    // Field: pic_8259_regs.PIC_ICW4.upm
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW4.upm.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW4 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW4.upm.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW4.upm.next = next_c;
        field_combo.PIC_ICW4.upm.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW4.upm.value <= 1'h1;
        end else begin
            if(field_combo.PIC_ICW4.upm.load_next) begin
                field_storage.PIC_ICW4.upm.value <= field_combo.PIC_ICW4.upm.next;
            end
        end
    end
    assign hwif_out.PIC_ICW4.upm.value = field_storage.PIC_ICW4.upm.value;
    // Field: pic_8259_regs.PIC_ICW4.aeoi
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW4.aeoi.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW4 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW4.aeoi.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW4.aeoi.next = next_c;
        field_combo.PIC_ICW4.aeoi.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW4.aeoi.value <= 1'h0;
        end else begin
            if(field_combo.PIC_ICW4.aeoi.load_next) begin
                field_storage.PIC_ICW4.aeoi.value <= field_combo.PIC_ICW4.aeoi.next;
            end
        end
    end
    assign hwif_out.PIC_ICW4.aeoi.value = field_storage.PIC_ICW4.aeoi.value;
    // Field: pic_8259_regs.PIC_ICW4.buf_mode
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW4.buf_mode.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW4 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW4.buf_mode.value & ~decoded_wr_biten[3:2]) | (decoded_wr_data[3:2] & decoded_wr_biten[3:2]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW4.buf_mode.next = next_c;
        field_combo.PIC_ICW4.buf_mode.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW4.buf_mode.value <= 2'h0;
        end else begin
            if(field_combo.PIC_ICW4.buf_mode.load_next) begin
                field_storage.PIC_ICW4.buf_mode.value <= field_combo.PIC_ICW4.buf_mode.next;
            end
        end
    end
    assign hwif_out.PIC_ICW4.buf_mode.value = field_storage.PIC_ICW4.buf_mode.value;
    // Field: pic_8259_regs.PIC_ICW4.sfnm
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_ICW4.sfnm.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_ICW4 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_ICW4.sfnm.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.PIC_ICW4.sfnm.next = next_c;
        field_combo.PIC_ICW4.sfnm.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_ICW4.sfnm.value <= 1'h0;
        end else begin
            if(field_combo.PIC_ICW4.sfnm.load_next) begin
                field_storage.PIC_ICW4.sfnm.value <= field_combo.PIC_ICW4.sfnm.next;
            end
        end
    end
    assign hwif_out.PIC_ICW4.sfnm.value = field_storage.PIC_ICW4.sfnm.value;
    // Field: pic_8259_regs.PIC_OCW1.imr
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_OCW1.imr.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_OCW1 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_OCW1.imr.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.PIC_OCW1.imr.next;
            load_next_c = '1;
        end
        field_combo.PIC_OCW1.imr.next = next_c;
        field_combo.PIC_OCW1.imr.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_OCW1.imr.value <= 8'hff;
        end else begin
            if(field_combo.PIC_OCW1.imr.load_next) begin
                field_storage.PIC_OCW1.imr.value <= field_combo.PIC_OCW1.imr.next;
            end
        end
    end
    assign hwif_out.PIC_OCW1.imr.value = field_storage.PIC_OCW1.imr.value;
    // Field: pic_8259_regs.PIC_OCW2.irq_level
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_OCW2.irq_level.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_OCW2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_OCW2.irq_level.value & ~decoded_wr_biten[2:0]) | (decoded_wr_data[2:0] & decoded_wr_biten[2:0]);
            load_next_c = '1;
        end
        field_combo.PIC_OCW2.irq_level.next = next_c;
        field_combo.PIC_OCW2.irq_level.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_OCW2.irq_level.value <= 3'h0;
        end else begin
            if(field_combo.PIC_OCW2.irq_level.load_next) begin
                field_storage.PIC_OCW2.irq_level.value <= field_combo.PIC_OCW2.irq_level.next;
            end
        end
    end
    assign hwif_out.PIC_OCW2.irq_level.value = field_storage.PIC_OCW2.irq_level.value;
    // Field: pic_8259_regs.PIC_OCW2.eoi_cmd
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_OCW2.eoi_cmd.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_OCW2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_OCW2.eoi_cmd.value & ~decoded_wr_biten[7:5]) | (decoded_wr_data[7:5] & decoded_wr_biten[7:5]);
            load_next_c = '1;
        end
        field_combo.PIC_OCW2.eoi_cmd.next = next_c;
        field_combo.PIC_OCW2.eoi_cmd.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_OCW2.eoi_cmd.value <= 3'h0;
        end else begin
            if(field_combo.PIC_OCW2.eoi_cmd.load_next) begin
                field_storage.PIC_OCW2.eoi_cmd.value <= field_combo.PIC_OCW2.eoi_cmd.next;
            end
        end
    end
    assign hwif_out.PIC_OCW2.eoi_cmd.value = field_storage.PIC_OCW2.eoi_cmd.value;
    // Field: pic_8259_regs.PIC_OCW3.read_reg_cmd
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_OCW3.read_reg_cmd.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_OCW3 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_OCW3.read_reg_cmd.value & ~decoded_wr_biten[1:0]) | (decoded_wr_data[1:0] & decoded_wr_biten[1:0]);
            load_next_c = '1;
        end
        field_combo.PIC_OCW3.read_reg_cmd.next = next_c;
        field_combo.PIC_OCW3.read_reg_cmd.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_OCW3.read_reg_cmd.value <= 2'h0;
        end else begin
            if(field_combo.PIC_OCW3.read_reg_cmd.load_next) begin
                field_storage.PIC_OCW3.read_reg_cmd.value <= field_combo.PIC_OCW3.read_reg_cmd.next;
            end
        end
    end
    assign hwif_out.PIC_OCW3.read_reg_cmd.value = field_storage.PIC_OCW3.read_reg_cmd.value;
    // Field: pic_8259_regs.PIC_OCW3.poll_cmd
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_OCW3.poll_cmd.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_OCW3 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_OCW3.poll_cmd.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.PIC_OCW3.poll_cmd.next = next_c;
        field_combo.PIC_OCW3.poll_cmd.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_OCW3.poll_cmd.value <= 1'h0;
        end else begin
            if(field_combo.PIC_OCW3.poll_cmd.load_next) begin
                field_storage.PIC_OCW3.poll_cmd.value <= field_combo.PIC_OCW3.poll_cmd.next;
            end
        end
    end
    assign hwif_out.PIC_OCW3.poll_cmd.value = field_storage.PIC_OCW3.poll_cmd.value;
    // Field: pic_8259_regs.PIC_OCW3.ocw3_marker
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_OCW3.ocw3_marker.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_OCW3 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_OCW3.ocw3_marker.value & ~decoded_wr_biten[4:3]) | (decoded_wr_data[4:3] & decoded_wr_biten[4:3]);
            load_next_c = '1;
        end
        field_combo.PIC_OCW3.ocw3_marker.next = next_c;
        field_combo.PIC_OCW3.ocw3_marker.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_OCW3.ocw3_marker.value <= 2'h1;
        end else begin
            if(field_combo.PIC_OCW3.ocw3_marker.load_next) begin
                field_storage.PIC_OCW3.ocw3_marker.value <= field_combo.PIC_OCW3.ocw3_marker.next;
            end
        end
    end
    assign hwif_out.PIC_OCW3.ocw3_marker.value = field_storage.PIC_OCW3.ocw3_marker.value;
    // Field: pic_8259_regs.PIC_OCW3.smm_cmd
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.PIC_OCW3.smm_cmd.value;
        load_next_c = '0;
        if(decoded_reg_strb.PIC_OCW3 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.PIC_OCW3.smm_cmd.value & ~decoded_wr_biten[6:5]) | (decoded_wr_data[6:5] & decoded_wr_biten[6:5]);
            load_next_c = '1;
        end
        field_combo.PIC_OCW3.smm_cmd.next = next_c;
        field_combo.PIC_OCW3.smm_cmd.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PIC_OCW3.smm_cmd.value <= 2'h0;
        end else begin
            if(field_combo.PIC_OCW3.smm_cmd.load_next) begin
                field_storage.PIC_OCW3.smm_cmd.value <= field_combo.PIC_OCW3.smm_cmd.next;
            end
        end
    end
    assign hwif_out.PIC_OCW3.smm_cmd.value = field_storage.PIC_OCW3.smm_cmd.value;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------

    logic readback_err;
    logic readback_done;
    logic [31:0] readback_data;

    // Assign readback values to a flattened array
    logic [31:0] readback_array[11];
    assign readback_array[0][0:0] = (decoded_reg_strb.PIC_CONFIG && !decoded_req_is_wr) ? field_storage.PIC_CONFIG.pic_enable.value : '0;
    assign readback_array[0][1:1] = (decoded_reg_strb.PIC_CONFIG && !decoded_req_is_wr) ? field_storage.PIC_CONFIG.init_mode.value : '0;
    assign readback_array[0][2:2] = (decoded_reg_strb.PIC_CONFIG && !decoded_req_is_wr) ? field_storage.PIC_CONFIG.auto_reset_init.value : '0;
    assign readback_array[0][31:3] = (decoded_reg_strb.PIC_CONFIG && !decoded_req_is_wr) ? 29'h0 : '0;
    assign readback_array[1][4:0] = '0;
    assign readback_array[1][31:5] = (decoded_reg_strb.PIC_ICW1 && !decoded_req_is_wr) ? 27'h0 : '0;
    assign readback_array[2][7:0] = '0;
    assign readback_array[2][31:8] = (decoded_reg_strb.PIC_ICW2 && !decoded_req_is_wr) ? 24'h0 : '0;
    assign readback_array[3][7:0] = '0;
    assign readback_array[3][31:8] = (decoded_reg_strb.PIC_ICW3 && !decoded_req_is_wr) ? 24'h0 : '0;
    assign readback_array[4][4:0] = '0;
    assign readback_array[4][31:5] = (decoded_reg_strb.PIC_ICW4 && !decoded_req_is_wr) ? 27'h0 : '0;
    assign readback_array[5][7:0] = (decoded_reg_strb.PIC_OCW1 && !decoded_req_is_wr) ? field_storage.PIC_OCW1.imr.value : '0;
    assign readback_array[5][31:8] = (decoded_reg_strb.PIC_OCW1 && !decoded_req_is_wr) ? 24'h0 : '0;
    assign readback_array[6][2:0] = '0;
    assign readback_array[6][4:3] = (decoded_reg_strb.PIC_OCW2 && !decoded_req_is_wr) ? 2'h0 : '0;
    assign readback_array[6][7:5] = '0;
    assign readback_array[6][31:8] = (decoded_reg_strb.PIC_OCW2 && !decoded_req_is_wr) ? 24'h0 : '0;
    assign readback_array[7][6:0] = '0;
    assign readback_array[7][31:7] = (decoded_reg_strb.PIC_OCW3 && !decoded_req_is_wr) ? 25'h0 : '0;
    assign readback_array[8][7:0] = (decoded_reg_strb.PIC_IRR && !decoded_req_is_wr) ? hwif_in.PIC_IRR.irr.next : '0;
    assign readback_array[8][31:8] = (decoded_reg_strb.PIC_IRR && !decoded_req_is_wr) ? 24'h0 : '0;
    assign readback_array[9][7:0] = (decoded_reg_strb.PIC_ISR && !decoded_req_is_wr) ? hwif_in.PIC_ISR.isr.next : '0;
    assign readback_array[9][31:8] = (decoded_reg_strb.PIC_ISR && !decoded_req_is_wr) ? 24'h0 : '0;
    assign readback_array[10][0:0] = (decoded_reg_strb.PIC_STATUS && !decoded_req_is_wr) ? hwif_in.PIC_STATUS.init_complete.next : '0;
    assign readback_array[10][3:1] = (decoded_reg_strb.PIC_STATUS && !decoded_req_is_wr) ? hwif_in.PIC_STATUS.icw_step.next : '0;
    assign readback_array[10][4:4] = (decoded_reg_strb.PIC_STATUS && !decoded_req_is_wr) ? hwif_in.PIC_STATUS.int_output.next : '0;
    assign readback_array[10][7:5] = (decoded_reg_strb.PIC_STATUS && !decoded_req_is_wr) ? hwif_in.PIC_STATUS.highest_priority.next : '0;
    assign readback_array[10][31:8] = (decoded_reg_strb.PIC_STATUS && !decoded_req_is_wr) ? 24'h0 : '0;

    // Reduce the array
    always_comb begin
        automatic logic [31:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<11; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign cpuif_rd_ack = readback_done;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
