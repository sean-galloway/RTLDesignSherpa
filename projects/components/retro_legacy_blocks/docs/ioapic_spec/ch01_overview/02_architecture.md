### APB IOAPIC - Architecture

#### High-Level Architecture

The APB IOAPIC is organized as a hierarchical design with three primary layers:

```
┌──────────────────────────────────────────────────────────────┐
│ apb_ioapic (Top Level)                                       │
│                                                               │
│  ┌────────────────────────┐                                 │
│  │ APB Slave Interface    │ (APB Clock Domain: pclk)        │
│  │ - apb_slave (CDC=0)    │                                 │
│  │ - apb_slave_cdc (CDC=1)│                                 │
│  └────────┬───────────────┘                                 │
│           │ CMD/RSP (with optional CDC)                       │
│           ▼                                                   │
│  ┌────────────────────────────────────────┐                 │
│  │ ioapic_config_regs                     │                 │
│  │ (Register if Clock Domain: pclk or ioapic_clk)           │
│  │                                         │                 │
│  │  ┌──────────────────┐  ┌──────────────┐│                 │
│  │  │peakrdl_to_cmdrsp │  │ ioapic_regs  ││                 │
│  │  │   Adapter        │→ │ (PeakRDL Gen)││                 │
│  │  └──────────────────┘  └──────┬───────┘│                 │
│  │                                │ hwif    │                 │
│  │        [Indirect Access Logic] │         │                 │
│  │        IOREGSEL/IOWIN ←────────┘         │                 │
│  └────────────────┬───────────────────────┘                 │
│                   │ Config/Status Signals                     │
│                   ▼                                           │
│  ┌────────────────────────────────────────┐                 │
│  │ ioapic_core                             │                 │
│  │ (Interrupt Logic: pclk or ioapic_clk)   │                 │
│  │                                          │                 │
│  │  • IRQ Input Sync (3-stage)             │                 │
│  │  • Polarity Handling                    │                 │
│  │  • Edge/Level Detection                 │                 │
│  │  • Priority Arbitration                 │                 │
│  │  • Delivery FSM                         │                 │
│  │  • Remote IRR Management                │                 │
│  └────────┬───────────────────────────────┘                 │
│           │                                                   │
│  External Interfaces:                                         │
│  ├─ irq_in[23:0] ──────────► 24 Interrupt Inputs            │
│  ├─ irq_out_valid ─────────► Interrupt Request to CPU       │
│  ├─ irq_out_vector[7:0] ───► Vector Number                  │
│  ├─ irq_out_dest[7:0] ─────► Destination APIC ID            │
│  └─ eoi_in ────────────────► End-of-Interrupt from CPU      │
└──────────────────────────────────────────────────────────────┘
```

#### Block Hierarchy

The design follows RLB architecture standards with clear functional separation:

1. **apb_ioapic.sv** (Top Level)
   - APB slave interface selection (CDC or non-CDC via parameter)
   - Clock domain routing based on CDC_ENABLE
   - Module instantiation and wiring
   - External interface connections

2. **ioapic_config_regs.sv** (Register Interface)
   - PeakRDL adapter instantiation (peakrdl_to_cmdrsp)
   - Generated register block instantiation (ioapic_regs)
   - Special logic for Intel indirect access (IOREGSEL/IOWIN)
   - Hardware interface signal mapping (hwif_in/hwif_out to core)
   - Redirection table array handling (24 entries)

3. **ioapic_core.sv** (Core Logic)
   - IRQ input synchronization (3-stage, metastability prevention)
   - Polarity inversion (active-high/active-low handling)
   - Edge detection (rising/falling edge with filtering)
   - Level sensing (continuous level tracking)
   - Priority arbitration (static: lowest IRQ wins)
   - Interrupt delivery state machine (IDLE → DELIVER → WAIT_EOI)
   - Remote IRR management (level interrupt state tracking)
   - Delivery status per IRQ

4. **ioapic_regs.sv** (Generated by PeakRDL)
   - Direct APB registers: IOREGSEL, IOWIN
   - Internal registers: IOAPICID, IOAPICVER, IOAPICARB
   - Redirection table: IOREDTBL[24] with LO/HI splits
   - Hardware interface structs (hwif_in, hwif_out)

#### Data Flow

**Configuration Path (APB Write):**
```
Software → APB Write → apb_slave[_cdc] → CMD → peakrdl_to_cmdrsp → 
→ ioapic_regs → hwif_out → ioapic_config_regs mapping → ioapic_core config
```

**Status Readback Path (APB Read):**
```
ioapic_core status → ioapic_config_regs mapping → hwif_in → ioapic_regs → 
→ peakrdl_to_cmdrsp → RSP → apb_slave[_cdc] → APB Read Data → Software
```

**Interrupt Delivery Path:**
```
IRQ Input → Sync → Polarity → Edge/Level Detect → Pending → Arbitration → 
→ Delivery FSM → irq_out_valid + vector + dest → CPU/LAPIC
```

**EOI Return Path (Level Interrupts):**
```
CPU EOI → eoi_in + eoi_vector → ioapic_core → Clear Remote IRR → 
→ Re-enable interrupt if still asserted
```

#### Intel Indirect Access Method

The IOAPIC uses Intel's two-step indirect register access:

**Step 1: Select Internal Register**
```
Write to IOREGSEL (APB address 0x00):
  Data = Internal register offset (0x00-0x3F)
```

**Step 2: Access Selected Register**
```
Read/Write IOWIN (APB address 0x04):
  Data = Selected register contents
```

**Example: Configure IRQ0 Redirection Entry**
```c
// Step 1: Select IOREDTBL[0]_LO (internal offset 0x10)
*IOREGSEL = 0x10;

// Step 2: Write configuration via IOWIN
*IOWIN = 0x00000020;  // Vector 0x20, edge-triggered, unmasked

// Step 3: Select IOREDTBL[0]_HI (internal offset 0x11)
*IOREGSEL = 0x11;

// Step 4: Write destination via IOWIN
*IOWIN = 0x01000000;  // Destination APIC ID = 1
```

This indirect access method:
- Reduces address space (only 2 APB registers instead of 50+)
- Matches Intel specification for software compatibility
- Allows 256 internal registers with 8-bit offset
- PeakRDL generated logic handles routing automatically

#### Clock Domain Architecture

The IOAPIC supports two clock domain configurations via CDC_ENABLE parameter:

**Single Clock Domain (CDC_ENABLE=0 - Default):**
```
pclk ────┬──► apb_slave ───► ioapic_config_regs ───► ioapic_core
         └──► Register domain
         └──► Core logic domain
```
- Simplest configuration
- Lowest latency
- Single clock timing analysis
- Recommended for most use cases

**Dual Clock Domain (CDC_ENABLE=1):**
```
pclk ────► apb_slave_cdc ───┐
                             │ CDC Handshake
ioapic_clk ──────────────┬──┴──► ioapic_config_regs ───► ioapic_core
                         └──────► Register domain
                         └──────► Core logic domain
```
- Allows independent APB and IOAPIC clocks
- Useful for always-on interrupt handling
- ioapic_clk can run while pclk is gated
- Adds 2-4 cycle latency for CDC handshake

**Clock Selection Logic:**
```systemverilog
// In apb_ioapic.sv:
.clk (CDC_ENABLE[0] ? ioapic_clk : pclk)
```

Both config_regs and core use the same clock (no internal CDC needed).

#### Reset Architecture

The IOAPIC uses standard RLB reset methodology:

**Reset Signals:**
- `presetn` - APB domain reset (active-low, async)
- `ioapic_resetn` - IOAPIC domain reset (active-low, async)

**Reset Routing:**
```systemverilog
// In apb_ioapic.sv:
.rst_n (CDC_ENABLE[0] ? ioapic_resetn : presetn)
```

**Reset Behavior:**
- All IRQs masked by default (mask bit = 1)
- No interrupts pending
- Delivery state = IDLE
- Remote IRR cleared for all IRQs
- IOAPIC ID = 0x0
- All redirection entries reset to safe defaults

#### Interrupt Flow State Machine

The IOAPIC core implements a simple 3-state FSM for interrupt delivery:

```
        ┌─────────────┐
        │    IDLE     │◄──────────────────┐
        └──────┬──────┘                   │
               │ IRQ pending & unmasked   │
               ▼                           │
        ┌─────────────┐                   │
        │   DELIVER   │                   │
        └──────┬──────┘                   │
               │ irq_out_ready            │
               ▼                           │
        ┌─────────────┐                   │
        │  WAIT_EOI   │ (Level mode only) │
        │             │                   │
        └──────┬──────┘                   │
               │ EOI received             │
               └──────────────────────────┘
```

**States:**
- **IDLE**: Arbitrating among pending IRQs, select highest priority
- **DELIVER**: Presenting interrupt to CPU (irq_out_valid asserted)
- **WAIT_EOI**: Waiting for End-of-Interrupt (level-triggered only)

**Edge-triggered path:** IDLE → DELIVER → IDLE (no EOI wait)  
**Level-triggered path:** IDLE → DELIVER → WAIT_EOI → IDLE

#### Integration Guidelines

**Minimal Integration (Single CPU):**
```systemverilog
apb_ioapic #(
    .NUM_IRQS    (24),
    .CDC_ENABLE  (0)   // Single clock domain
) u_ioapic (
    .pclk              (sys_clk),
    .presetn           (sys_resetn),
    .ioapic_clk        (sys_clk),      // Same clock
    .ioapic_resetn     (sys_resetn),   // Same reset
    
    .s_apb_*           (/* APB signals */),
    .irq_in            (system_irqs),
    .irq_out_valid     (cpu_irq_valid),
    .irq_out_vector    (cpu_irq_vector),
    .irq_out_dest      (/* tie to CPU ID */),
    .irq_out_deliv_mode(/* unused in simple system */),
    .irq_out_ready     (cpu_irq_ack),
    .eoi_in            (cpu_eoi),
    .eoi_vector        (cpu_eoi_vector)
);
```

**Advanced Integration (Multi-CPU with CDC):**
```systemverilog
apb_ioapic #(
    .NUM_IRQS    (24),
    .CDC_ENABLE  (1)   // Dual clock domain
) u_ioapic (
    .pclk              (apb_clk),        // APB bus clock
    .presetn           (apb_resetn),
    .ioapic_clk        (always_on_clk),  // Independent clock
    .ioapic_resetn     (por_resetn),
    
    .s_apb_*           (/* APB signals */),
    .irq_in            (system_irqs),
    .irq_out_*         (/* to LAPIC router */),
    .eoi_in            (eoi_from_lapic),
    .eoi_vector        (eoi_vector_from_lapic)
);
```

#### Address Space Organization

**APB Address Space (12-bit: 0x000-0xFFF):**
- 0x000: IOREGSEL (direct access)
- 0x004: IOWIN (direct access)
- 0x008-0xFFF: Reserved

**Internal Register Space (8-bit offset via IOREGSEL):**
- 0x00: IOAPICID
- 0x01: IOAPICVER
- 0x02: IOAPICARB
- 0x03-0x0F: Reserved
- 0x10-0x3F: IOREDTBL[0-23] (LO/HI pairs)

**Memory Footprint:** 4KB APB window (matches other RLB modules)

#### Design Trade-offs

**Indirect vs Direct Access:**
- **Chosen**: Indirect access (IOREGSEL/IOWIN)
- **Reason**: Intel 82093AA compatibility, reduced address space
- **Cost**: Extra APB cycle per access, more complex logic
- **Benefit**: Software portability, scalable register space

**Static vs Dynamic Priority:**
- **Chosen**: Static priority (lowest IRQ wins)
- **Reason**: Simplicity, deterministic behavior, sufficient for MVP
- **Cost**: Less flexible than round-robin
- **Benefit**: Predictable, easy to verify, low logic

**Fixed vs Multiple Delivery Modes:**
- **Chosen**: Fixed mode only for MVP
- **Reason**: Covers 90%+ of use cases, simpler implementation
- **Cost**: Can't use LowestPri, SMI, NMI, etc. yet
- **Benefit**: Clean implementation, extensible design

---

**Next:** [Chapter 1.3 - Clocks and Reset](03_clocks_and_reset.md)
