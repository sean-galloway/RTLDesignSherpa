// CPU_RD Master Adapter Module
// Generated by: AdapterGenerator
// Handles timing isolation, address decode, and width conversion for cpu_rd master

`timescale 1ns / 1ps

import bridge_1x5_rd_pkg::*;

module cpu_rd_adapter #(
    parameter NUM_SLAVES = 5,
    parameter SKID_DEPTH_AR = 2,
    parameter SKID_DEPTH_R = 2
) (
    input  logic aclk,
    input  logic aresetn,

    // External AXI interface (from cpu_rd master)
    input  logic [3:0]  cpu_rd_axi_arid,
    input  logic [31:0]  cpu_rd_axi_araddr,
    input  logic [7:0]  cpu_rd_axi_arlen,
    input  logic [2:0]  cpu_rd_axi_arsize,
    input  logic [1:0]  cpu_rd_axi_arburst,
    input  logic         cpu_rd_axi_arlock,
    input  logic [3:0]  cpu_rd_axi_arcache,
    input  logic [2:0]  cpu_rd_axi_arprot,
    input  logic [3:0]  cpu_rd_axi_arqos,
    input  logic [3:0]  cpu_rd_axi_arregion,
    input  logic         cpu_rd_axi_aruser,
    input  logic         cpu_rd_axi_arvalid,
    output  logic         cpu_rd_axi_arready,

    output  logic [3:0]  cpu_rd_axi_rid,
    output  logic [63:0]  cpu_rd_axi_rdata,
    output  logic [1:0]  cpu_rd_axi_rresp,
    output  logic         cpu_rd_axi_rlast,
    output  logic         cpu_rd_axi_ruser,
    output  logic         cpu_rd_axi_rvalid,
    input  logic         cpu_rd_axi_rready,

    // Address decode outputs (full width one-hot)
    output logic [NUM_SLAVES-1:0] slave_select_ar,

    // 64b width outputs (to crossbar)
    output axi4_ar_t     cpu_rd_32b_ar,
    output logic         cpu_rd_32b_arvalid,
    input  logic         cpu_rd_32b_arready,

    input  axi4_r_32b_t  cpu_rd_32b_r,
    input  logic         cpu_rd_32b_rvalid,
    output logic         cpu_rd_32b_rready,

    output axi4_ar_t     cpu_rd_64b_ar,
    output logic         cpu_rd_64b_arvalid,
    input  logic         cpu_rd_64b_arready,

    input  axi4_r_64b_t  cpu_rd_64b_r,
    input  logic         cpu_rd_64b_rvalid,
    output logic         cpu_rd_64b_rready,

    output axi4_ar_t     cpu_rd_128b_ar,
    output logic         cpu_rd_128b_arvalid,
    input  logic         cpu_rd_128b_arready,

    input  axi4_r_128b_t  cpu_rd_128b_r,
    input  logic         cpu_rd_128b_rvalid,
    output logic         cpu_rd_128b_rready
);

    // ================================================================
    // Localparams
    // ================================================================
    localparam ADDR_WIDTH = 32;
    localparam DATA_WIDTH = 64;
    localparam ID_WIDTH = 4;

    // ================================================================
    // Internal signals after wrapper (timing isolation)
    // Note: ID width matches external (4-bit)
    // ================================================================
    logic [3:0]   fub_axi_arid;
    logic [31:0]  fub_axi_araddr;
    logic [7:0]   fub_axi_arlen;
    logic [2:0]   fub_axi_arsize;
    logic [1:0]   fub_axi_arburst;
    logic         fub_axi_arlock;
    logic [3:0]   fub_axi_arcache;
    logic [2:0]   fub_axi_arprot;
    logic         fub_axi_arvalid;
    logic         fub_axi_arready;

    logic [3:0]   fub_axi_rid;
    logic [63:0]  fub_axi_rdata;
    logic [1:0]   fub_axi_rresp;
    logic         fub_axi_rlast;
    logic         fub_axi_rvalid;
    logic         fub_axi_rready;

    logic         wrapper_rd_busy;

    // ================================================================
    // Timing isolation wrapper (axi4_slave_rd)
    // ================================================================
    axi4_slave_rd #(
        .SKID_DEPTH_AR(SKID_DEPTH_AR),
        .SKID_DEPTH_R(SKID_DEPTH_R),
        .AXI_ID_WIDTH(4),
        .AXI_ADDR_WIDTH(32),
        .AXI_DATA_WIDTH(64),
        .AXI_USER_WIDTH(1)
    ) u_timing_wrapper_rd (
        .aclk(aclk),
        .aresetn(aresetn),

        // External boundary (slave side - accepts from master)
        .s_axi_arid(cpu_rd_axi_arid),
        .s_axi_araddr(cpu_rd_axi_araddr),
        .s_axi_arlen(cpu_rd_axi_arlen),
        .s_axi_arsize(cpu_rd_axi_arsize),
        .s_axi_arburst(cpu_rd_axi_arburst),
        .s_axi_arlock(cpu_rd_axi_arlock),
        .s_axi_arcache(cpu_rd_axi_arcache),
        .s_axi_arprot(cpu_rd_axi_arprot),
        .s_axi_arqos(cpu_rd_axi_arqos),
        .s_axi_arregion(cpu_rd_axi_arregion),
        .s_axi_aruser(cpu_rd_axi_aruser),
        .s_axi_arvalid(cpu_rd_axi_arvalid),
        .s_axi_arready(cpu_rd_axi_arready),

        .s_axi_rid(cpu_rd_axi_rid),
        .s_axi_rdata(cpu_rd_axi_rdata),
        .s_axi_rresp(cpu_rd_axi_rresp),
        .s_axi_rlast(cpu_rd_axi_rlast),
        .s_axi_ruser(cpu_rd_axi_ruser),
        .s_axi_rvalid(cpu_rd_axi_rvalid),
        .s_axi_rready(cpu_rd_axi_rready),

        // Internal crossbar (master side - outputs to converter)
        .fub_axi_arid(fub_axi_arid),
        .fub_axi_araddr(fub_axi_araddr),
        .fub_axi_arlen(fub_axi_arlen),
        .fub_axi_arsize(fub_axi_arsize),
        .fub_axi_arburst(fub_axi_arburst),
        .fub_axi_arlock(fub_axi_arlock),
        .fub_axi_arcache(fub_axi_arcache),
        .fub_axi_arprot(fub_axi_arprot),
        .fub_axi_arqos(),
        .fub_axi_arregion(),
        .fub_axi_aruser(),
        .fub_axi_arvalid(fub_axi_arvalid),
        .fub_axi_arready(fub_axi_arready),

        .fub_axi_rid(fub_axi_rid),
        .fub_axi_rdata(fub_axi_rdata),
        .fub_axi_rresp(fub_axi_rresp),
        .fub_axi_rlast(fub_axi_rlast),
        .fub_axi_ruser(1'b0),
        .fub_axi_rvalid(fub_axi_rvalid),
        .fub_axi_rready(fub_axi_rready),

        .busy(wrapper_rd_busy)
    );

    // ================================================================
    // Address decode (slave selection) - Read
    // Slave 0 (periph_rd): 0x00000000 - 0x0FFFFFFF
    // Slave 1 (ddr_rd): 0x10000000 - 0x4FFFFFFF
    // Slave 2 (hbm_rd): 0x50000000 - 0x7FFFFFFF
    // Slave 3 (apb_periph): 0x80000000 - 0x8000FFFF
    // Slave 4 (axil_periph): 0x90000000 - 0x9000FFFF
    // ================================================================
    always_comb begin
        slave_select_ar = '0;
        if (fub_axi_araddr <= 32'h0FFFFFFF) begin
            slave_select_ar[0] = 1'b1;  // periph_rd
        end
        else if (fub_axi_araddr >= 32'h10000000 && fub_axi_araddr <= 32'h4FFFFFFF) begin
            slave_select_ar[1] = 1'b1;  // ddr_rd
        end
        else if (fub_axi_araddr >= 32'h50000000 && fub_axi_araddr <= 32'h7FFFFFFF) begin
            slave_select_ar[2] = 1'b1;  // hbm_rd
        end
        else if (fub_axi_araddr >= 32'h80000000 && fub_axi_araddr <= 32'h8000FFFF) begin
            slave_select_ar[3] = 1'b1;  // apb_periph
        end
        else if (fub_axi_araddr >= 32'h90000000 && fub_axi_araddr <= 32'h9000FFFF) begin
            slave_select_ar[4] = 1'b1;  // axil_periph
        end
    end

    // ================================================================
    // Width adaptation - Master: 64b
    // Connected to slaves with widths: [32, 64, 128]
    // ================================================================

    // ================================================================
    // Width converter: 64b → 32b
    // ================================================================

    // Intermediate signals for 32b converter
    logic conv_32b_arready;
    logic [3:0] conv_32b_rid;
    logic [63:0] conv_32b_rdata;
    logic [1:0] conv_32b_rresp;
    logic conv_32b_rlast;
    logic conv_32b_rvalid;

    axi4_dwidth_converter_rd #(
        .S_AXI_DATA_WIDTH(64),
        .M_AXI_DATA_WIDTH(32),
        .AXI_ID_WIDTH(4),
        .AXI_ADDR_WIDTH(32),
        .AXI_USER_WIDTH(1),
        .SKID_DEPTH_AR(2),
        .SKID_DEPTH_R(4)
    ) u_rd_conv_32b (
        .aclk(aclk),
        .aresetn(aresetn),

        // Slave side (from wrapper) - BROADCAST requests
        .s_axi_arid(fub_axi_arid),
        .s_axi_araddr(fub_axi_araddr),
        .s_axi_arlen(fub_axi_arlen),
        .s_axi_arsize(fub_axi_arsize),
        .s_axi_arburst(fub_axi_arburst),
        .s_axi_arlock(fub_axi_arlock),
        .s_axi_arcache(fub_axi_arcache),
        .s_axi_arprot(fub_axi_arprot),
        .s_axi_arqos(4'b0),
        .s_axi_arregion(4'b0),
        .s_axi_aruser(1'b0),
        .s_axi_arvalid(fub_axi_arvalid),
        .s_axi_arready(conv_32b_arready),  // Intermediate signal

        .s_axi_rid(conv_32b_rid),  // Intermediate signal
        .s_axi_rdata(conv_32b_rdata),  // Intermediate signal
        .s_axi_rresp(conv_32b_rresp),  // Intermediate signal
        .s_axi_rlast(conv_32b_rlast),  // Intermediate signal
        .s_axi_ruser(),
        .s_axi_rvalid(conv_32b_rvalid),  // Intermediate signal
        .s_axi_rready(fub_axi_rready),

        // Master side (to crossbar)
        .m_axi_arid(cpu_rd_32b_ar.id),
        .m_axi_araddr(cpu_rd_32b_ar.addr),
        .m_axi_arlen(cpu_rd_32b_ar.len),
        .m_axi_arsize(cpu_rd_32b_ar.size),
        .m_axi_arburst(cpu_rd_32b_ar.burst),
        .m_axi_arlock(cpu_rd_32b_ar.lock),
        .m_axi_arcache(cpu_rd_32b_ar.cache),
        .m_axi_arprot(cpu_rd_32b_ar.prot),
        .m_axi_arqos(cpu_rd_32b_ar.qos),      // Tie to 0 in packet
        .m_axi_arregion(cpu_rd_32b_ar.region), // Tie to 0 in packet
        .m_axi_aruser(cpu_rd_32b_ar.user),     // Tie to 0 in packet
        .m_axi_arvalid(cpu_rd_32b_arvalid),
        .m_axi_arready(cpu_rd_32b_arready),

        .m_axi_rid(cpu_rd_32b_r.id),
        .m_axi_rdata(cpu_rd_32b_r.data),
        .m_axi_rresp(cpu_rd_32b_r.resp),
        .m_axi_rlast(cpu_rd_32b_r.last),
        .m_axi_ruser(cpu_rd_32b_r.user),       // From packet (ignored)
        .m_axi_rvalid(cpu_rd_32b_rvalid),
        .m_axi_rready(cpu_rd_32b_rready)
    );

    // ================================================================
    // Direct passthrough: 64b → 64b (no converter)
    // Requests: fub_axi_* → cpu_rd_64b_*
    // Responses: cpu_rd_64b_* → MUX → fub_axi_*
    // ================================================================

    // AR channel (request: fub → output)
    assign cpu_rd_64b_ar.id     = fub_axi_arid;
    assign cpu_rd_64b_ar.addr   = fub_axi_araddr;
    assign cpu_rd_64b_ar.len    = fub_axi_arlen;
    assign cpu_rd_64b_ar.size   = fub_axi_arsize;
    assign cpu_rd_64b_ar.burst  = fub_axi_arburst;
    assign cpu_rd_64b_ar.lock   = fub_axi_arlock;
    assign cpu_rd_64b_ar.cache  = fub_axi_arcache;
    assign cpu_rd_64b_ar.prot   = fub_axi_arprot;
    assign cpu_rd_64b_ar.qos    = 4'b0;  // Tie to 0
    assign cpu_rd_64b_ar.region = 4'b0;  // Tie to 0
    assign cpu_rd_64b_ar.user   = 1'b0;  // Tie to 0
    assign cpu_rd_64b_arvalid   = fub_axi_arvalid;
    // arready routed via MUX

    // R channel (response: output → MUX → fub)
    assign cpu_rd_64b_rready = fub_axi_rready;
    // rid, rdata, rresp, rlast, rvalid routed via MUX (user field ignored)

    // ================================================================
    // Width converter: 64b → 128b
    // ================================================================

    // Intermediate signals for 128b converter
    logic conv_128b_arready;
    logic [3:0] conv_128b_rid;
    logic [63:0] conv_128b_rdata;
    logic [1:0] conv_128b_rresp;
    logic conv_128b_rlast;
    logic conv_128b_rvalid;

    axi4_dwidth_converter_rd #(
        .S_AXI_DATA_WIDTH(64),
        .M_AXI_DATA_WIDTH(128),
        .AXI_ID_WIDTH(4),
        .AXI_ADDR_WIDTH(32),
        .AXI_USER_WIDTH(1),
        .SKID_DEPTH_AR(2),
        .SKID_DEPTH_R(4)
    ) u_rd_conv_128b (
        .aclk(aclk),
        .aresetn(aresetn),

        // Slave side (from wrapper) - BROADCAST requests
        .s_axi_arid(fub_axi_arid),
        .s_axi_araddr(fub_axi_araddr),
        .s_axi_arlen(fub_axi_arlen),
        .s_axi_arsize(fub_axi_arsize),
        .s_axi_arburst(fub_axi_arburst),
        .s_axi_arlock(fub_axi_arlock),
        .s_axi_arcache(fub_axi_arcache),
        .s_axi_arprot(fub_axi_arprot),
        .s_axi_arqos(4'b0),
        .s_axi_arregion(4'b0),
        .s_axi_aruser(1'b0),
        .s_axi_arvalid(fub_axi_arvalid),
        .s_axi_arready(conv_128b_arready),  // Intermediate signal

        .s_axi_rid(conv_128b_rid),  // Intermediate signal
        .s_axi_rdata(conv_128b_rdata),  // Intermediate signal
        .s_axi_rresp(conv_128b_rresp),  // Intermediate signal
        .s_axi_rlast(conv_128b_rlast),  // Intermediate signal
        .s_axi_ruser(),
        .s_axi_rvalid(conv_128b_rvalid),  // Intermediate signal
        .s_axi_rready(fub_axi_rready),

        // Master side (to crossbar)
        .m_axi_arid(cpu_rd_128b_ar.id),
        .m_axi_araddr(cpu_rd_128b_ar.addr),
        .m_axi_arlen(cpu_rd_128b_ar.len),
        .m_axi_arsize(cpu_rd_128b_ar.size),
        .m_axi_arburst(cpu_rd_128b_ar.burst),
        .m_axi_arlock(cpu_rd_128b_ar.lock),
        .m_axi_arcache(cpu_rd_128b_ar.cache),
        .m_axi_arprot(cpu_rd_128b_ar.prot),
        .m_axi_arqos(cpu_rd_128b_ar.qos),      // Tie to 0 in packet
        .m_axi_arregion(cpu_rd_128b_ar.region), // Tie to 0 in packet
        .m_axi_aruser(cpu_rd_128b_ar.user),     // Tie to 0 in packet
        .m_axi_arvalid(cpu_rd_128b_arvalid),
        .m_axi_arready(cpu_rd_128b_arready),

        .m_axi_rid(cpu_rd_128b_r.id),
        .m_axi_rdata(cpu_rd_128b_r.data),
        .m_axi_rresp(cpu_rd_128b_r.resp),
        .m_axi_rlast(cpu_rd_128b_r.last),
        .m_axi_ruser(cpu_rd_128b_r.user),       // From packet (ignored)
        .m_axi_rvalid(cpu_rd_128b_rvalid),
        .m_axi_rready(cpu_rd_128b_rready)
    );

    // ================================================================
    // Response MUX - Route responses from width-specific paths
    // back to fub_axi_* based on address decode
    // ================================================================

    // Read response MUX (R channel)
    always_comb begin
        fub_axi_arready = 1'b0;
        fub_axi_rid = 4'd0;
        fub_axi_rdata = 64'd0;
        fub_axi_rresp = 2'b00;
        fub_axi_rlast = 1'b0;
        fub_axi_rvalid = 1'b0;

        case (slave_select_ar)
            5'b00001: begin  // Slave 0 (32b)
                fub_axi_arready = conv_32b_arready;
                fub_axi_rid = conv_32b_rid;
                fub_axi_rdata = conv_32b_rdata;
                fub_axi_rresp = conv_32b_rresp;
                fub_axi_rlast = conv_32b_rlast;
                fub_axi_rvalid = conv_32b_rvalid;
            end
            5'b10000: begin  // Slave 4 (32b)
                fub_axi_arready = conv_32b_arready;
                fub_axi_rid = conv_32b_rid;
                fub_axi_rdata = conv_32b_rdata;
                fub_axi_rresp = conv_32b_rresp;
                fub_axi_rlast = conv_32b_rlast;
                fub_axi_rvalid = conv_32b_rvalid;
            end
            5'b00010: begin  // Slave 1 (64b)
                fub_axi_arready = cpu_rd_64b_arready;
                fub_axi_rid = cpu_rd_64b_r.id;
                fub_axi_rdata = cpu_rd_64b_r.data;
                fub_axi_rresp = cpu_rd_64b_r.resp;
                fub_axi_rlast = cpu_rd_64b_r.last;
                fub_axi_rvalid = cpu_rd_64b_rvalid;
            end
            5'b01000: begin  // Slave 3 (64b)
                fub_axi_arready = cpu_rd_64b_arready;
                fub_axi_rid = cpu_rd_64b_r.id;
                fub_axi_rdata = cpu_rd_64b_r.data;
                fub_axi_rresp = cpu_rd_64b_r.resp;
                fub_axi_rlast = cpu_rd_64b_r.last;
                fub_axi_rvalid = cpu_rd_64b_rvalid;
            end
            5'b00100: begin  // Slave 2 (128b)
                fub_axi_arready = conv_128b_arready;
                fub_axi_rid = conv_128b_rid;
                fub_axi_rdata = conv_128b_rdata;
                fub_axi_rresp = conv_128b_rresp;
                fub_axi_rlast = conv_128b_rlast;
                fub_axi_rvalid = conv_128b_rvalid;
            end
            default: begin
                // No slave selected - hold defaults
            end
        endcase
    end

endmodule : cpu_rd_adapter
