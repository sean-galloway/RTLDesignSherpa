<!-- RTL Design Sherpa Documentation Header -->
<table>
<tr>
<td width="80">
  <a href="https://github.com/sean-galloway/RTLDesignSherpa">
    <img src="https://raw.githubusercontent.com/sean-galloway/RTLDesignSherpa/main/docs/logos/Logo_200px.png" alt="RTL Design Sherpa" width="70">
  </a>
</td>
<td>
  <strong>RTL Design Sherpa</strong> · <em>Learning Hardware Design Through Practice</em><br>
  <sub>
    <a href="https://github.com/sean-galloway/RTLDesignSherpa">GitHub</a> ·
    <a href="https://github.com/sean-galloway/RTLDesignSherpa/blob/main/docs/DOCUMENTATION_INDEX.md">Documentation Index</a> ·
    <a href="https://github.com/sean-galloway/RTLDesignSherpa/blob/main/LICENSE">MIT License</a>
  </sub>
</td>
</tr>
</table>

---

<!-- End Header -->

# Bridge Generator Architecture

**Date:** 2025-11-06
**Status:** Documentation created after generator modifications broke compilation
**Purpose:** Explain build system and generator architecture for debugging/restoration

---

## Table of Contents

1. [Build Flow Overview](#build-flow-overview)
2. [Makefile Targets](#makefile-targets)
3. [Generator Entry Point](#generator-entry-point)
4. [Component Generators](#component-generators)
5. [Signal Naming System](#signal-naming-system)
6. [YAML Configuration Format](#yaml-configuration-format)
7. [Architecture Diagrams](#architecture-diagrams)
8. [Current Broken State](#current-broken-state)

---

## Build Flow Overview

### High-Level Flow

```
User runs: make rebuild-all
    ↓
Makefile deletes rtl/generated/bridge_*
    ↓
Makefile calls: $(PYTHON) $(SCRIPT_DIR)/bridge_generator.py --bulk bridge_batch.csv --generate-tests
    ↓
bridge_generator.py reads bridge_batch.csv (lists YAML configs)
    ↓
For each YAML config:
    ├─ Parse YAML (masters, slaves, connectivity)
    ├─ Generate Package File (bridge_pkg.sv)
    ├─ Generate Adapter Modules (one per master)
    ├─ Generate Crossbar Module
    ├─ Generate Bridge Top-Level Module
    └─ Write all files to rtl/generated/bridge_{name}/
    ↓
Regeneration complete → Tests can run
```

### Key Files in Flow

| File | Role | Location |
|------|------|----------|
| `Makefile` | Orchestrates build | `dv/tests/Makefile` |
| `bridge_batch.csv` | Lists YAML configs | `bin/bridge_batch.csv` |
| `bridge_generator.py` | Main entry point | `bin/bridge_generator.py` |
| `*.yaml` | Bridge configs | `bin/test_configs/*.yaml` |
| Generated RTL | Output | `rtl/generated/bridge_*/` |

---

## Makefile Targets

### Location: `projects/components/bridge/dv/tests/Makefile`

### Key Targets

#### `clean-all` (Line 252)
```makefile
clean-all:
	@echo "Cleaning all test artifacts..."
	rm -rf $(TEST_OUTPUT_DIR)
	rm -rf __pycache__
	rm -rf .pytest_cache
	find . -name "*.pyc" -delete
	@echo "Clean complete"
```

**Purpose:** Remove all test artifacts, but does NOT delete generated RTL.

#### `rebuild-all` (Line 460)
```makefile
rebuild-all: clean-all
	@echo "CRITICAL RULE #0: Deleting ALL generated RTL before regeneration"
	rm -rf $(BRIDGE_RTL_DIR)/bridge_*
	@echo "Regenerating all bridges..."
	@$(MAKE) test
	@echo "Regeneration complete"
```

**Purpose:**
1. Clean test artifacts
2. **Delete all generated RTL** (`rtl/generated/bridge_*`)
3. Call `test` target to regenerate everything

**CRITICAL:** This enforces "CRITICAL RULE #0" - always delete ALL generated RTL before regenerating.

#### `test` (Lines 379-398)
```makefile
test: check-sim check-python setup-test-dirs
	@echo "=================================================="
	@echo "Running Bridge Generator (--bulk mode)"
	@echo "=================================================="
	@$(PYTHON) $(SCRIPT_DIR)/bridge_generator.py \
		--bulk $(BULK_BATCH_FILE) \
		--generate-tests \
		--verbose
	@echo ""
	@echo "=================================================="
	@echo "Bridge generation complete"
	@echo "=================================================="
```

**Purpose:**
1. Check environment (simulator, Python)
2. Create test directories
3. **Run bridge_generator.py in bulk mode**
4. Generate test files

**Key Variables:**
- `SCRIPT_DIR = ../../bin` - Generator scripts location
- `BULK_BATCH_FILE = $(SCRIPT_DIR)/bridge_batch.csv` - List of YAML configs

---

## Generator Entry Point

### Location: `projects/components/bridge/bin/bridge_generator.py`

### Main Function: `generate_bridge()`

```python
def generate_bridge(
    ports_file: str,           # YAML config path
    connectivity_file: str = None,  # Optional separate connectivity file
    name: str = None,          # Auto-generated if None
    output_dir: str = None     # rtl/generated by default
) -> Tuple[bool, str]:
    """
    Main entry point for bridge generation.

    Returns:
        (success: bool, bridge_name: str)
    """
```

### Generation Steps (from `generate_bridge()`)

1. **Parse Configuration** (`parse_yaml_config()`)
   - Read YAML file
   - Extract masters, slaves, connectivity
   - Validate configuration

2. **Create Output Directory**
   - `rtl/generated/bridge_{name}/`

3. **Generate Package File** (`PackageGenerator.generate()`)
   - Create `bridge_{name}_pkg.sv`
   - Define channel types (AXI4Channel_AR, AXI4Channel_R, etc.)
   - Define data structures (axi4_ar_t, axi4_r_64b_t, etc.)

4. **Generate Adapters** (For each master)
   - `AdapterGenerator.generate()`
   - One adapter per master
   - Handles:
     - Width conversion (master width → 64-bit internal path)
     - Address decoding (which slave to route to)
     - Timing isolation (axi4_slave_wr/rd wrappers)

5. **Generate Crossbar** (`CrossbarGenerator.generate()`)
   - Create `bridge_{name}_xbar.sv`
   - Route adapter outputs to slave ports
   - Handle arbitration if multiple masters target same slave

6. **Generate Bridge Top-Level** (`BridgeModuleGenerator.generate()`)
   - Create `bridge_{name}.sv`
   - Instantiate all adapters
   - Instantiate crossbar
   - Connect external ports to adapters
   - Connect crossbar outputs to external slave ports

### Bulk Mode

When called with `--bulk bridge_batch.csv`:

```python
for yaml_file in batch_csv:
    success, name = generate_bridge(
        ports_file=yaml_file,
        connectivity_file=None,  # Auto-detect
        name=None,               # Auto-generate
        output_dir="rtl/generated"
    )
```

---

## Component Generators

### 1. Package Generator

**Location:** `bin/bridge_pkg/generators/package_generator.py`

**Purpose:** Generate SystemVerilog package with types and structures.

**Generated Content:**
```systemverilog
package bridge_{name}_pkg;
    // Channel types
    typedef struct packed {
        logic [3:0]  arid;
        logic [31:0] araddr;
        // ... AR channel fields
    } axi4_ar_t;

    typedef struct packed {
        logic [3:0]  rid;
        logic [63:0] rdata;  // Always 64-bit internal
        // ... R channel fields
    } axi4_r_64b_t;

    // Similar for AW, W, B channels
endpackage
```

**Key Point:** Internal data path is always 64 bits, regardless of master/slave widths.

---

### 2. Adapter Generator

**Location:** `bin/bridge_pkg/generators/adapter_generator.py`

**Purpose:** Generate one adapter module per master.

**Architecture:**
```
Master (external) → Timing Wrapper → Address Decoder → Width Converter → 64-bit internal
                    (axi4_slave_*)    (decode logic)    (dwidth converter)
```

**Generated Module Example:**
```systemverilog
module cpu_master_adapter (
    input  logic aclk,
    input  logic aresetn,

    // External interface (master's native width)
    input  logic [3:0]   cpu_m_axi_arid,    // ← Uses master.prefix
    input  logic [31:0]  cpu_m_axi_araddr,
    // ... (32-bit data width in this example)

    // Decode outputs
    output logic [NUM_SLAVES-1:0] slave_select_ar,
    output logic [NUM_SLAVES-1:0] slave_select_aw,

    // 64b internal path
    output axi4_ar_t     cpu_master_64b_ar,     // ← Uses master.name
    output logic         cpu_master_64b_arvalid,
    input  logic         cpu_master_64b_arready,
    input  axi4_r_64b_t  cpu_master_64b_r,      // ← 64-bit data
    // ...
);
```

**Key Functions:**

1. **Timing Isolation:** Uses `axi4_slave_wr`/`axi4_slave_rd` wrappers
2. **Address Decode:** Generates `slave_select_ar[i]` signals
3. **Width Conversion:** Converts master width to 64-bit internal

**Signal Naming:**
- **External ports:** Use `master.prefix` (e.g., `cpu_m_axi_`)
- **Internal signals:** Use `master.name` (e.g., `cpu_master_64b_ar`)

---

### 3. Crossbar Generator

**Location:** `bin/bridge_pkg/generators/crossbar_generator.py`

**Purpose:** Route adapter outputs to slave ports.

**Architecture:**
```
Adapter outputs (64-bit) → Mux per slave → Slave port (slave's native width)
                            (arbiter if needed)  (width conversion if needed)
```

**Generated Module Example:**
```systemverilog
module bridge_{name}_xbar (
    input  logic aclk,
    input  logic aresetn,

    // Master 0: cpu_master adapter outputs
    input  logic [NUM_SLAVES-1:0] cpu_master_slave_select_ar,
    input  axi4_ar_t              cpu_master_64b_ar,
    input  logic                  cpu_master_64b_arvalid,
    output logic                  cpu_master_64b_arready,
    // ...

    // Slave 0: ddr_ooo
    output logic [3:0]  ddr_ooo_s_axi_arid,     // ← ORIGINAL used _s_axi_
    output logic [31:0] ddr_ooo_s_axi_araddr,
    // ... (slave's native width)
);
```

**Key Functions:**

1. **Slave Port Declarations:** Generate output ports for each slave
2. **Mux Logic:** Route selected master to each slave
3. **Width Conversion:** Convert 64-bit internal to slave width
4. **Arbitration:** If multiple masters can target same slave

**Signal Naming (CRITICAL):**
- **Crossbar outputs to slaves:** Uses some convention for signal names
- **ORIGINAL CODE:** Used `SignalNaming.get_all_axi4_signals()` with appropriate parameters
- **MY BROKEN CHANGES:** Changed to use `slave.prefix` directly → generated wrong names

**Port Direction Database:**
- Line 276: Originally `signal_db = AXI4_SLAVE_SIGNALS`
- This determines whether signals are `input` or `output`
- Crossbar is MASTER to slaves, so outputs requests, inputs responses

---

### 4. Bridge Module Generator

**Location:** `bin/bridge_pkg/components/bridge_module_generator.py`

**Purpose:** Generate top-level bridge wrapper that instantiates adapters and crossbar.

**Architecture:**
```
External Master Ports → Adapter Instances → Crossbar Instance → External Slave Ports
```

**Generated Module Example:**
```systemverilog
module bridge_{name} (
    input  logic aclk,
    input  logic aresetn,

    // External master ports
    input  logic [3:0]  cpu_m_axi_arid,      // ← Uses master.prefix
    input  logic [31:0] cpu_m_axi_araddr,
    // ...

    // External slave ports
    output logic [3:0]  ddr_ooo_m_axi_arid,  // ← Uses slave.prefix
    output logic [31:0] ddr_ooo_m_axi_araddr,
    // ...
);

    // Internal 64-bit signals
    axi4_ar_t     cpu_master_64b_ar;
    logic         cpu_master_64b_arvalid;
    logic         cpu_master_64b_arready;
    // ...

    // Adapter instantiation
    cpu_master_adapter u_cpu_master_adapter (
        .aclk(aclk),
        .aresetn(aresetn),
        .cpu_m_axi_arid(cpu_m_axi_arid),      // ← Connect external to adapter
        // ... all master signals
        .cpu_master_64b_ar(cpu_master_64b_ar), // ← Internal 64-bit path
        // ...
    );

    // Crossbar instantiation
    bridge_{name}_xbar u_xbar (
        .aclk(aclk),
        .aresetn(aresetn),
        .cpu_master_64b_ar(cpu_master_64b_ar), // ← Internal from adapter
        // ...
        .ddr_ooo_s_axi_arid(ddr_ooo_s_axi_arid), // ← Connect to... WHAT?
        // ...
    );

endmodule
```

**Key Functions:**

1. **External Port Declarations:**
   - Master ports: Input (from external masters)
   - Slave ports: Output (to external slaves)

2. **Internal Signal Declarations:**
   - 64-bit adapter ↔ crossbar signals

3. **Adapter Instantiations:**
   - One per master
   - Connect external master ports to adapter
   - Connect adapter outputs to internal 64-bit signals

4. **Crossbar Instantiation:**
   - Connect internal 64-bit signals from adapters to crossbar inputs
   - Connect crossbar slave outputs to... **THIS IS WHERE THE BUG IS**

**Signal Naming (THE CRITICAL ISSUE):**

**Lines 621-639: Adapter Instantiation**
- **ORIGINAL:** Used `SignalNaming.get_all_axi4_signals(port_name=master.name, ...)`
- **MY CHANGES:** Used `master.prefix` directly
- **Effect:** Changed what signals get connected

**Lines 785-801: Crossbar Slave Connections**
- **ORIGINAL:** Used `SignalNaming.get_all_axi4_signals(port_name=slave.name, ...)`
- **MY CHANGES:** Used `slave.prefix` directly
- **Effect:** Crossbar now connects to signals like `ddr_ooo_s_axi_arid` that don't exist

---

## Signal Naming System

### Location: `bin/bridge_pkg/signal_naming.py`

### Key Classes

#### `SignalNaming`

Static class with helper methods for generating signal names.

**Key Method:**
```python
@staticmethod
def get_all_axi4_signals(
    port_name: str,          # e.g., "cpu_master" or "ddr_ooo"
    direction: Direction,    # MASTER or SLAVE
    channels: List[AXI4Channel],  # [AR, R] or [AW, W, B] or all
    data_width: int = 64
) -> List[Tuple[str, SignalInfo]]:
    """
    Generate all AXI4 signal names for a port.

    Returns list of (signal_name, signal_info) tuples.
    Example:
        ("cpu_master_m_axi_arid", SignalInfo(name="arid", width=4, ...))
    """
```

**Signal Name Construction:**
```python
# Pseudocode from original implementation
signal_name = f"{port_name}_{direction_suffix}_axi_{signal_base_name}"

# Examples:
# port_name="cpu_master", direction=MASTER, signal="arid"
#   → "cpu_master_m_axi_arid"

# port_name="ddr_ooo", direction=SLAVE, signal="arid"
#   → "ddr_ooo_s_axi_arid"
```

**Direction Suffixes:**
- `MASTER` → `"m_axi"`
- `SLAVE` → `"s_axi"`

#### Signal Databases: `AXI4_MASTER_SIGNALS` and `AXI4_SLAVE_SIGNALS`

These define signal directions from master/slave perspective.

**Structure:**
```python
AXI4_MASTER_SIGNALS = {
    AXI4Channel.AR: [
        SignalInfo(name="arid",    width="{ID_WIDTH}",   direction=Direction.OUTPUT),
        SignalInfo(name="araddr",  width="{ADDR_WIDTH}", direction=Direction.OUTPUT),
        SignalInfo(name="arvalid", width=1,              direction=Direction.OUTPUT),
        SignalInfo(name="arready", width=1,              direction=Direction.INPUT),
    ],
    AXI4Channel.R: [
        SignalInfo(name="rid",     width="{ID_WIDTH}",   direction=Direction.INPUT),
        SignalInfo(name="rdata",   width="{DATA_WIDTH}", direction=Direction.INPUT),
        SignalInfo(name="rvalid",  width=1,              direction=Direction.INPUT),
        SignalInfo(name="rready",  width=1,              direction=Direction.OUTPUT),
    ],
    # ... AW, W, B channels
}

AXI4_SLAVE_SIGNALS = {
    # Same signals, but directions are REVERSED
    AXI4Channel.AR: [
        SignalInfo(name="arid",    width="{ID_WIDTH}",   direction=Direction.INPUT),   # ← INPUT
        SignalInfo(name="araddr",  width="{ADDR_WIDTH}", direction=Direction.INPUT),   # ← INPUT
        SignalInfo(name="arvalid", width=1,              direction=Direction.INPUT),   # ← INPUT
        SignalInfo(name="arready", width=1,              direction=Direction.OUTPUT),  # ← OUTPUT
    ],
    # ...
}
```

**Usage in Generators:**

1. **Adapter Generator:** Uses `AXI4_SLAVE_SIGNALS` for external master-facing ports (adapter is slave to master)
2. **Crossbar Generator:** Uses ??? for slave-facing ports (crossbar is master to slaves)
3. **Bridge Generator:** Uses both depending on what's being connected

---

## YAML Configuration Format

### Location: `bin/test_configs/*.yaml`

### Example: `bridge_1x2_rd_minimal.yaml`

```yaml
bridge_name: bridge_1x2_rd

masters:
  - name: cpu_master             # Port name for internal references
    prefix: cpu_m_axi_           # Signal prefix for external ports
    type: axi4                   # Protocol
    channels: rd                 # rd, wr, or rw
    data_width: 32               # Master's data width
    addr_width: 32
    id_width: 4

slaves:
  - name: ddr_ooo                # Port name for internal references
    prefix: ddr_ooo_m_axi_       # Signal prefix for external ports (bridge is master)
    type: axi4
    channels: rd
    data_width: 64               # Slave's data width
    addr_width: 32
    id_width: 4
    base_addr: 0x00000000
    size: 0x40000000             # 1GB

  - name: sram_fifo
    prefix: sram_fifo_m_axi_
    type: axi4
    channels: rd
    data_width: 64
    addr_width: 32
    id_width: 4
    base_addr: 0x40000000
    size: 0x10000000             # 256MB

connectivity:
  - master: cpu_master
    slaves: [ddr_ooo, sram_fifo]  # cpu_master can access both slaves
```

### Key Fields

**Masters:**
- `name`: Used for internal signal names (e.g., `cpu_master_64b_ar`)
- `prefix`: Used for external port names (e.g., `cpu_m_axi_arid`)
- `channels`: `rd`, `wr`, or `rw` (determines which AXI channels to generate)
- `data_width`: Master's native data width (converted to 64-bit internally)

**Slaves:**
- `name`: Used for internal references
- `prefix`: Used for external port names (e.g., `ddr_ooo_m_axi_arid`)
  - **NOTE:** Prefix has `m_axi` because bridge is MASTER to slaves
- `base_addr`, `size`: Address decoding

**Connectivity:**
- Which masters can access which slaves (for address decoder)

---

## Architecture Diagrams

### Signal Flow: External → Adapter → Crossbar → External

```
External Master                 Adapter                    Internal 64b           Crossbar                External Slave
================                =======                    ============           ========                ==============

cpu_m_axi_arid[3:0]  ──────→   [Timing]  ────→  cpu_master_64b_ar.arid  ───→  [Mux]  ────→  ddr_ooo_m_axi_arid[3:0]
  (32-bit data)                [Decode]                    (64-bit data)         [Width]         (64-bit data)
  (Input to bridge)            [Width Convert]                                   [Convert]       (Output from bridge)

Signal naming:                  External ports:            Internal signals:      Crossbar:       External ports:
- Uses master.prefix           - Use master.prefix        - Use master.name      - ???           - Use slave.prefix
  (cpu_m_axi_)                   (cpu_m_axi_)              (cpu_master_64b_)                       (ddr_ooo_m_axi_)
```

### The Mystery: What Should Crossbar Outputs Be Named?

**Option 1: Direct Connection (No Intermediate Signals)**
```systemverilog
// Bridge top-level
module bridge_1x2_rd (
    output logic [3:0] ddr_ooo_m_axi_arid,  // ← External port
    // ...
);

    // Crossbar instantiation
    bridge_1x2_rd_xbar u_xbar (
        .ddr_ooo_s_axi_arid(ddr_ooo_m_axi_arid),  // ← Connect crossbar out to external port
        // crossbar port ^^^          ^^^ external port
    );
endmodule
```

**Option 2: Intermediate Signals**
```systemverilog
// Bridge top-level
module bridge_1x2_rd (
    output logic [3:0] ddr_ooo_m_axi_arid,  // ← External port
    // ...
);

    logic [3:0] ddr_ooo_s_axi_arid;  // ← Intermediate signal

    // Crossbar instantiation
    bridge_1x2_rd_xbar u_xbar (
        .ddr_ooo_s_axi_arid(ddr_ooo_s_axi_arid),  // ← Connect to intermediate
    );

    // Assignment
    assign ddr_ooo_m_axi_arid = ddr_ooo_s_axi_arid;  // ← Connect intermediate to external
endmodule
```

**Current Broken State: Option 2 WITHOUT declaring intermediate signals**
```systemverilog
// Bridge top-level (BROKEN)
module bridge_1x2_rd (
    output logic [3:0] ddr_ooo_m_axi_arid,  // ← External port declared
    // ...
);

    // NO DECLARATION of ddr_ooo_s_axi_arid!

    // Crossbar instantiation
    bridge_1x2_rd_xbar u_xbar (
        .ddr_ooo_s_axi_arid(ddr_ooo_s_axi_arid),  // ← Implicit 1-bit wire!
        //                   ^^^^^^^^^^^^^^^^^^^ UNDECLARED → defaults to 1-bit
    );

    // Verilator error: expects 4 bits, gets 1 bit
endmodule
```

---

## Current Broken State

### What I Changed

**File 1: `bridge_pkg/components/bridge_module_generator.py`**

**Lines 621-639: Adapter Instantiation**
- **Before:** Used `SignalNaming.get_all_axi4_signals(port_name=master.name, ...)`
- **After:** Loop through `AXI4_MASTER_SIGNALS` using `master.prefix` directly

**Lines 785-801: Crossbar Slave Connections**
- **Before:** Used `SignalNaming.get_all_axi4_signals(port_name=slave.name, ...)`
- **After:** Loop through `AXI4_MASTER_SIGNALS` using `slave.prefix` directly

**File 2: `bridge_pkg/generators/crossbar_generator.py`**

**Line 20: Import**
- **Before:** Only imported `AXI4_SLAVE_SIGNALS`
- **After:** Imported both `AXI4_SLAVE_SIGNALS` and `AXI4_MASTER_SIGNALS`

**Line 276: Signal Database Selection**
- **Before:** `signal_db = AXI4_SLAVE_SIGNALS`
- **After:** `signal_db = AXI4_MASTER_SIGNALS`

### What Broke

**Symptom:** Width mismatch errors like:
```
%Warning-WIDTHEXPAND: ... expects 4 bits on the pin connection,
but pin connection's VARREF 'ddr_ooo_s_axi_arid' generates 1 bits.
```

**Root Cause:**

1. **Bridge module** now instantiates crossbar with connections like:
   ```systemverilog
   .ddr_ooo_s_axi_arid(ddr_ooo_s_axi_arid),
   ```

2. **Signal `ddr_ooo_s_axi_arid` is NEVER DECLARED** in bridge module

3. **Verilator defaults undeclared signals to 1-bit**

4. **Crossbar expects multi-bit signals** (e.g., `[3:0]` for ID)

5. **Width mismatch error**

### Why It Broke

**The Misconception:**

I assumed the signal naming was "wrong" because I saw:
- External ports: `ddr_ooo_m_axi_arid`
- Crossbar connections: Trying to use `ddr_ooo_s_axi_arid`

I thought "these should match!" and tried to make everything use the same prefix.

**The Reality:**

The original code was using `SignalNaming.get_all_axi4_signals()` with **port names** (not prefixes), which would generate appropriate signal names with correct infixes (`_m_axi_` vs `_s_axi_`) based on the `direction` parameter.

My changes bypassed this system and directly used `prefix`, which:
1. Added `_s_axi_` infix where it shouldn't exist
2. Created signal names that were never declared
3. Broke compilation

### How to Fix

**Option 1: Revert All My Changes**

See `REVERT_INSTRUCTIONS.md` for detailed steps.

**Option 2: Understand Original Architecture and Fix Properly**

1. Read `signal_naming.py` to understand how `get_all_axi4_signals()` works
2. Determine what the correct signal names should be at each connection point
3. Either:
   - a) Use `SignalNaming.get_all_axi4_signals()` correctly
   - b) Declare intermediate signals in bridge module
   - c) Connect crossbar outputs directly to external ports

**Option 3: Simplify Architecture**

If the intermediate signal naming is confusing, consider:
1. Crossbar outputs connect directly to external slave ports
2. No intermediate signals with `_s_axi_` infix
3. Crossbar port names match external port names exactly

---

## Next Steps for Debugging

### 1. Understand Original Implementation

**Read original commits** (before my changes):
```bash
cd /mnt/data/github/rtldesignsherpa
git log --oneline projects/components/bridge/bin/bridge_pkg/ | head -10
# Find commit hash before my changes
git show <hash>:projects/components/bridge/bin/bridge_pkg/components/bridge_module_generator.py
```

**Compare lines 621-639 and 785-801** in original vs current.

### 2. Understand SignalNaming Usage

Read `bin/bridge_pkg/signal_naming.py` and understand:
- What does `get_all_axi4_signals(port_name="cpu_master", direction=MASTER, ...)` return?
- What does `get_all_axi4_signals(port_name="ddr_ooo", direction=MASTER, ...)` return?
- How do these names relate to YAML `prefix` fields?

### 3. Trace Signal Flow

Pick one signal (e.g., `arid`) and trace through:
1. External master port name (from YAML prefix)
2. Adapter external port name
3. Adapter internal signal name
4. Crossbar input port name
5. Crossbar output port name
6. Bridge intermediate signal name (if any)
7. External slave port name (from YAML prefix)

Understand where each name comes from and what system generates it.

### 4. Test Regeneration

After understanding architecture:
1. Revert my changes (or implement proper fix)
2. Delete all generated RTL: `rm -rf rtl/generated/bridge_*`
3. Regenerate: `cd dv/tests && make rebuild-all`
4. Check one generated file: `cat rtl/generated/bridge_1x2_rd/bridge_1x2_rd.sv`
5. Verify signal names are consistent and all declared
6. Run tests: `make run-parallel`

---

## Summary

**Build Flow:**
```
make rebuild-all → delete RTL → bridge_generator.py → parse YAML → generate package/adapters/crossbar/bridge → write to rtl/generated/
```

**Components:**
1. **Package Generator:** Types and structures
2. **Adapter Generator:** Per-master width conversion and decode
3. **Crossbar Generator:** Route adapters to slaves
4. **Bridge Generator:** Top-level wrapper

**Signal Naming:**
- `master.prefix` → External master port names (e.g., `cpu_m_axi_arid`)
- `master.name` → Internal signal names (e.g., `cpu_master_64b_ar`)
- `slave.prefix` → External slave port names (e.g., `ddr_ooo_m_axi_arid`)
- `SignalNaming.get_all_axi4_signals()` → Generate signal lists with appropriate infixes

**Current Problem:**
My changes broke the signal naming system by bypassing `SignalNaming` and directly using prefixes, causing the bridge to try to connect to undeclared signals.

**Solution:**
Revert changes and regenerate, OR understand original architecture and implement proper fix.
