// Bridge Slave Router Block Diagram
// Purpose: Show address decoding and slave selection logic

digraph slave_router {
    rankdir=TB;
    node [shape=box, style="rounded,filled", fillcolor=lightblue];
    edge [fontsize=10];

    // Title
    label="Slave Router Architecture\nAddress Decode and Selection";
    labelloc="t";
    fontsize=14;

    // Input from Masters
    subgraph cluster_input {
        label="From Master Adapters";
        style=filled;
        fillcolor=lightgreen;
        
        aw_in [label="AW Channels\n(N masters)\n\nAWVALID\nAWADDR\nAWID", fillcolor=palegreen];
        ar_in [label="AR Channels\n(N masters)\n\nARVALID\nARADDR\nARID", fillcolor=palegreen];
    }

    // Router Core
    subgraph cluster_router {
        label="Slave Router Module";
        style=filled;
        fillcolor=lightyellow;

        // AW Decode
        subgraph cluster_aw_decode {
            label="AW Address Decode";
            style=filled;
            fillcolor=lightcyan;
            
            aw_decode [label="Address\nDecoder\n\nPer-Master\nComparators", fillcolor=lightsteelblue];
            aw_matrix [label="Routing\nMatrix\n\nM×S selections", fillcolor=khaki];
            aw_oor [label="Out-of-Range\nDetection\n\nDECERR gen", fillcolor=lightcoral];
        }

        // AR Decode
        subgraph cluster_ar_decode {
            label="AR Address Decode";
            style=filled;
            fillcolor=lightcyan;
            
            ar_decode [label="Address\nDecoder\n\nPer-Master\nComparators", fillcolor=lightsteelblue];
            ar_matrix [label="Routing\nMatrix\n\nM×S selections", fillcolor=khaki];
            ar_oor [label="Out-of-Range\nDetection\n\nDECERR gen", fillcolor=lightcoral];
        }

        // Address Map
        addr_map [label="Address Map\nConfiguration\n\nSlave 0: BASE[0] - END[0]\nSlave 1: BASE[1] - END[1]\n...\nSlave N: BASE[N] - END[N]", shape=cylinder, fillcolor=wheat];
    }

    // Output to Slaves
    subgraph cluster_output {
        label="To Slave Arbiters";
        style=filled;
        fillcolor=lightcoral;
        
        aw_out [label="AW Requests\nper Slave\n\nS0: M masters\nS1: M masters\n...\nSN: M masters", fillcolor=lightpink];
        ar_out [label="AR Requests\nper Slave\n\nS0: M masters\nS1: M masters\n...\nSN: M masters", fillcolor=lightpink];
    }

    // Data Flow
    aw_in -> aw_decode [label="AWADDR[M]", color=blue, style=bold];
    aw_decode -> addr_map [label="Compare\nvs ranges", color=blue, style=dotted];
    aw_decode -> aw_matrix [label="Slave match\nper master", color=blue];
    aw_decode -> aw_oor [label="No match", color=red, style=dotted];
    aw_matrix -> aw_out [label="Route to\nSlave arbiters", color=blue, style=bold];
    aw_oor -> aw_out [label="Error\nresponse", color=red, style=dotted];

    ar_in -> ar_decode [label="ARADDR[M]", color=green, style=bold];
    ar_decode -> addr_map [label="Compare\nvs ranges", color=green, style=dotted];
    ar_decode -> ar_matrix [label="Slave match\nper master", color=green];
    ar_decode -> ar_oor [label="No match", color=red, style=dotted];
    ar_matrix -> ar_out [label="Route to\nSlave arbiters", color=green, style=bold];
    ar_oor -> ar_out [label="Error\nresponse", color=red, style=dotted];

    // Decode Logic Example
    example [label="Decode Logic (per master)\n\nfor each AWADDR:\n  if (ADDR >= SLAVE0_BASE && ADDR <= SLAVE0_END)\n    route_to_slave[0] = 1\n  else if (ADDR >= SLAVE1_BASE && ADDR <= SLAVE1_END)\n    route_to_slave[1] = 1\n  ...\n  else\n    out_of_range = 1  // Generate DECERR", shape=note, fillcolor=lightyellow];

    // Configuration
    config [label="Configuration\n\nAddress Map:\n• Per-slave BASE and SIZE\n• Non-overlapping ranges required\n• Gaps allowed (→ DECERR)\n\nDefault Slave:\n• Optional catch-all\n• Handles unmapped addresses\n\nPriority:\n• Lower slave index = higher priority\n• In case of overlaps", shape=note, fillcolor=lightgray];

    // Legend
    subgraph cluster_legend {
        label="Legend";
        style=filled;
        fillcolor=white;

        leg_write [label="Write Decode (AW)", style=bold, color=blue];
        leg_read [label="Read Decode (AR)", style=bold, color=green];
        leg_error [label="Error Path (OOR)", style=bold, color=red];
        leg_decode [label="Decode Logic", fillcolor=lightsteelblue, style=filled];
        leg_route [label="Routing Matrix", fillcolor=khaki, style=filled];
    }
}
