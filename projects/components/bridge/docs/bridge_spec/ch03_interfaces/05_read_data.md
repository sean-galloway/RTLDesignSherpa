# 3.5 Read Data and Response Channel (R)

The Read Data channel combines both read data and response status, returning data from slave to master in response to a read address request. Unlike writes (which use separate W and B channels), reads use a single R channel for data and status.

## 3.5.1 Overview

**Key Characteristics:**
- Travels from slave back to master (response path)
- Contains both data AND response status (unlike B channel)
- One R beat per data beat (arlen + 1 total beats)
- CAN interleave by ID (unlike W channel)
- Contains transaction ID for matching to AR
- Uses valid/ready handshake per beat

## 3.5.2 Channel Signals

```systemverilog
// Read Data Channel (Slave → Master)
input  logic                     rvalid;    // Read data valid
output logic                     rready;    // Read data ready
input  logic [ID_WIDTH-1:0]      rid;       // Read ID (matches arid)
input  logic [DATA_WIDTH-1:0]    rdata;     // Read data
input  logic [1:0]               rresp;     // Read response status
input  logic                     rlast;     // Last beat of burst
input  logic [USER_WIDTH-1:0]    ruser;     // User-defined sideband (optional)
```

## 3.5.3 Signal Descriptions

### rvalid
- **Direction:** Slave → Master
- **Width:** 1 bit
- **Description:** Indicates read data and response are valid
- **Protocol Rules:**
  - Slave asserts when R channel information is valid
  - Must remain asserted until `rready` is HIGH on rising edge
  - Once asserted, cannot be deasserted until handshake completes
  - Must be LOW during reset
  - Multiple R beats can be pipelined (different rids)

### rready
- **Direction:** Master → Slave
- **Width:** 1 bit
- **Description:** Indicates master is ready to accept read data
- **Protocol Rules:**
  - Master asserts when ready for data
  - Can toggle freely (no dependency on `rvalid`)
  - Recommended to assert early to maximize throughput
  - Should be HIGH when master has buffer space

### rid
- **Direction:** Slave → Master
- **Width:** ID_WIDTH bits (matches arid width)
- **Description:** Read response ID - matches original arid
- **Protocol Rules:**
  - Must match `arid` from corresponding AR transaction
  - Used by master to match data to original request
  - All beats in a burst carry same rid
  - Bridge may use extended ID for response routing
  - Must remain stable while `rvalid` is asserted

**ID Matching:**
```
Master sends:
  AR: arid = 7, arlen = 3 (4 beats)

Slave responds with 4 R beats:
  R beat 0: rid = 7, rlast = 0
  R beat 1: rid = 7, rlast = 0
  R beat 2: rid = 7, rlast = 0
  R beat 3: rid = 7, rlast = 1
  
  All beats have same rid matching arid.
```

### rdata
- **Direction:** Slave → Master
- **Width:** DATA_WIDTH bits (typically 32, 64, 128, 256, 512, or 1024)
- **Description:** Read data for current beat
- **Protocol Rules:**
  - Contains data read from memory/registers
  - Valid when `rresp == OKAY` or `EXOKAY`
  - May be undefined/invalid when `rresp == SLVERR` or `DECERR`
  - Must remain stable while `rvalid` is asserted
  - Byte order: Little-endian within bus width

**Data Bus Layout (64-bit example):**
```
rdata[63:56] - Byte 7  (highest address)
rdata[55:48] - Byte 6
rdata[47:40] - Byte 5
rdata[39:32] - Byte 4
rdata[31:24] - Byte 3
rdata[23:16] - Byte 2
rdata[15: 8] - Byte 1
rdata[ 7: 0] - Byte 0  (lowest address)
```

**Narrow Reads:**
```
For arsize < bus width, only relevant bytes contain valid data:

64-bit bus, reading 4 bytes (arsize=2) from address 0x1000:
  rdata[31:0]  = valid data from 0x1000-0x1003
  rdata[63:32] = undefined (don't care)

64-bit bus, reading 1 byte (arsize=0) from address 0x1002:
  araddr[2:0] = 0x2 → byte lane 2
  rdata[23:16] = valid data from 0x1002
  rdata[others] = undefined (don't care)
```

### rresp
- **Direction:** Slave → Master
- **Width:** 2 bits
- **Description:** Read response status for this beat
- **Protocol Rules:**
  - Indicates success or error of read transaction
  - **ALL beats in burst must have same rresp** (AXI4 rule)
  - If any error occurs, all beats report error
  - Must remain stable while `rvalid` is asserted

**Response Encoding:**
```
rresp = 2'b00 (OKAY):    Read successful
                         rdata contains valid data
                         Normal completion

rresp = 2'b01 (EXOKAY): Exclusive access okay
                         Atomic read succeeded
                         rdata contains valid data
                         Rare in most systems

rresp = 2'b10 (SLVERR): Slave error
                         Slave detected error
                         rdata may be invalid
                         Examples:
                           - Read from write-only register
                           - Invalid register address
                           - Permission denied
                           - ECC uncorrectable error

rresp = 2'b11 (DECERR): Decode error
                         No slave at this address
                         Generated by interconnect
                         rdata is invalid/undefined
                         Master requested unmapped address
```

**Error Propagation Rule:**
```
If ANY beat encounters error, ALL beats report error:
  - DECERR > SLVERR > EXOKAY > OKAY
  - Worst error wins
  
Example burst with 4 beats:
  Beat 0: Address 0x1000, can detect it's out-of-range
  Beat 1-3: Never accessed (error detected on beat 0)
  
  All 4 R beats return: rresp = DECERR
  
AXI4 Rule: "A slave must use the same RRESP value for all 
           data transfers in a burst"
```

### rlast
- **Direction:** Slave → Master
- **Width:** 1 bit
- **Description:** Indicates last data beat in read burst
- **Protocol Rules:**
  - Asserted on final R beat of transaction
  - Beat count must match `arlen + 1` from corresponding AR
  - Only ONE R beat in a burst has `rlast=1`
  - Must remain stable while `rvalid` is asserted
  - Critical for burst boundary detection and ID tracking

**rlast Timing:**
```
Transaction with arlen=3 (4 beats total):

R beat 0: rvalid=1, rlast=0, rid=5  → First beat
R beat 1: rvalid=1, rlast=0, rid=5  → Middle beat
R beat 2: rvalid=1, rlast=0, rid=5  → Middle beat
R beat 3: rvalid=1, rlast=1, rid=5  → LAST beat

Single beat (arlen=0):
R beat 0: rvalid=1, rlast=1, rid=5  → First AND last
```

### ruser
- **Direction:** Slave → Master
- **Width:** USER_WIDTH bits (optional, configurable)
- **Description:** User-defined sideband signaling
- **Protocol Rules:**
  - User-defined extension to protocol
  - Must remain stable while `rvalid` is asserted
  - Not all designs include this signal

## 3.5.4 Handshake Timing

**Single Beat Transfer:**
```
        ___     ___     ___     ___
aclk   |   |___|   |___|   |___|   |___
           ___________
rvalid  ___|           |_______________
           ___________
rready  ___|           |_______________
           ___________
rdata   XXX| 0xABCD   |XXXXXXXXXXXXX
           ___________
rresp   XXX|   OKAY   |XXXXXXXXXXXXX
           ___________
rlast   ___|     1     |_______________
```

**Burst Transfer (4 Beats):**
```
        ___     ___     ___     ___     ___     ___
aclk   |   |___|   |___|   |___|   |___|   |___|   |___
           ___________________________________________
rvalid  ___|                                           |___
           ___________________________________________
rready  ___|                                           |___
           _____   _____   _____   _____
rdata   XXX|_D0_|X|_D1_|X|_D2_|X|_D3_|XXXXXXXXXXXXX
           ___________________________________________
rresp   XXX|              OKAY                        |XXX
           _______________________________     _______
rlast   ___|                               |___|       |___
                                          ^^^
                                   rlast=1 on beat 3
```

**Slave Wait States:**
```
        ___     ___     ___     ___     ___     ___
aclk   |   |___|   |___|   |___|   |___|   |___|   |___
           ___________ ___ ___________     ___________
rvalid  ___|           |   |           |   |           |___
           ___________________________________________
rready  ___|                                           |___
           _____       ___     _____       _____
rdata   XXX|_D0_|XXXXX| X |XXX|_D1_|XXXXX|_D2_|XXXXXXXX

Beat 0 transferred cycle 1
Beat 1 stalled cycles 2-3 (rvalid=0, slave not ready)
Beat 1 transferred cycle 4
Beat 2 stalled cycle 5
Beat 2 transferred cycle 6
```

**Master Backpressure:**
```
        ___     ___     ___     ___     ___     ___
aclk   |   |___|   |___|   |___|   |___|   |___|   |___
           ___________________________________________
rvalid  ___|                                           |___
           ___________     ___ ___________
rready  ___|           |   |   |           |___________
           _____                     _____
rdata   XXX|_D0_|XXXXXXXXXXXXXXXXXXX|_D1_|XXXXXXXXXXXXX

Beat 0 transferred cycle 1
Beat 1 stalled cycles 2-4 (rready=0, master not ready)
Beat 1 transferred cycle 5
```

## 3.5.5 R Channel Interleaving

**KEY DIFFERENCE:** Unlike W channel, R channel **CAN** interleave by ID.

### Why Interleaving?

```
Different rid values can be interleaved:
  - Allows out-of-order completion
  - Slave doesn't need to buffer full bursts
  - Can return data as soon as available
  - Improves throughput and latency

This is the PRIMARY mechanism for out-of-order reads in AXI4.
```

### Interleaving Rules

```
Rule 1: R beats with SAME rid must be consecutive (no interleaving)
Rule 2: R beats with DIFFERENT rid CAN be interleaved
Rule 3: Within same rid, beats must be in order (beat 0, 1, 2...)

LEGAL:
  AR: arid=5, arlen=3 (4 beats needed)
  AR: arid=7, arlen=1 (2 beats needed)
  
  R: rid=5, beat 0, rlast=0
  R: rid=5, beat 1, rlast=0
  R: rid=7, beat 0, rlast=0  ← Interleaved! Different rid
  R: rid=7, beat 1, rlast=1  ← Complete rid=7
  R: rid=5, beat 2, rlast=0  ← Back to rid=5
  R: rid=5, beat 3, rlast=1  ← Complete rid=5

ILLEGAL:
  R: rid=5, beat 0, rlast=0
  R: rid=5, beat 1, rlast=0
  R: rid=5, beat 3, rlast=0  ← WRONG! Skipped beat 2
  R: rid=5, beat 2, rlast=1
```

### Interleaving Examples

**Example 1: Fast Read Overtakes Slow Read**
```
Cycle 0: AR (arid=1, slow memory address)
Cycle 1: AR (arid=2, cached address)

Slave responses:
Cycle 5: R (rid=2, beat 0, rlast=1) ← Cache hit, completes fast
Cycle 20: R (rid=1, beat 0)         ← Slow memory
Cycle 21: R (rid=1, beat 1, rlast=1)

rid=2 completed before rid=1 even though issued later!
```

**Example 2: Interleaved Multi-Beat Bursts**
```
Cycle 0: AR (arid=3, arlen=3, 4 beats)
Cycle 1: AR (arid=4, arlen=1, 2 beats)

Slave responses (interleaved):
Cycle 10: R (rid=3, beat 0, rlast=0)
Cycle 11: R (rid=3, beat 1, rlast=0)
Cycle 12: R (rid=4, beat 0, rlast=0)  ← Interleave starts
Cycle 13: R (rid=4, beat 1, rlast=1)  ← Complete rid=4
Cycle 14: R (rid=3, beat 2, rlast=0)  ← Back to rid=3
Cycle 15: R (rid=3, beat 3, rlast=1)  ← Complete rid=3
```

## 3.5.6 Ordering Rules

### In-Order for Same ID

**Rule:** R responses with same rid must complete in order of their AR.

```
LEGAL:
  Cycle 0: AR (arid=5, addr=0x1000)
  Cycle 1: AR (arid=5, addr=0x2000)
  Cycle 5: R (rid=5... rlast=1)  ← For first AR (0x1000)
  Cycle 6: R (rid=5... rlast=1)  ← For second AR (0x2000)

ILLEGAL:
  Cycle 0: AR (arid=5, addr=0x1000) transaction A
  Cycle 1: AR (arid=5, addr=0x2000) transaction B
  Cycle 5: R (rid=5... rlast=1)  ← For transaction B
  Cycle 6: R (rid=5... rlast=1)  ← For transaction A
  ^^^
  VIOLATION! Same ID out of order
```

### Out-of-Order for Different IDs

**Rule:** R responses with different rid CAN complete out of order.

```
LEGAL:
  Cycle 0: AR (arid=5)
  Cycle 1: AR (arid=7)
  Cycle 5: R (rid=7... rlast=1)  ← Second AR completes first
  Cycle 6: R (rid=5... rlast=1)  ← First AR completes second
  
This is the whole point of having IDs!
```

## 3.5.7 Data Width Conversion

When masters and slaves have different data widths, the bridge inserts width converters.

### Upsizing (Narrow Slave → Wide Master)

**Example: 32-bit slave, 64-bit master**

Slave returns (2 beats):
```
R beat 0: rdata[31:0] = 0xAAAA_AAAA
R beat 1: rdata[31:0] = 0xBBBB_BBBB, rlast=1
```

Converter packs → Master sees (1 beat):
```
R beat 0: rdata[63:0] = 0xBBBB_BBBB_AAAA_AAAA, rlast=1
```

### Downsizing (Wide Slave → Narrow Master)

**Example: 64-bit slave, 32-bit master**

Slave returns (1 beat):
```
R beat 0: rdata[63:0] = 0xBBBB_BBBB_AAAA_AAAA, rlast=1
```

Converter splits → Master sees (2 beats):
```
R beat 0: rdata[31:0] = 0xAAAA_AAAA, rlast=0
R beat 1: rdata[31:0] = 0xBBBB_BBBB, rlast=1
```

**See Section 2.6 for full width conversion details.**

## 3.5.8 Error Handling

### OKAY - Normal Read

```
rresp = 2'b00 (OKAY)

Meaning:
  - Read successful
  - rdata contains valid data from slave
  - Normal case

Master Action:
  - Accept rdata
  - Use data for computation
  - Transaction complete when rlast=1
```

### SLVERR - Slave Error

```
rresp = 2'b10 (SLVERR)

Possible Causes:
  - Read from write-only register
  - Address within slave range but invalid
  - Protected/secure access violation
  - ECC uncorrectable error
  - Slave internal error

Master Action:
  - rdata may be invalid/undefined
  - Do NOT use rdata for critical operations
  - Log error
  - May retry or report to software

Slave Behavior:
  - ALL beats in burst must return SLVERR
  - rdata can be any value (master should ignore)
  - rlast still indicates burst boundary
```

### DECERR - Decode Error

```
rresp = 2'b11 (DECERR)

Causes:
  - Address not mapped to any slave
  - Bridge router detected out-of-range address
  - Generated by interconnect, not by slave

Master Action:
  - rdata is invalid/undefined
  - Do NOT use rdata
  - Log serious error
  - Do NOT retry (address is wrong)
  - Report to software

Bridge Generation:
  - Bridge generates DECERR for unmapped addresses
  - Returns (arlen+1) R beats with rresp=DECERR
  - rdata = pattern (e.g., 0xDEADCAFE) or undefined
  - rid = captured arid
  - rlast on final beat
```

**Bridge DECERR Generation:**
```systemverilog
// Bridge generates DECERR for out-of-range addresses
always_ff @(posedge aclk) begin
    if (ar_out_of_range && arvalid && arready) begin
        // Capture transaction details
        oor_arid <= arid;
        oor_arlen <= arlen;
        oor_count <= 0;
        oor_generating <= 1'b1;
    end else if (oor_generating) begin
        // Generate R beats with DECERR
        rvalid <= 1'b1;
        rid <= oor_arid;
        rdata <= ERROR_PATTERN;  // e.g., 0xDEADBEEF
        rresp <= 2'b11;  // DECERR
        rlast <= (oor_count == oor_arlen);
        
        if (rready) begin
            oor_count <= oor_count + 1;
            if (rlast) oor_generating <= 1'b0;
        end
    end
end
```

### EXOKAY - Exclusive Okay

```
rresp = 2'b01 (EXOKAY)

Used For:
  - Atomic/exclusive reads
  - Part of load-linked/store-conditional
  - Semaphore operations

Meaning:
  - Exclusive read succeeded
  - Exclusive monitor tagged this address
  - Subsequent exclusive write can succeed

Note:
  - Rare in typical systems
  - Requires exclusive access monitor
  - Most bridges pass through
```

## 3.5.9 Bridge-Specific R Channel Considerations

### Response Routing

```
Multi-master bridge must route R to correct master:

Method 1: ID-based routing (most common)
  rid = {bridge_id, original_master_id}
  Bridge extracts bridge_id bits to route R
  
Method 2: CAM tracking
  Bridge records which master sent which arid
  Uses CAM to match rid to original master
  See Section 2.5 for details

Both methods work with R interleaving.
```

### R Channel Merging

```
Bridge merges R from multiple slaves → master:

Challenge: Multiple slaves may have R data ready simultaneously

Solution: R channel arbiter
  - Round-robin or priority-based
  - Considers rid to allow interleaving
  - Must not split bursts (wait for rlast)
  
Example:
  Slave 0: Has R data ready (rid=3)
  Slave 1: Has R data ready (rid=5)
  
  Arbiter grants Slave 0
  Transfers all beats for rid=3 until rlast
  Then can grant Slave 1 for rid=5
```

### Response Buffering

```
Bridge may buffer R data:
  - Small FIFO (2-8 entries typical)
  - Allows slave to push data ahead
  - Reduces backpressure
  - Master can be slow (rready=0)

Depth considerations:
  - Minimum: 2 (ping-pong)
  - Typical: 4-8 (good balance)
  - High performance: 16-32 (deep buffering)
```

### Outstanding Transaction Limits

```
Bridge must track outstanding reads:
  - AR issued but R not complete (rlast not seen)
  - Each slave has limit (e.g., 16 outstanding)
  - Prevents resource exhaustion
  
If limit reached:
  - arready = 0 (backpressure AR channel)
  - Wait for R completions (rlast)
  - Then allow more AR
```

## 3.5.10 Performance Implications

### Latency

```
Read latency = AR to last R beat (rlast=1)

Minimum (best case):
  - Register read: 1-2 cycles
  - SRAM read: 2-3 cycles
  
Typical:
  - On-chip memory: 3-10 cycles
  - Cache hit: 2-5 cycles
  
Maximum (worst case):
  - Cache miss → off-chip: 50-200 cycles
  - Slow peripheral: 100+ cycles
```

### Throughput

```
Maximum throughput:
  - R data every cycle
  - Requires:
    * Slave rvalid always HIGH
    * Master rready always HIGH
    * Deep pipelining
    * Multiple outstanding reads
  
Bottlenecks:
  - Slave memory bandwidth
  - Bridge arbitration
  - Master buffer space (rready=0)
  - Outstanding limit reached
```

### Optimizations

**1. Pipelining:**
```
Issue multiple ARs before first R returns:
  Cycle 0: AR (arid=0)
  Cycle 1: AR (arid=1)
  Cycle 2: AR (arid=2)
  Cycle 5: R (rid=0)... ← First data arrives
  Cycle 6: R (rid=1)...
  Cycle 7: R (rid=2)...
  
Hides AR-to-R latency.
```

**2. Interleaving:**
```
Use different arids for independent reads:
  - Allows out-of-order completion
  - Slave can return cached data immediately
  - Doesn't block on slow reads
```

**3. Burst Reads:**
```
Use longer bursts where possible:
  arlen=15 (16 beats) better than 16× arlen=0
  - Amortizes AR overhead
  - Better memory efficiency
  - Higher throughput
```

## 3.5.11 Common Issues and Debug

### Issue 1: Missing R Data

```
Symptom: AR transfers but R never arrives
Causes:
  - Slave hung
  - R channel disconnected
  - Bridge routing error
  - Out-of-range address (should get DECERR)

Debug:
  - Check slave status
  - Verify bridge routing logic
  - Check address map
  - Implement timeout
```

### Issue 2: rid Mismatch

```
Symptom: rid doesn't match any outstanding arid
Causes:
  - Bridge routing error
  - ID corruption
  - Spurious R response

Debug:
  - Track outstanding arids
  - Compare rid to pending list
  - Check bridge ID extension
```

### Issue 3: Wrong Beat Count

```
Symptom: Number of R beats doesn't match arlen+1
Causes:
  - rlast logic error
  - Beat counter bug
  - Lost R beats

Debug:
  - Count R beats from first to rlast
  - Must equal (arlen+1) from corresponding AR
  - Check rlast generation logic
```

### Issue 4: Illegal R Interleaving

```
Symptom: R beats with same rid not consecutive
Causes:
  - Slave implementation error
  - Bridge merging bug

Debug:
  - Track rid sequence
  - Verify same rid beats are consecutive
  - Check for interleaving violations
```

### Issue 5: rdata Invalid on Error

```
Symptom: Master uses rdata despite rresp=SLVERR/DECERR
Causes:
  - Master not checking rresp
  - Software bug

Debug:
  - Always check rresp before using rdata
  - Add assertion: if (rresp != OKAY) don't use rdata
```

## 3.5.12 Verification Checks

```systemverilog
// Assertion: Every AR gets (arlen+1) R beats
property ar_r_correspondence;
    logic [7:0] expected_beats;
    @(posedge aclk) disable iff (!aresetn)
    (arvalid && arready, expected_beats = arlen + 1) |->
    ##[1:MAX_LATENCY] 
    (rvalid && rready && rid == $past(arid), expected_beats--) [*expected_beats];
endproperty

// Assertion: rlast only on final beat
property rlast_on_final;
    @(posedge aclk) disable iff (!aresetn)
    (rvalid && rready && rlast) |-> (beat_count == expected_beats);
endproperty

// Assertion: Same rid beats consecutive
property same_rid_consecutive;
    @(posedge aclk) disable iff (!aresetn)
    (rvalid && rready && !rlast && rid == ID_X) |->
    ##1 (rvalid && rready) |-> (rid == ID_X);
endproperty

// Assertion: Same rresp for all beats in burst
property same_rresp_in_burst;
    logic [1:0] first_rresp;
    @(posedge aclk) disable iff (!aresetn)
    (rvalid && rready && !rlast, first_rresp = rresp) |->
    (rvalid && rready [->1:$] until rlast) |-> (rresp == first_rresp);
endproperty
```

---

**Related Sections:**
- Section 3.4: Read Address Channel (AR)
- Section 3.2: Write Data Channel (W) - contrast with R interleaving
- Section 2.5: ID Management
- Section 2.6: Width Conversion
- Section 2.8: Response Routing
- Section 2.9: Error Handling

**Next:** [Chapter 4: Usage Examples](../ch04_usage_examples/01_basic_configuration.md)
