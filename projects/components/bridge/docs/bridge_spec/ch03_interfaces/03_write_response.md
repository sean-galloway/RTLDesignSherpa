# 3.3 Write Response Channel (B)

The Write Response (B) channel carries the acknowledgment from slave to master that a write transaction has completed. It includes the transaction ID and status.

## 3.3.1 Overview

**Key Characteristics:**
- Travels from slave back to master (response path)
- Contains transaction ID for matching to AW
- Single beat per write transaction (regardless of awlen)
- Can complete out-of-order for different IDs
- Must complete in-order for same ID

## 3.3.2 Channel Signals

```systemverilog
// Write Response Channel (Slave → Master)
input  logic                     bvalid;    // Write response valid
output logic                     bready;    // Write response ready
input  logic [ID_WIDTH-1:0]      bid;       // Response ID (matches awid)
input  logic [1:0]               bresp;     // Write response status
input  logic [USER_WIDTH-1:0]    buser;     // User-defined sideband (optional)
```

## 3.3.3 Signal Descriptions

### bvalid
- **Direction:** Slave → Master
- **Width:** 1 bit
- **Description:** Indicates write response is valid
- **Protocol Rules:**
  - Slave asserts when write transaction completes
  - Must remain asserted until `bready` is HIGH on rising edge
  - Once asserted, cannot be deasserted until handshake completes
  - Must be LOW during reset
  - One B response per AW transaction

### bready
- **Direction:** Master → Slave
- **Width:** 1 bit
- **Description:** Indicates master is ready to accept response
- **Protocol Rules:**
  - Master asserts when ready for write response
  - Can be asserted before, during, or after `bvalid`
  - Recommended to assert early to avoid backpressure
  - Can toggle freely
  - Master should track outstanding writes and be ready

### bid
- **Direction:** Slave → Master
- **Width:** ID_WIDTH bits (matches awid width)
- **Description:** Write response ID - matches original awid
- **Protocol Rules:**
  - Must match `awid` from corresponding AW transaction
  - Used by master to match response to original request
  - Bridge may use extended ID for response routing
  - Must remain stable while `bvalid` is asserted
  - Critical for out-of-order completion

**ID Matching:**
```
Master sends:
  AW: awid = 5
  W:  (awlen+1) beats

Slave eventually responds:
  B:  bid = 5  ← Must match original awid
```

### bresp
- **Direction:** Slave → Master
- **Width:** 2 bits
- **Description:** Write response status
- **Protocol Rules:**
  - Indicates success or error of write transaction
  - All beats in the burst share same response
  - Must remain stable while `bvalid` is asserted

**Response Encoding:**
```
bresp = 2'b00 (OKAY):    Write successful
                         All data written correctly
                         Normal completion

bresp = 2'b01 (EXOKAY): Exclusive access okay
                         Atomic operation succeeded
                         Rare in most systems

bresp = 2'b10 (SLVERR): Slave error
                         Slave detected error
                         Examples:
                           - Invalid register address
                           - Write to read-only register
                           - Permission denied
                           - Timeout on downstream bus

bresp = 2'b11 (DECERR): Decode error
                         No slave at this address
                         Generated by interconnect
                         Master requested unmapped address
```

**Response Priority:**
```
If ANY beat encounters error, entire burst reports error:
  - DECERR > SLVERR > EXOKAY > OKAY
  - Worst error wins
  
Example:
  Beat 0: OKAY
  Beat 1: SLVERR  ← Error on one beat
  Beat 2: OKAY
  Beat 3: OKAY
  
  Final B response: bresp = SLVERR (error propagates to all)
```

### buser
- **Direction:** Slave → Master
- **Width:** USER_WIDTH bits (optional, configurable)
- **Description:** User-defined sideband signaling
- **Protocol Rules:**
  - User-defined extension to protocol
  - Must remain stable while `bvalid` is asserted
  - Not all designs include this signal

## 3.3.4 Handshake Timing

**Zero-Wait Response:**
```
        ___     ___     ___     ___
aclk   |   |___|   |___|   |___|   |___
           ___________
bvalid  ___|           |_______________
           ___________
bready  ___|           |_______________
           ___________
bid     XXX|     5     |XXXXXXXXXXXXX
           ___________
bresp   XXX|   OKAY   |XXXXXXXXXXXXX
```

**Slave Wait States:**
```
        ___     ___     ___     ___     ___     ___
aclk   |   |___|   |___|   |___|   |___|   |___|   |___
           _______________________________
bvalid  ___|                               |___________
                   ___________
bready  ___________|           |_______________________
           _______________________________
bid     XXX|              5                |XXXXXXXXXXX
```
Slave waits 2 cycles for master to be ready.

**Master Wait States:**
```
        ___     ___     ___     ___     ___     ___
aclk   |   |___|   |___|   |___|   |___|   |___|   |___
                   _______________________
bvalid  ___________|                       |___________
           ___________
bready  ___|           |_______________________________
           ___________
bid     XXXXXXXXXXXXX|          5          |XXXXXXXXXXX
```
Master ready early, waits 2 cycles for slave response.

## 3.3.5 Write Transaction Completion

### Basic Write Flow

```
Step 1: Master sends AW (awid=5, awlen=3)
Step 2: Master sends 4 W beats (wlast on beat 3)
Step 3: Slave processes write
Step 4: Slave sends B (bid=5, bresp=OKAY)
Step 5: Master receives B, transaction complete
```

**Timeline:**
```
Cycle 0: AW transfer (awid=5, awaddr=0x1000, awlen=3)
Cycle 1: W beat 0 transfer
Cycle 2: W beat 1 transfer
Cycle 3: W beat 2 transfer
Cycle 4: W beat 3 transfer (wlast=1)
         ^^^
         Slave can now generate B response
Cycle 5: ... (slave processing)
Cycle 6: B transfer (bid=5, bresp=OKAY)
```

### When Does Slave Generate B?

**Minimum Requirement:**
```
Slave MUST see final W beat (wlast=1) before generating B
- B response covers ALL beats in the burst
- Cannot respond until all data received
```

**Typical Timing:**
```
Fast Slave (0 latency):
  Cycle N: wlast=1 on W channel
  Cycle N+1: bvalid=1 on B channel

Medium Slave (1-2 cycles):
  Cycle N: wlast=1
  Cycle N+1: (internal processing)
  Cycle N+2: bvalid=1

Slow Slave (>2 cycles):
  Cycle N: wlast=1
  Cycles N+1 to N+K: (processing, may involve memory access)
  Cycle N+K+1: bvalid=1
```

### Outstanding Write Tracking

```systemverilog
// Master tracks outstanding writes
logic [3:0] outstanding_writes;  // Count of AW sent but B not received

always_ff @(posedge aclk) begin
    if (!aresetn) begin
        outstanding_writes <= 0;
    end else begin
        case ({awvalid && awready, bvalid && bready})
            2'b10: outstanding_writes <= outstanding_writes + 1;  // AW only
            2'b01: outstanding_writes <= outstanding_writes - 1;  // B only
            2'b11: outstanding_writes <= outstanding_writes;      // Both
            2'b00: outstanding_writes <= outstanding_writes;      // Neither
        endcase
    end
end

// Master should not overflow limit
assign aw_can_issue = (outstanding_writes < MAX_OUTSTANDING);
```

## 3.3.6 Ordering Rules

### In-Order for Same ID

**Rule:** Responses with same ID must complete in order of their AW.

```
LEGAL:
  Cycle 0: AW (awid=5)
  Cycle 1: AW (awid=5)
  Cycle 5: B (bid=5)  ← First awid=5
  Cycle 6: B (bid=5)  ← Second awid=5 (must be after first)

ILLEGAL:
  Cycle 0: AW (awid=5) transaction A
  Cycle 1: AW (awid=5) transaction B
  Cycle 5: B (bid=5)  ← For transaction B
  Cycle 6: B (bid=5)  ← For transaction A
  ^^^
  Order violation! Same ID responses out of order
```

### Out-of-Order for Different IDs

**Rule:** Responses with different IDs CAN complete out of order.

```
LEGAL:
  Cycle 0: AW (awid=5)
  Cycle 1: AW (awid=7)
  Cycle 5: B (bid=7)  ← awid=7 completes first
  Cycle 6: B (bid=5)  ← awid=5 completes second
  ^^^
  Legal! Different IDs can reorder
```

### Bridge Response Routing

In multi-master bridge, `bid` contains routing information:

```
Extended ID Structure:
  bid = {bridge_id, original_master_id}
  
Bridge uses bridge_id to route B back to correct master:
  if (bid[upper_bits] == BRIDGE_ID_M0)
    route B to Master 0
  else if (bid[upper_bits] == BRIDGE_ID_M1)
    route B to Master 1
  ...
```

## 3.3.7 Error Handling

### OKAY - Normal Completion

```
bresp = 2'b00 (OKAY)

Meaning:
  - All data written successfully
  - No errors detected
  - Normal case

Master Action:
  - Transaction complete
  - Continue normal operation
```

### SLVERR - Slave Error

```
bresp = 2'b10 (SLVERR)

Possible Causes:
  - Write to read-only register
  - Address within slave range but invalid
  - Protected/secure access violation
  - Slave internal error
  - Downstream error

Master Action:
  - Log error
  - May retry or report to software
  - Consider transaction failed
  - Do NOT assume data was written
```

### DECERR - Decode Error

```
bresp = 2'b11 (DECERR)

Causes:
  - Address not mapped to any slave
  - Bridge router detected out-of-range address
  - Generated by interconnect, not by slave

Master Action:
  - Log serious error
  - Address may be corrupt or misconfigured
  - Do NOT retry (address is invalid)
  - Report to software for investigation
```

**Bridge DECERR Generation:**
```systemverilog
// Bridge generates DECERR for unmapped addresses
logic oor_error;  // Out-of-range

// After AW with unmapped address
always_ff @(posedge aclk) begin
    if (aw_unmapped && awvalid && awready) begin
        // Sink W channel data
        // ...
        
        // Generate DECERR response
        bvalid <= 1'b1;
        bid <= captured_awid;
        bresp <= 2'b11;  // DECERR
    end
end
```

### EXOKAY - Exclusive Okay

```
bresp = 2'b01 (EXOKAY)

Used For:
  - Atomic/exclusive accesses
  - Read-modify-write operations
  - Semaphores, mutexes

Meaning:
  - Exclusive write succeeded
  - No other master modified location

Note:
  - Rare in typical bridge configurations
  - Requires exclusive access monitor
  - Most bridges pass through or convert to OKAY
```

## 3.3.8 Common Issues and Debug

### Issue 1: Missing B Response

```
Symptom: Master sends AW and W, but never receives B
Causes:
  - Slave stuck or hung
  - B channel disconnected
  - Slave waiting for missing W data
  - Bridge routing error

Debug:
  - Check wlast was asserted
  - Check slave received all W beats
  - Monitor slave internal state
  - Check bridge ID routing logic
  - Implement timeout mechanism
```

### Issue 2: ID Mismatch

```
Symptom: bid does not match any outstanding awid
Causes:
  - Bridge routing error
  - ID corruption
  - Spurious B response

Debug:
  - Log all awid values sent
  - Compare bid to outstanding transactions
  - Check bridge ID extension logic
  - Verify slave ID pass-through
```

### Issue 3: Wrong Number of B Responses

```
Symptom: More/fewer B responses than AW requests
Causes:
  - Lost AW transaction
  - Duplicate B response
  - Bridge accounting error

Debug:
  - Count AW transfers vs B transfers
  - Should be 1:1 correspondence
  - Track outstanding transactions
```

### Issue 4: Out-of-Order Same ID

```
Symptom: Two awid=X transactions complete in wrong order
Causes:
  - Slave reordering logic bug
  - Bridge routing error
  - Out-of-order memory

Debug:
  - Log AW order and B order for same ID
  - Check slave ordering guarantees
  - Verify ID matching logic
```

### Issue 5: Unexpected Error Response

```
Symptom: bresp=SLVERR or DECERR on valid address
Causes:
  - Protection violation
  - Slave misconfiguration
  - Transient error
  - Bridge incorrectly flagging as out-of-range

Debug:
  - Check address against memory map
  - Verify awprot settings
  - Check slave status registers
  - Review bridge address decoder
```

## 3.3.9 Bridge-Specific Considerations

### Response Routing

```
Multi-master bridge must route B to correct master:

Method 1: ID-based routing (most common)
  - Bridge extends ID: {bridge_id, master_id}
  - B response contains full extended ID
  - Bridge extracts bridge_id to route B

Method 2: CAM/FIFO tracking
  - Bridge records which master sent which awid
  - Uses CAM to match bid to original master
  - See Section 2.5 for details
```

### Response Forwarding

```
Bridge forwards bresp unchanged:
  - OKAY → OKAY
  - SLVERR → SLVERR
  - DECERR → DECERR (from slave)
  
Bridge generates DECERR for unmapped addresses:
  - Router detects address out of range
  - Sinks W channel data
  - Generates B with DECERR
  - bid matches captured awid
```

### Response Buffering

```
Bridge may buffer B responses:
  - Small FIFO (2-4 entries typical)
  - Allows slave to push responses
  - Reduces backpressure
  - Master can be slow to accept

Buffering helps when:
  - Multiple masters share response path
  - Master occasionally busy (bready=0)
  - Improves overall throughput
```

### Outstanding Transaction Limits

```
Bridge limits outstanding writes per master:
  - Tracks count: AW sent, B not yet received
  - Backpressures when limit reached
  - Prevents CAM overflow
  - Typical limits: 16-64 outstanding

If limit reached:
  - awready = 0 to master
  - Wait for B responses to free slots
  - Then allow more AW
```

## 3.3.10 Performance Implications

### Latency

```
Write Latency = Time from AW to B

Components:
  1. AW to slave
  2. W beats to slave
  3. Slave processing
  4. B back to master

Total: Typically 3-20 cycles for on-chip slave
       100+ cycles for off-chip memory
```

### Throughput

```
Posted Writes:
  - Master sends AW+W without waiting for B
  - Can pipeline multiple writes
  - B responses come later
  - High throughput

Blocking Writes:
  - Master waits for B before next AW
  - Lower throughput
  - Simpler master logic
```

### Pipelining

```
Maximum throughput when:
  - Master issues AWs back-to-back
  - bready always HIGH (ready for B)
  - Slave bvalid frequently HIGH
  - Deep outstanding queue

Limited by:
  - Slave B response rate
  - Master outstanding limit
  - Bridge CAM depth
```

## 3.3.11 Verification Checks

```systemverilog
// Assertion: Every AW must get exactly one B
property aw_b_correspondence;
    @(posedge aclk) disable iff (!aresetn)
    awvalid && awready |-> ##[1:MAX_LATENCY] bvalid && bready;
endproperty

// Assertion: bid must match outstanding awid
property bid_matches_outstanding;
    @(posedge aclk) disable iff (!aresetn)
    bvalid && bready |-> outstanding_set[bid];
endproperty

// Assertion: Same ID responses in order
property same_id_order;
    @(posedge aclk) disable iff (!aresetn)
    (awvalid && awready && awid == ID_X) ##1
    (awvalid && awready && awid == ID_X) |->
    first_matches(bvalid && bready && bid == ID_X) ##1
    first_matches(bvalid && bready && bid == ID_X);
endproperty
```

---

**Related Sections:**
- Section 3.1: Write Address Channel (AW)
- Section 3.2: Write Data Channel (W)
- Section 2.5: ID Management
- Section 2.8: Response Routing
- Section 2.9: Error Handling

**Next:** [3.4 Read Address Channel (AR)](04_read_address.md)
