"""
Slave Adapter Generator for Bridge Crossbars

Generates per-slave adapter modules that sit between crossbar and external slaves.

Each slave adapter contains:
- Timing isolation wrapper (axi4_master_wr/rd for AXI4 slaves)
- Protocol conversion (axi4_to_apb, axi4_to_axil for non-AXI4 slaves)
- Final skid buffers before external slave interface
"""

from dataclasses import dataclass
from typing import List
from ..signal_naming import SignalNaming, Direction, AXI4Channel, PortDirection, SignalInfo, AXI4_MASTER_SIGNALS


@dataclass
class SlaveInfo:
    """Configuration for a slave port."""
    name: str
    prefix: str
    base_addr: int
    addr_range: int
    data_width: int
    addr_width: int
    protocol: str = 'axi4'  # 'axi4', 'apb', or 'axil'


class SlaveAdapterGenerator:
    """
    Generates per-slave adapter modules for bridge crossbars.

    Each slave adapter contains:
    - axi4_master_wr/rd timing wrappers (for AXI4 slaves)
    - axi4_to_apb converter (for APB slaves)
    - axi4_to_axil converter (for AXI4-Lite slaves)
    - Final skid buffers before external interface
    """

    def __init__(self, bridge_name: str, slave_config: SlaveInfo, channels: str,
                 id_width: int = 4, data_width: int = 32):
        """
        Initialize slave adapter generator.

        Args:
            bridge_name: Name of bridge (e.g., "bridge_1x2_wr")
            slave_config: Configuration for this slave
            channels: Channel type ("wr", "rd", or "rw")
            id_width: AXI4 ID width (crossbar internal width)
            data_width: Crossbar internal data width
        """
        self.bridge_name = bridge_name
        self.slave = slave_config
        self.channels = channels
        self.id_width = id_width
        self.data_width = data_width

        # Determine which channels we have
        self.has_write = channels in ["wr", "rw"]
        self.has_read = channels in ["rd", "rw"]

        # Skid buffer depths (configurable)
        self.skid_depth_aw = 2
        self.skid_depth_ar = 2
        self.skid_depth_w = 4
        self.skid_depth_r = 2
        self.skid_depth_b = 2

    def generate(self) -> str:
        """
        Generate complete slave adapter module.

        Returns:
            SystemVerilog slave adapter module source code
        """
        lines = []

        # Header
        lines.extend(self._generate_header())

        # Module declaration
        lines.extend(self._generate_module_declaration())

        # Internal signals
        lines.extend(self._generate_internal_signals())

        # Timing wrapper or protocol converter
        if self.slave.protocol == 'axi4':
            lines.extend(self._generate_axi4_timing_wrapper())
        elif self.slave.protocol == 'apb':
            lines.extend(self._generate_apb_converter())
        elif self.slave.protocol == 'axil':
            lines.extend(self._generate_axil_converter())

        # Module end
        lines.append(f"endmodule : {self.slave.name}_adapter")
        lines.append("")

        return "\n".join(lines)

    def _generate_header(self) -> List[str]:
        """Generate file header."""
        return [
            f"// Slave Adapter: {self.slave.name}_adapter",
            "// Generated by: SlaveAdapterGenerator",
            "//",
            f"// Provides timing isolation and protocol conversion for slave: {self.slave.name}",
            f"// Protocol: {self.slave.protocol.upper()}",
            "",
            "`timescale 1ns / 1ps",
            "",
            f"import {self.bridge_name}_pkg::*;",
            ""
        ]

    def _generate_module_declaration(self) -> List[str]:
        """Generate module declaration with all ports."""
        lines = []

        lines.append(f"module {self.slave.name}_adapter (")
        lines.append("    input  logic aclk,")
        lines.append("    input  logic aresetn,")
        lines.append("")

        # Crossbar-facing interface (AXI4 input from crossbar)
        lines.append(f"    // Crossbar interface (AXI4 from crossbar)")
        lines.extend(self._generate_crossbar_interface_ports())
        lines.append("")

        # External slave interface
        lines.append(f"    // External slave interface ({self.slave.protocol.upper()})")
        lines.extend(self._generate_external_interface_ports())

        lines.append(");")
        lines.append("")

        return lines

    def _generate_crossbar_interface_ports(self) -> List[str]:
        """
        Generate crossbar-facing interface ports (AXI4 inputs from crossbar).

        These are always AXI4 regardless of slave protocol.
        Port directions are from adapter's perspective:
        - Adapter receives requests from crossbar (INPUT)
        - Adapter sends responses to crossbar (OUTPUT)
        """
        lines = []

        # Use crossbar output naming: xbar_{slave}_axi_*
        # This matches what bridge_module_generator expects
        prefix = f"xbar_{self.slave.name}_axi_"

        # Width parameters
        width_values = {
            'ID_WIDTH': 4,  # Crossbar uses 4-bit IDs
            'ADDR_WIDTH': self.slave.addr_width,
            'DATA_WIDTH': self.slave.data_width,
            'STRB_WIDTH': self.slave.data_width // 8,
            'USER_WIDTH': 1
        }

        # Determine channels based on adapter type
        channels = []
        if self.channels in ["wr", "rw"]:
            channels.extend([AXI4Channel.AW, AXI4Channel.W, AXI4Channel.B])
        if self.channels in ["rd", "rw"]:
            channels.extend([AXI4Channel.AR, AXI4Channel.R])

        # Get signal info from SignalNaming
        # Crossbar is master to adapter, so adapter sees inverted directions
        signal_db = AXI4_MASTER_SIGNALS

        for channel in channels:
            if channel not in signal_db:
                continue

            for sig_info in signal_db[channel]:
                # Build signal name
                sig_name = f"{prefix}{channel.value}{sig_info.name}"

                # Invert direction (adapter receives from crossbar master)
                inverted_direction = PortDirection.INPUT if sig_info.direction == PortDirection.OUTPUT else PortDirection.OUTPUT

                # Create inverted signal info
                inverted_sig = SignalInfo(
                    name=sig_info.name,
                    direction=inverted_direction,
                    width_expr=sig_info.width_expr,
                    width_param=sig_info.width_param,
                    is_vector=sig_info.is_vector,
                    description=sig_info.description
                )

                # Get declaration
                declaration = inverted_sig.get_declaration(sig_name, width_values)
                lines.append(f"    {declaration},")

        return lines

    def _generate_external_interface_ports(self) -> List[str]:
        """
        Generate external slave interface ports.

        Protocol depends on slave type:
        - AXI4: Direct AXI4 signals (from axi4_master_wr/rd wrapper)
        - APB: APB signals
        - AXIL: AXI4-Lite signals
        """
        lines = []

        if self.slave.protocol == 'axi4':
            lines.extend(self._generate_axi4_external_ports())
        elif self.slave.protocol == 'apb':
            lines.extend(self._generate_apb_external_ports())
        elif self.slave.protocol == 'axil':
            lines.extend(self._generate_axil_external_ports())

        return lines

    def _generate_axi4_external_ports(self) -> List[str]:
        """Generate AXI4 external slave ports using SignalNaming."""
        lines = []

        # Use slave prefix from config
        prefix = self.slave.prefix

        # Width parameters
        width_values = {
            'ID_WIDTH': 4,
            'ADDR_WIDTH': self.slave.addr_width,
            'DATA_WIDTH': self.slave.data_width,
            'STRB_WIDTH': self.slave.data_width // 8,
            'USER_WIDTH': 1
        }

        # Determine channels
        channels = []
        if self.channels in ["wr", "rw"]:
            channels.extend([AXI4Channel.AW, AXI4Channel.W, AXI4Channel.B])
        if self.channels in ["rd", "rw"]:
            channels.extend([AXI4Channel.AR, AXI4Channel.R])

        # Adapter acts as master to external slave
        signal_db = AXI4_MASTER_SIGNALS

        # Pre-calculate last signal
        last_channel = channels[-1] if channels else None

        for channel_idx, channel in enumerate(channels):
            if channel not in signal_db:
                continue

            channel_signals = list(signal_db[channel])
            for sig_idx, sig_info in enumerate(channel_signals):
                # Build signal name
                sig_name = f"{prefix}{channel.value}{sig_info.name}"

                # Get declaration
                declaration = sig_info.get_declaration(sig_name, width_values)

                # Check if last signal
                is_last_channel = (channel == last_channel)
                is_last_signal = (sig_idx == len(channel_signals) - 1)
                is_very_last = (is_last_channel and is_last_signal)

                if is_very_last:
                    lines.append(f"    {declaration}")  # No comma
                else:
                    lines.append(f"    {declaration},")

        return lines

    def _generate_apb_external_ports(self) -> List[str]:
        """Generate APB external slave ports."""
        lines = []
        prefix = self.slave.prefix

        # APB signals (adapter is master to slave)
        addr_width = self.slave.addr_width
        data_width = self.slave.data_width
        strb_width = data_width // 8

        # APB standard uses uppercase signal names (PADDR, PSEL, etc.)
        lines.append(f"    output logic [{addr_width-1}:0] {prefix}PADDR,")
        lines.append(f"    output logic                  {prefix}PSEL,")
        lines.append(f"    output logic                  {prefix}PENABLE,")
        lines.append(f"    output logic                  {prefix}PWRITE,")
        lines.append(f"    output logic [{data_width-1}:0] {prefix}PWDATA,")
        lines.append(f"    output logic [{strb_width-1}:0] {prefix}PSTRB,")
        lines.append(f"    output logic [2:0]            {prefix}PPROT,")
        lines.append(f"    input  logic [{data_width-1}:0] {prefix}PRDATA,")
        lines.append(f"    input  logic                  {prefix}PSLVERR,")
        lines.append(f"    input  logic                  {prefix}PREADY")

        return lines

    def _generate_axil_external_ports(self) -> List[str]:
        """Generate AXI4-Lite external slave ports."""
        lines = []
        prefix = self.slave.prefix

        # AXI4-Lite signals (adapter is master to slave)
        addr_width = self.slave.addr_width
        data_width = self.slave.data_width
        strb_width = data_width // 8

        # Determine which channels to generate
        has_write = self.channels in ["wr", "rw"]
        has_read = self.channels in ["rd", "rw"]

        # Track if we need comma after signals
        signals_added = False

        if has_write:
            # Write Address Channel
            lines.append(f"    output logic [{addr_width-1}:0] {prefix}awaddr,")
            lines.append(f"    output logic [2:0]            {prefix}awprot,")
            lines.append(f"    output logic                  {prefix}awvalid,")
            lines.append(f"    input  logic                  {prefix}awready,")
            lines.append(f"    // Write Data Channel")
            lines.append(f"    output logic [{data_width-1}:0] {prefix}wdata,")
            lines.append(f"    output logic [{strb_width-1}:0] {prefix}wstrb,")
            lines.append(f"    output logic                  {prefix}wvalid,")
            lines.append(f"    input  logic                  {prefix}wready,")
            lines.append(f"    // Write Response Channel")
            lines.append(f"    input  logic [1:0]            {prefix}bresp,")
            lines.append(f"    input  logic                  {prefix}bvalid,")
            # Comma only if there are read channels following
            if has_read:
                lines.append(f"    output logic                  {prefix}bready,")
            else:
                lines.append(f"    output logic                  {prefix}bready")  # Last signal - no comma
            signals_added = True

        if has_read:
            if signals_added:
                lines.append(f"    // Read Address Channel")
            lines.append(f"    output logic [{addr_width-1}:0] {prefix}araddr,")
            lines.append(f"    output logic [2:0]            {prefix}arprot,")
            lines.append(f"    output logic                  {prefix}arvalid,")
            lines.append(f"    input  logic                  {prefix}arready,")
            lines.append(f"    // Read Data Channel")
            lines.append(f"    input  logic [{data_width-1}:0] {prefix}rdata,")
            lines.append(f"    input  logic [1:0]            {prefix}rresp,")
            lines.append(f"    input  logic                  {prefix}rvalid,")
            lines.append(f"    output logic                  {prefix}rready")  # Last signal - no comma

        return lines

    def _generate_internal_signals(self) -> List[str]:
        """Generate internal signal declarations."""
        return [
            "    // Internal signals (if needed for protocol conversion)",
            ""
        ]

    def _generate_axi4_timing_wrapper(self) -> List[str]:
        """Generate axi4_master_wr/rd timing wrapper instantiation."""
        lines = []

        crossbar_prefix = f"xbar_{self.slave.name}_axi_"
        slave_prefix = self.slave.prefix

        if self.channels in ["wr", "rw"]:
            lines.extend(self._generate_master_wr_wrapper(crossbar_prefix, slave_prefix))

        if self.channels in ["rd", "rw"]:
            lines.extend(self._generate_master_rd_wrapper(crossbar_prefix, slave_prefix))

        return lines

    def _generate_master_wr_wrapper(self, crossbar_prefix: str, slave_prefix: str) -> List[str]:
        """Generate axi4_master_wr wrapper instance."""
        lines = []

        lines.append("    // AXI4 Master Write Timing Wrapper")
        lines.append("    axi4_master_wr #(")
        lines.append(f"        .SKID_DEPTH_AW({self.skid_depth_aw}),")
        lines.append(f"        .SKID_DEPTH_W({self.skid_depth_w}),")
        lines.append(f"        .SKID_DEPTH_B({self.skid_depth_b}),")
        lines.append(f"        .AXI_ID_WIDTH(4),")
        lines.append(f"        .AXI_ADDR_WIDTH({self.slave.addr_width}),")
        lines.append(f"        .AXI_DATA_WIDTH({self.slave.data_width}),")
        lines.append(f"        .AXI_USER_WIDTH(1)")
        lines.append("    ) u_master_wr (")
        lines.append("        .aclk(aclk),")
        lines.append("        .aresetn(aresetn),")
        lines.append("")
        lines.append("        // Slave interface (from crossbar)")
        lines.append(f"        .fub_axi_awid({crossbar_prefix}awid),")
        lines.append(f"        .fub_axi_awaddr({crossbar_prefix}awaddr),")
        lines.append(f"        .fub_axi_awlen({crossbar_prefix}awlen),")
        lines.append(f"        .fub_axi_awsize({crossbar_prefix}awsize),")
        lines.append(f"        .fub_axi_awburst({crossbar_prefix}awburst),")
        lines.append(f"        .fub_axi_awlock({crossbar_prefix}awlock),")
        lines.append(f"        .fub_axi_awcache({crossbar_prefix}awcache),")
        lines.append(f"        .fub_axi_awprot({crossbar_prefix}awprot),")
        lines.append(f"        .fub_axi_awqos({crossbar_prefix}awqos),")
        lines.append(f"        .fub_axi_awregion({crossbar_prefix}awregion),")
        lines.append(f"        .fub_axi_awuser({crossbar_prefix}awuser),")
        lines.append(f"        .fub_axi_awvalid({crossbar_prefix}awvalid),")
        lines.append(f"        .fub_axi_awready({crossbar_prefix}awready),")
        lines.append("")
        lines.append(f"        .fub_axi_wdata({crossbar_prefix}wdata),")
        lines.append(f"        .fub_axi_wstrb({crossbar_prefix}wstrb),")
        lines.append(f"        .fub_axi_wlast({crossbar_prefix}wlast),")
        lines.append(f"        .fub_axi_wuser({crossbar_prefix}wuser),")
        lines.append(f"        .fub_axi_wvalid({crossbar_prefix}wvalid),")
        lines.append(f"        .fub_axi_wready({crossbar_prefix}wready),")
        lines.append("")
        lines.append(f"        .fub_axi_bid({crossbar_prefix}bid),")
        lines.append(f"        .fub_axi_bresp({crossbar_prefix}bresp),")
        lines.append(f"        .fub_axi_buser({crossbar_prefix}buser),")
        lines.append(f"        .fub_axi_bvalid({crossbar_prefix}bvalid),")
        lines.append(f"        .fub_axi_bready({crossbar_prefix}bready),")
        lines.append("")
        lines.append("        // Master interface (to external slave)")
        lines.append(f"        .m_axi_awid({slave_prefix}awid),")
        lines.append(f"        .m_axi_awaddr({slave_prefix}awaddr),")
        lines.append(f"        .m_axi_awlen({slave_prefix}awlen),")
        lines.append(f"        .m_axi_awsize({slave_prefix}awsize),")
        lines.append(f"        .m_axi_awburst({slave_prefix}awburst),")
        lines.append(f"        .m_axi_awlock({slave_prefix}awlock),")
        lines.append(f"        .m_axi_awcache({slave_prefix}awcache),")
        lines.append(f"        .m_axi_awprot({slave_prefix}awprot),")
        lines.append(f"        .m_axi_awqos({slave_prefix}awqos),")
        lines.append(f"        .m_axi_awregion({slave_prefix}awregion),")
        lines.append(f"        .m_axi_awuser({slave_prefix}awuser),")
        lines.append(f"        .m_axi_awvalid({slave_prefix}awvalid),")
        lines.append(f"        .m_axi_awready({slave_prefix}awready),")
        lines.append("")
        lines.append(f"        .m_axi_wdata({slave_prefix}wdata),")
        lines.append(f"        .m_axi_wstrb({slave_prefix}wstrb),")
        lines.append(f"        .m_axi_wlast({slave_prefix}wlast),")
        lines.append(f"        .m_axi_wuser({slave_prefix}wuser),")
        lines.append(f"        .m_axi_wvalid({slave_prefix}wvalid),")
        lines.append(f"        .m_axi_wready({slave_prefix}wready),")
        lines.append("")
        lines.append(f"        .m_axi_bid({slave_prefix}bid),")
        lines.append(f"        .m_axi_bresp({slave_prefix}bresp),")
        lines.append(f"        .m_axi_buser({slave_prefix}buser),")
        lines.append(f"        .m_axi_bvalid({slave_prefix}bvalid),")
        lines.append(f"        .m_axi_bready({slave_prefix}bready),")
        lines.append("")
        lines.append("        // Status output (unconnected - for clock gating)")
        lines.append("        .busy()")
        lines.append("    );")
        lines.append("")

        return lines

    def _generate_master_rd_wrapper(self, crossbar_prefix: str, slave_prefix: str) -> List[str]:
        """Generate axi4_master_rd wrapper instance."""
        lines = []

        lines.append("    // AXI4 Master Read Timing Wrapper")
        lines.append("    axi4_master_rd #(")
        lines.append(f"        .SKID_DEPTH_AR({self.skid_depth_ar}),")
        lines.append(f"        .SKID_DEPTH_R({self.skid_depth_r}),")
        lines.append(f"        .AXI_ID_WIDTH(4),")
        lines.append(f"        .AXI_ADDR_WIDTH({self.slave.addr_width}),")
        lines.append(f"        .AXI_DATA_WIDTH({self.slave.data_width}),")
        lines.append(f"        .AXI_USER_WIDTH(1)")
        lines.append("    ) u_master_rd (")
        lines.append("        .aclk(aclk),")
        lines.append("        .aresetn(aresetn),")
        lines.append("")
        lines.append("        // Slave interface (from crossbar)")
        lines.append(f"        .fub_axi_arid({crossbar_prefix}arid),")
        lines.append(f"        .fub_axi_araddr({crossbar_prefix}araddr),")
        lines.append(f"        .fub_axi_arlen({crossbar_prefix}arlen),")
        lines.append(f"        .fub_axi_arsize({crossbar_prefix}arsize),")
        lines.append(f"        .fub_axi_arburst({crossbar_prefix}arburst),")
        lines.append(f"        .fub_axi_arlock({crossbar_prefix}arlock),")
        lines.append(f"        .fub_axi_arcache({crossbar_prefix}arcache),")
        lines.append(f"        .fub_axi_arprot({crossbar_prefix}arprot),")
        lines.append(f"        .fub_axi_arqos({crossbar_prefix}arqos),")
        lines.append(f"        .fub_axi_arregion({crossbar_prefix}arregion),")
        lines.append(f"        .fub_axi_aruser({crossbar_prefix}aruser),")
        lines.append(f"        .fub_axi_arvalid({crossbar_prefix}arvalid),")
        lines.append(f"        .fub_axi_arready({crossbar_prefix}arready),")
        lines.append("")
        lines.append(f"        .fub_axi_rid({crossbar_prefix}rid),")
        lines.append(f"        .fub_axi_rdata({crossbar_prefix}rdata),")
        lines.append(f"        .fub_axi_rresp({crossbar_prefix}rresp),")
        lines.append(f"        .fub_axi_rlast({crossbar_prefix}rlast),")
        lines.append(f"        .fub_axi_ruser({crossbar_prefix}ruser),")
        lines.append(f"        .fub_axi_rvalid({crossbar_prefix}rvalid),")
        lines.append(f"        .fub_axi_rready({crossbar_prefix}rready),")
        lines.append("")
        lines.append("        // Master interface (to external slave)")
        lines.append(f"        .m_axi_arid({slave_prefix}arid),")
        lines.append(f"        .m_axi_araddr({slave_prefix}araddr),")
        lines.append(f"        .m_axi_arlen({slave_prefix}arlen),")
        lines.append(f"        .m_axi_arsize({slave_prefix}arsize),")
        lines.append(f"        .m_axi_arburst({slave_prefix}arburst),")
        lines.append(f"        .m_axi_arlock({slave_prefix}arlock),")
        lines.append(f"        .m_axi_arcache({slave_prefix}arcache),")
        lines.append(f"        .m_axi_arprot({slave_prefix}arprot),")
        lines.append(f"        .m_axi_arqos({slave_prefix}arqos),")
        lines.append(f"        .m_axi_arregion({slave_prefix}arregion),")
        lines.append(f"        .m_axi_aruser({slave_prefix}aruser),")
        lines.append(f"        .m_axi_arvalid({slave_prefix}arvalid),")
        lines.append(f"        .m_axi_arready({slave_prefix}arready),")
        lines.append("")
        lines.append(f"        .m_axi_rid({slave_prefix}rid),")
        lines.append(f"        .m_axi_rdata({slave_prefix}rdata),")
        lines.append(f"        .m_axi_rresp({slave_prefix}rresp),")
        lines.append(f"        .m_axi_rlast({slave_prefix}rlast),")
        lines.append(f"        .m_axi_ruser({slave_prefix}ruser),")
        lines.append(f"        .m_axi_rvalid({slave_prefix}rvalid),")
        lines.append(f"        .m_axi_rready({slave_prefix}rready),")
        lines.append("")
        lines.append("        // Status output (unconnected - for clock gating)")
        lines.append("        .busy()")
        lines.append("    );")
        lines.append("")

        return lines

    def _generate_apb_converter(self) -> List[str]:
        """Generate AXI4-to-APB converter instantiation."""
        lines = []

        # Crossbar interface prefix
        crossbar_prefix = f"xbar_{self.slave.name}_axi_"

        lines.append("    // AXI4-to-APB converter shim")
        lines.append("    axi4_to_apb_shim #(")
        lines.append("        .DEPTH_AW         (2),")
        lines.append("        .DEPTH_W          (4),")
        lines.append("        .DEPTH_B          (2),")
        lines.append("        .DEPTH_AR         (2),")
        lines.append("        .DEPTH_R          (4),")
        lines.append("        .SIDE_DEPTH       (4),")
        lines.append("        .APB_CMD_DEPTH    (4),")
        lines.append("        .APB_RSP_DEPTH    (4),")
        lines.append(f"        .AXI_ID_WIDTH     ({self.id_width}),")
        lines.append(f"        .AXI_ADDR_WIDTH   ({self.slave.addr_width}),")
        lines.append(f"        .AXI_DATA_WIDTH   ({self.data_width}),")  # Crossbar internal width
        lines.append("        .AXI_USER_WIDTH   (1),")
        lines.append(f"        .APB_ADDR_WIDTH   ({self.slave.addr_width}),")
        lines.append(f"        .APB_DATA_WIDTH   ({self.slave.data_width})")  # APB slave width
        lines.append(f"    ) u_{self.slave.name}_apb_converter (")
        lines.append("        .aclk             (aclk),")
        lines.append("        .aresetn          (aresetn),")
        lines.append("        .pclk             (aclk),     // Same clock domain")
        lines.append("        .presetn          (aresetn),  // Same reset")
        lines.append("")

        # AXI4 slave interface (from crossbar) - connect or tie off channels
        if self.has_write:
            lines.append("        // AXI4 write address channel (from crossbar)")
            lines.append(f"        .s_axi_awid       ({crossbar_prefix}awid),")
            lines.append(f"        .s_axi_awaddr     ({crossbar_prefix}awaddr),")
            lines.append(f"        .s_axi_awlen      ({crossbar_prefix}awlen),")
            lines.append(f"        .s_axi_awsize     ({crossbar_prefix}awsize),")
            lines.append(f"        .s_axi_awburst    ({crossbar_prefix}awburst),")
            lines.append(f"        .s_axi_awlock     ({crossbar_prefix}awlock),")
            lines.append(f"        .s_axi_awcache    ({crossbar_prefix}awcache),")
            lines.append(f"        .s_axi_awprot     ({crossbar_prefix}awprot),")
            lines.append(f"        .s_axi_awqos      ({crossbar_prefix}awqos),")
            lines.append(f"        .s_axi_awregion   ({crossbar_prefix}awregion),")
            lines.append(f"        .s_axi_awuser     ({crossbar_prefix}awuser),")
            lines.append(f"        .s_axi_awvalid    ({crossbar_prefix}awvalid),")
            lines.append(f"        .s_axi_awready    ({crossbar_prefix}awready),")
            lines.append("")
            lines.append("        // AXI4 write data channel")
            lines.append(f"        .s_axi_wdata      ({crossbar_prefix}wdata),")
            lines.append(f"        .s_axi_wstrb      ({crossbar_prefix}wstrb),")
            lines.append(f"        .s_axi_wlast      ({crossbar_prefix}wlast),")
            lines.append(f"        .s_axi_wuser      ({crossbar_prefix}wuser),")
            lines.append(f"        .s_axi_wvalid     ({crossbar_prefix}wvalid),")
            lines.append(f"        .s_axi_wready     ({crossbar_prefix}wready),")
            lines.append("")
            lines.append("        // AXI4 write response channel")
            lines.append(f"        .s_axi_bid        ({crossbar_prefix}bid),")
            lines.append(f"        .s_axi_bresp      ({crossbar_prefix}bresp),")
            lines.append(f"        .s_axi_buser      ({crossbar_prefix}buser),")
            lines.append(f"        .s_axi_bvalid     ({crossbar_prefix}bvalid),")
            lines.append(f"        .s_axi_bready     ({crossbar_prefix}bready),")
            lines.append("")
        else:
            # Tie off write channels for read-only bridge
            lines.append("        // Write channels tied off (read-only bridge)")
            lines.append(f"        .s_axi_awid       ({self.id_width}'b0),")
            lines.append(f"        .s_axi_awaddr     ({self.slave.addr_width}'b0),")
            lines.append(f"        .s_axi_awlen      (8'b0),")
            lines.append(f"        .s_axi_awsize     (3'b0),")
            lines.append(f"        .s_axi_awburst    (2'b0),")
            lines.append(f"        .s_axi_awlock     (1'b0),")
            lines.append(f"        .s_axi_awcache    (4'b0),")
            lines.append(f"        .s_axi_awprot     (3'b0),")
            lines.append(f"        .s_axi_awqos      (4'b0),")
            lines.append(f"        .s_axi_awregion   (4'b0),")
            lines.append(f"        .s_axi_awuser     (1'b0),")
            lines.append(f"        .s_axi_awvalid    (1'b0),")
            lines.append(f"        .s_axi_awready    (),  // Unconnected")
            lines.append("")
            # Get data width and strb width
            strb_width = self.data_width // 8
            lines.append(f"        .s_axi_wdata      ({self.data_width}'b0),")
            lines.append(f"        .s_axi_wstrb      ({strb_width}'b0),")
            lines.append(f"        .s_axi_wlast      (1'b0),")
            lines.append(f"        .s_axi_wuser      (1'b0),")
            lines.append(f"        .s_axi_wvalid     (1'b0),")
            lines.append(f"        .s_axi_wready     (),  // Unconnected")
            lines.append("")
            lines.append(f"        .s_axi_bid        (),  // Unconnected")
            lines.append(f"        .s_axi_bresp      (),  // Unconnected")
            lines.append(f"        .s_axi_buser      (),  // Unconnected")
            lines.append(f"        .s_axi_bvalid     (),  // Unconnected")
            lines.append(f"        .s_axi_bready     (1'b0),")
            lines.append("")

        if self.has_read:
            lines.append("        // AXI4 read address channel (from crossbar)")
            lines.append(f"        .s_axi_arid       ({crossbar_prefix}arid),")
            lines.append(f"        .s_axi_araddr     ({crossbar_prefix}araddr),")
            lines.append(f"        .s_axi_arlen      ({crossbar_prefix}arlen),")
            lines.append(f"        .s_axi_arsize     ({crossbar_prefix}arsize),")
            lines.append(f"        .s_axi_arburst    ({crossbar_prefix}arburst),")
            lines.append(f"        .s_axi_arlock     ({crossbar_prefix}arlock),")
            lines.append(f"        .s_axi_arcache    ({crossbar_prefix}arcache),")
            lines.append(f"        .s_axi_arprot     ({crossbar_prefix}arprot),")
            lines.append(f"        .s_axi_arqos      ({crossbar_prefix}arqos),")
            lines.append(f"        .s_axi_arregion   ({crossbar_prefix}arregion),")
            lines.append(f"        .s_axi_aruser     ({crossbar_prefix}aruser),")
            lines.append(f"        .s_axi_arvalid    ({crossbar_prefix}arvalid),")
            lines.append(f"        .s_axi_arready    ({crossbar_prefix}arready),")
            lines.append("")
            lines.append("        // AXI4 read data channel")
            lines.append(f"        .s_axi_rid        ({crossbar_prefix}rid),")
            lines.append(f"        .s_axi_rdata      ({crossbar_prefix}rdata),")
            lines.append(f"        .s_axi_rresp      ({crossbar_prefix}rresp),")
            lines.append(f"        .s_axi_rlast      ({crossbar_prefix}rlast),")
            lines.append(f"        .s_axi_ruser      ({crossbar_prefix}ruser),")
            lines.append(f"        .s_axi_rvalid     ({crossbar_prefix}rvalid),")
            lines.append(f"        .s_axi_rready     ({crossbar_prefix}rready),")
            lines.append("")
        else:
            # Tie off read channels for write-only bridge
            lines.append("        // Read channels tied off (write-only bridge)")
            lines.append(f"        .s_axi_arid       ({self.id_width}'b0),")
            lines.append(f"        .s_axi_araddr     ({self.slave.addr_width}'b0),")
            lines.append(f"        .s_axi_arlen      (8'b0),")
            lines.append(f"        .s_axi_arsize     (3'b0),")
            lines.append(f"        .s_axi_arburst    (2'b0),")
            lines.append(f"        .s_axi_arlock     (1'b0),")
            lines.append(f"        .s_axi_arcache    (4'b0),")
            lines.append(f"        .s_axi_arprot     (3'b0),")
            lines.append(f"        .s_axi_arqos      (4'b0),")
            lines.append(f"        .s_axi_arregion   (4'b0),")
            lines.append(f"        .s_axi_aruser     (1'b0),")
            lines.append(f"        .s_axi_arvalid    (1'b0),")
            lines.append(f"        .s_axi_arready    (),  // Unconnected")
            lines.append("")
            lines.append(f"        .s_axi_rid        (),  // Unconnected")
            lines.append(f"        .s_axi_rdata      (),  // Unconnected")
            lines.append(f"        .s_axi_rresp      (),  // Unconnected")
            lines.append(f"        .s_axi_rlast      (),  // Unconnected")
            lines.append(f"        .s_axi_ruser      (),  // Unconnected")
            lines.append(f"        .s_axi_rvalid     (),  // Unconnected")
            lines.append(f"        .s_axi_rready     (1'b0),")
            lines.append("")

        # APB master interface (to external slave) - use external prefix
        # Note: axi4_to_apb_shim uses uppercase APB signal names (PSEL, PADDR, etc.)
        # Connect to top-level APB ports (also uppercase to match APB standard)
        lines.append("        // APB master interface (to external slave)")
        lines.append(f"        .m_apb_PSEL       ({self.slave.prefix}PSEL),")
        lines.append(f"        .m_apb_PADDR      ({self.slave.prefix}PADDR),")
        lines.append(f"        .m_apb_PENABLE    ({self.slave.prefix}PENABLE),")
        lines.append(f"        .m_apb_PWRITE     ({self.slave.prefix}PWRITE),")
        lines.append(f"        .m_apb_PWDATA     ({self.slave.prefix}PWDATA),")
        lines.append(f"        .m_apb_PSTRB      ({self.slave.prefix}PSTRB),")
        lines.append(f"        .m_apb_PPROT      ({self.slave.prefix}PPROT),")
        lines.append(f"        .m_apb_PRDATA     ({self.slave.prefix}PRDATA),")
        lines.append(f"        .m_apb_PSLVERR    ({self.slave.prefix}PSLVERR),")
        lines.append(f"        .m_apb_PREADY     ({self.slave.prefix}PREADY)")
        lines.append("    );")
        lines.append("")
        return lines

    def _generate_axil_converter(self) -> List[str]:
        """Generate AXI4-to-AXI4-Lite converter instantiation."""
        lines = []

        # Crossbar interface prefix
        crossbar_prefix = f"xbar_{self.slave.name}_axi_"

        lines.append("    // AXI4-to-AXI4-Lite converter")

        # Determine which converter to use based on channels
        if self.channels == "rd":
            lines.append("    axi4_to_axil4_rd #(")
        elif self.channels == "wr":
            lines.append("    axi4_to_axil4_wr #(")
        else:  # rw - would need both converters or a combined one
            lines.append("    // TODO: Read-write AXI4-Lite conversion requires both converters")
            return lines

        lines.append(f"        .AXI_ID_WIDTH     ({self.id_width}),")
        lines.append(f"        .AXI_ADDR_WIDTH   ({self.slave.addr_width}),")
        lines.append(f"        .AXI_DATA_WIDTH   ({self.data_width}),")  # Crossbar internal width (slave's native width)
        lines.append("        .AXI_USER_WIDTH   (1),")
        lines.append("        .SKID_DEPTH_AR    (2),")
        lines.append("        .SKID_DEPTH_R     (4)")
        lines.append(f"    ) u_{self.slave.name}_axil_converter (")
        lines.append("        .aclk             (aclk),")
        lines.append("        .aresetn          (aresetn),")
        lines.append("")

        # AXI4 slave interface (from crossbar) - connect or tie off channels
        if self.has_write:
            # Write channels for write converter
            lines.append("        // AXI4 write address channel (from crossbar)")
            lines.append(f"        .s_axi_awid       ({crossbar_prefix}awid),")
            lines.append(f"        .s_axi_awaddr     ({crossbar_prefix}awaddr),")
            lines.append(f"        .s_axi_awlen      ({crossbar_prefix}awlen),")
            lines.append(f"        .s_axi_awsize     ({crossbar_prefix}awsize),")
            lines.append(f"        .s_axi_awburst    ({crossbar_prefix}awburst),")
            lines.append(f"        .s_axi_awlock     ({crossbar_prefix}awlock),")
            lines.append(f"        .s_axi_awcache    ({crossbar_prefix}awcache),")
            lines.append(f"        .s_axi_awprot     ({crossbar_prefix}awprot),")
            lines.append(f"        .s_axi_awqos      ({crossbar_prefix}awqos),")
            lines.append(f"        .s_axi_awregion   ({crossbar_prefix}awregion),")
            lines.append(f"        .s_axi_awuser     ({crossbar_prefix}awuser),")
            lines.append(f"        .s_axi_awvalid    ({crossbar_prefix}awvalid),")
            lines.append(f"        .s_axi_awready    ({crossbar_prefix}awready),")
            lines.append("")
            lines.append("        // AXI4 write data channel")
            lines.append(f"        .s_axi_wdata      ({crossbar_prefix}wdata),")
            lines.append(f"        .s_axi_wstrb      ({crossbar_prefix}wstrb),")
            lines.append(f"        .s_axi_wlast      ({crossbar_prefix}wlast),")
            lines.append(f"        .s_axi_wuser      ({crossbar_prefix}wuser),")
            lines.append(f"        .s_axi_wvalid     ({crossbar_prefix}wvalid),")
            lines.append(f"        .s_axi_wready     ({crossbar_prefix}wready),")
            lines.append("")
            lines.append("        // AXI4 write response channel")
            lines.append(f"        .s_axi_bid        ({crossbar_prefix}bid),")
            lines.append(f"        .s_axi_bresp      ({crossbar_prefix}bresp),")
            lines.append(f"        .s_axi_buser      ({crossbar_prefix}buser),")
            lines.append(f"        .s_axi_bvalid     ({crossbar_prefix}bvalid),")
            lines.append(f"        .s_axi_bready     ({crossbar_prefix}bready),")
            lines.append("")

        if self.has_read:
            # Read channels for read converter
            lines.append("        // AXI4 read address channel (from crossbar)")
            lines.append(f"        .s_axi_arid       ({crossbar_prefix}arid),")
            lines.append(f"        .s_axi_araddr     ({crossbar_prefix}araddr),")
            lines.append(f"        .s_axi_arlen      ({crossbar_prefix}arlen),")
            lines.append(f"        .s_axi_arsize     ({crossbar_prefix}arsize),")
            lines.append(f"        .s_axi_arburst    ({crossbar_prefix}arburst),")
            lines.append(f"        .s_axi_arlock     ({crossbar_prefix}arlock),")
            lines.append(f"        .s_axi_arcache    ({crossbar_prefix}arcache),")
            lines.append(f"        .s_axi_arprot     ({crossbar_prefix}arprot),")
            lines.append(f"        .s_axi_arqos      ({crossbar_prefix}arqos),")
            lines.append(f"        .s_axi_arregion   ({crossbar_prefix}arregion),")
            lines.append(f"        .s_axi_aruser     ({crossbar_prefix}aruser),")
            lines.append(f"        .s_axi_arvalid    ({crossbar_prefix}arvalid),")
            lines.append(f"        .s_axi_arready    ({crossbar_prefix}arready),")
            lines.append("")
            lines.append("        // AXI4 read data channel")
            lines.append(f"        .s_axi_rid        ({crossbar_prefix}rid),")
            lines.append(f"        .s_axi_rdata      ({crossbar_prefix}rdata),")
            lines.append(f"        .s_axi_rresp      ({crossbar_prefix}rresp),")
            lines.append(f"        .s_axi_rlast      ({crossbar_prefix}rlast),")
            lines.append(f"        .s_axi_ruser      ({crossbar_prefix}ruser),")
            lines.append(f"        .s_axi_rvalid     ({crossbar_prefix}rvalid),")
            lines.append(f"        .s_axi_rready     ({crossbar_prefix}rready),")
            lines.append("")

        # AXI4-Lite master interface (to external slave) - use external prefix
        if self.has_write:
            lines.append("        // AXI4-Lite write address channel (to external slave)")
            lines.append(f"        .m_axil_awaddr    ({self.slave.prefix}awaddr),")
            lines.append(f"        .m_axil_awprot    ({self.slave.prefix}awprot),")
            lines.append(f"        .m_axil_awvalid   ({self.slave.prefix}awvalid),")
            lines.append(f"        .m_axil_awready   ({self.slave.prefix}awready),")
            lines.append("")
            lines.append("        // AXI4-Lite write data channel")
            lines.append(f"        .m_axil_wdata     ({self.slave.prefix}wdata),")
            lines.append(f"        .m_axil_wstrb     ({self.slave.prefix}wstrb),")
            lines.append(f"        .m_axil_wvalid    ({self.slave.prefix}wvalid),")
            lines.append(f"        .m_axil_wready    ({self.slave.prefix}wready),")
            lines.append("")
            lines.append("        // AXI4-Lite write response channel")
            lines.append(f"        .m_axil_bresp     ({self.slave.prefix}bresp),")
            lines.append(f"        .m_axil_bvalid    ({self.slave.prefix}bvalid),")
            # Comma only if there are read channels following
            if self.has_read:
                lines.append(f"        .m_axil_bready    ({self.slave.prefix}bready),")
            else:
                lines.append(f"        .m_axil_bready    ({self.slave.prefix}bready)")
            lines.append("")

        if self.has_read:
            lines.append("        // AXI4-Lite read address channel (to external slave)")
            lines.append(f"        .m_axil_araddr    ({self.slave.prefix}araddr),")
            lines.append(f"        .m_axil_arprot    ({self.slave.prefix}arprot),")
            lines.append(f"        .m_axil_arvalid   ({self.slave.prefix}arvalid),")
            lines.append(f"        .m_axil_arready   ({self.slave.prefix}arready),")
            lines.append("")
            lines.append("        // AXI4-Lite read data channel")
            lines.append(f"        .m_axil_rdata     ({self.slave.prefix}rdata),")
            lines.append(f"        .m_axil_rresp     ({self.slave.prefix}rresp),")
            lines.append(f"        .m_axil_rvalid    ({self.slave.prefix}rvalid),")
            lines.append(f"        .m_axil_rready    ({self.slave.prefix}rready)")

        lines.append("    );")
        lines.append("")
        return lines


def main():
    """Test the slave adapter generator."""
    # Test AXI4 slave adapter
    slave = SlaveInfo(
        name="ddr",
        prefix="ddr_axi_",
        base_addr=0x00000000,
        addr_range=0x80000000,
        data_width=32,
        addr_width=32,
        protocol='axi4'
    )

    gen = SlaveAdapterGenerator(
        bridge_name="bridge_1x2_wr",
        slave_config=slave,
        channels="wr"
    )

    print(gen.generate())


if __name__ == "__main__":
    main()
