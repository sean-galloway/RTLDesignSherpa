"""
Bridge Adapter Generator

Generates per-master adapter modules that contain:
- Interface wrapper (timing isolation)
- Address decode logic
- Width converters (or direct passthrough)
- APB protocol converters (for APB slaves)
- Struct-based outputs

Author: RTL Design Sherpa
Date: 2025-11-03
"""

from typing import List, Dict, Tuple
from dataclasses import dataclass
from ..components.apb_shim_adapter import ApbShimAdapter
from ..signal_naming import SignalNaming, Direction, AXI4Channel, AXI4_MASTER_SIGNALS, PortDirection, SignalInfo


@dataclass
class SlaveInfo:
    """Information about a slave port."""
    name: str
    prefix: str  # Signal prefix (e.g., "sram_buffer_s_axi_", "apb_periph_")
    base_addr: int
    addr_range: int
    data_width: int
    addr_width: int  # Address width in bits
    protocol: str = 'axi4'  # Protocol type: 'axi4' or 'apb'
    enable_ooo: bool = False  # Slave supports out-of-order responses (use CAM vs FIFO)


@dataclass
class MasterConfig:
    """Configuration for a master port."""
    name: str
    prefix: str
    data_width: int
    addr_width: int
    id_width: int
    channels: str  # "wr", "rd", or "rw"
    slave_connections: List[int]  # Indices of connected slaves


class AdapterGenerator:
    """
    Generates per-master adapter modules for bridge crossbars.

    Each adapter contains:
    - Timing wrapper (axi4_slave_rd/wr)
    - Address decode (one-hot slave selection)
    - Width converters or direct passthrough
    - Struct-based outputs for clean interface
    """

    def __init__(self, bridge_name: str, num_slaves: int, master_config: MasterConfig, slaves: List[SlaveInfo], all_masters: List[MasterConfig] = None, enable_monitoring: bool = False, master_index: int = 0):
        """
        Initialize adapter generator.

        Args:
            bridge_name: Name of bridge (e.g., "bridge_1x2_wr")
            num_slaves: Total number of slaves in bridge
            master_config: Configuration for this master
            slaves: List of all slave configurations
            all_masters: List of ALL masters in bridge (for LCD calculation)
            enable_monitoring: Use *_mon wrapper versions (default: False)
            master_index: Index of this master in bridge (0, 1, 2, ...) for BRIDGE_ID
        """
        self.bridge_name = bridge_name
        self.num_slaves = num_slaves
        self.master = master_config
        self.slaves = slaves
        self.all_masters = all_masters if all_masters is not None else [master_config]
        self.enable_monitoring = enable_monitoring
        self.master_index = master_index

        # Skid buffer depths (configurable)
        self.skid_depth_aw = 2
        self.skid_depth_ar = 2
        self.skid_depth_w = 4
        self.skid_depth_r = 2
        self.skid_depth_b = 2

    def generate(self) -> str:
        """
        Generate complete adapter module.

        Returns:
            SystemVerilog adapter module source code
        """
        lines = []

        # Header
        lines.extend(self._generate_header())

        # Module declaration
        lines.extend(self._generate_module_declaration())

        # Internal signals
        lines.extend(self._generate_internal_signals())

        # Timing wrapper instantiation
        lines.extend(self._generate_wrapper())

        # Address decode
        lines.extend(self._generate_address_decode())

        # Width adaptation (converter or direct passthrough)
        lines.extend(self._generate_width_adaptation())

        # NOTE: APB protocol conversion is handled at the bridge level,
        # after the crossbar, not in the adapter. The adapter only does
        # timing isolation, address decode, and width conversion.

        # Module end
        lines.append("endmodule : " + self._get_module_name())
        lines.append("")

        return "\n".join(lines)

    def _generate_header(self) -> List[str]:
        """Generate file header."""
        return [
            f"// {self.master.name.upper()} Master Adapter Module",
            "// Generated by: AdapterGenerator",
            f"// Handles timing isolation, address decode, and width conversion for {self.master.name} master",
            "",
            "`timescale 1ns / 1ps",
            "",
            f"import {self.bridge_name}_pkg::*;",
            ""
        ]

    def _generate_module_declaration(self) -> List[str]:
        """Generate module declaration with ports."""
        lines = []
        module_name = self._get_module_name()

        # Module header with parameters
        lines.append(f"module {module_name} #(")
        lines.append(f"    parameter NUM_SLAVES = {self.num_slaves},")

        # Calculate BRIDGE_ID_WIDTH
        num_masters = len(self.all_masters)
        bridge_id_width = max(1, (num_masters - 1).bit_length())  # $clog2(NUM_MASTERS)
        lines.append(f"    parameter BRIDGE_ID = {self.master_index},  // Unique ID for this master")
        lines.append(f"    parameter BRIDGE_ID_WIDTH = {bridge_id_width},")

        if self.master.channels in ["wr", "rw"]:
            lines.append(f"    parameter SKID_DEPTH_AW = {self.skid_depth_aw},")
            lines.append(f"    parameter SKID_DEPTH_W = {self.skid_depth_w},")
            lines.append(f"    parameter SKID_DEPTH_B = {self.skid_depth_b}")
        if self.master.channels in ["rd", "rw"]:
            if self.master.channels == "rw":
                lines.append("    ,")  # Add comma if both wr and rd
            lines.append(f"    parameter SKID_DEPTH_AR = {self.skid_depth_ar},")
            lines.append(f"    parameter SKID_DEPTH_R = {self.skid_depth_r}")

        lines.append(") (")
        lines.append("    input  logic aclk,")
        lines.append("    input  logic aresetn,")
        lines.append("")

        # External AXI interface
        lines.append(f"    // External AXI interface (from {self.master.name} master)")
        lines.extend(self._generate_external_ports())

        # Address decode outputs
        lines.append("")
        lines.append("    // Address decode outputs (full width one-hot)")
        if self.master.channels in ["wr", "rw"]:
            lines.append("    output logic [NUM_SLAVES-1:0] slave_select_aw,")
            lines.append("    output logic [BRIDGE_ID_WIDTH-1:0] bridge_id_aw,")
        if self.master.channels in ["rd", "rw"]:
            lines.append("    output logic [NUM_SLAVES-1:0] slave_select_ar,")
            lines.append("    output logic [BRIDGE_ID_WIDTH-1:0] bridge_id_ar,")

        # Width-specific outputs via structs
        lines.append("")
        lines.append(f"    // {self.master.data_width}b width outputs (to crossbar)")
        lines.extend(self._generate_struct_ports())

        lines.append(");")
        lines.append("")

        return lines

    def _generate_external_ports(self) -> List[str]:
        """
        Generate external AXI port declarations using SignalNaming.

        Uses SignalNaming.get_all_axi4_signals() for consistent naming across
        the entire bridge (top-level, adapters, and crossbar).

        IMPORTANT: Adapter module is an intermediary that receives signals from
        external master and passes them through timing wrapper. Port directions
        are INVERTED from the master's perspective:
        - Request signals (awid, awaddr, etc.): INPUT to adapter (from external master)
        - Response signals (awready, bid, etc.): OUTPUT from adapter (to external master)

        Signal format: <master_name>_axi_<channel><signal>
        Example: cpu_axi_awaddr (NOT cpu_m_axi_awaddr)
        """
        lines = []

        # Width parameters for signal info queries
        width_values = {
            'ID_WIDTH': self.master.id_width,
            'ADDR_WIDTH': 32,  # Global address width
            'DATA_WIDTH': self.master.data_width,
            'STRB_WIDTH': self.master.data_width // 8,
            'USER_WIDTH': 1
        }

        # Determine which channels to generate based on master type
        channels = SignalNaming.channels_from_type(self.master.channels)

        # Get all AXI4 signals using SignalNaming (same as bridge top-level)
        all_signals = SignalNaming.get_all_axi4_signals(
            port_name=self.master.name,  # Use name, not prefix!
            direction=Direction.MASTER,
            channels=channels
        )

        # Generate declarations for each channel with INVERTED directions
        first_channel = True
        for channel, channel_signals in all_signals.items():
            if not first_channel:
                lines.append("")
            first_channel = False

            for sig_name, sig_info in channel_signals:
                # Invert port direction (adapter is intermediary, not the master)
                inverted_direction = PortDirection.OUTPUT if sig_info.direction == PortDirection.INPUT else PortDirection.INPUT

                # Create inverted signal info
                inverted_sig = SignalInfo(
                    name=sig_info.name,
                    direction=inverted_direction,
                    width_expr=sig_info.width_expr,
                    width_param=sig_info.width_param,
                    is_vector=sig_info.is_vector,
                    description=sig_info.description
                )

                # Get complete signal declaration with inverted direction
                declaration = inverted_sig.get_declaration(sig_name, width_values)
                lines.append(f"    {declaration},")

        return lines

    def _generate_struct_ports(self) -> List[str]:
        """
        Generate struct-based output port declarations.

        Creates ports for each unique slave width this master connects to.
        """
        lines = []

        # Get all unique slave widths
        slave_widths = self._get_connected_slave_widths()

        # Generate ports for each width
        for i, width in enumerate(slave_widths):
            suffix = f"{width}b"
            is_last_width = (i == len(slave_widths) - 1)

            # AW channel
            if self.master.channels in ["wr", "rw"]:
                lines.append(f"    output axi4_aw_t     {self.master.name}_{suffix}_aw,")
                lines.append(f"    output logic         {self.master.name}_{suffix}_awvalid,")
                lines.append(f"    input  logic         {self.master.name}_{suffix}_awready,")
                lines.append("")

            # W channel
            if self.master.channels in ["wr", "rw"]:
                lines.append(f"    output axi4_w_{suffix}_t  {self.master.name}_{suffix}_w,")
                lines.append(f"    output logic         {self.master.name}_{suffix}_wvalid,")
                lines.append(f"    input  logic         {self.master.name}_{suffix}_wready,")
                lines.append("")

            # B channel
            if self.master.channels in ["wr", "rw"]:
                lines.append(f"    input  axi4_b_t      {self.master.name}_{suffix}_b,")
                lines.append(f"    input  logic         {self.master.name}_{suffix}_bvalid,")
                # Add comma if not last port
                if self.master.channels == "wr" and is_last_width:
                    lines.append(f"    output logic         {self.master.name}_{suffix}_bready")
                else:
                    lines.append(f"    output logic         {self.master.name}_{suffix}_bready,")
                    if self.master.channels == "wr" and not is_last_width:
                        lines.append("")  # Blank line between widths

            # AR channel
            if self.master.channels in ["rd", "rw"]:
                if self.master.channels == "rw":
                    lines.append("")
                lines.append(f"    output axi4_ar_t     {self.master.name}_{suffix}_ar,")
                lines.append(f"    output logic         {self.master.name}_{suffix}_arvalid,")
                lines.append(f"    input  logic         {self.master.name}_{suffix}_arready,")
                lines.append("")

            # R channel
            if self.master.channels in ["rd", "rw"]:
                lines.append(f"    input  axi4_r_{suffix}_t  {self.master.name}_{suffix}_r,")
                lines.append(f"    input  logic         {self.master.name}_{suffix}_rvalid,")
                # Add comma if not last port
                if is_last_width:
                    lines.append(f"    output logic         {self.master.name}_{suffix}_rready")
                else:
                    lines.append(f"    output logic         {self.master.name}_{suffix}_rready,")
                    lines.append("")  # Blank line between widths

        return lines

    def _generate_internal_signals(self) -> List[str]:
        """Generate internal signal declarations (fub_axi_*)."""
        lines = []
        id_width = self.master.id_width
        addr_width = 32  # Use global 32-bit address width
        data_width = self.master.data_width
        strb_width = data_width // 8

        lines.append("    // ================================================================")
        lines.append("    // Localparams")
        lines.append("    // ================================================================")
        lines.append(f"    localparam ADDR_WIDTH = {addr_width};")
        lines.append(f"    localparam DATA_WIDTH = {data_width};")
        lines.append(f"    localparam ID_WIDTH = {id_width};")
        lines.append("")
        lines.append("    // ================================================================")
        lines.append("    // Internal signals after wrapper (timing isolation)")
        lines.append(f"    // Note: ID width matches external ({id_width}-bit)")
        lines.append("    // ================================================================")

        # Write channels
        if self.master.channels in ["wr", "rw"]:
            lines.append(f"    logic [{id_width-1}:0]   fub_axi_awid;")
            lines.append(f"    logic [{addr_width-1}:0]  fub_axi_awaddr;")
            lines.append("    logic [7:0]   fub_axi_awlen;")
            lines.append("    logic [2:0]   fub_axi_awsize;")
            lines.append("    logic [1:0]   fub_axi_awburst;")
            lines.append("    logic         fub_axi_awlock;")
            lines.append("    logic [3:0]   fub_axi_awcache;")
            lines.append("    logic [2:0]   fub_axi_awprot;")
            lines.append("    logic         fub_axi_awvalid;")
            lines.append("    logic         fub_axi_awready;")
            lines.append("")

            lines.append(f"    logic [{data_width-1}:0]  fub_axi_wdata;")
            lines.append(f"    logic [{strb_width-1}:0]   fub_axi_wstrb;")
            lines.append("    logic         fub_axi_wlast;")
            lines.append("    logic         fub_axi_wvalid;")
            lines.append("    logic         fub_axi_wready;")
            lines.append("")

            lines.append(f"    logic [{id_width-1}:0]   fub_axi_bid;")
            lines.append("    logic [1:0]   fub_axi_bresp;")
            lines.append("    logic         fub_axi_bvalid;")
            lines.append("    logic         fub_axi_bready;")
            lines.append("")

        # Read channels
        if self.master.channels in ["rd", "rw"]:
            lines.append(f"    logic [{id_width-1}:0]   fub_axi_arid;")
            lines.append(f"    logic [{addr_width-1}:0]  fub_axi_araddr;")
            lines.append("    logic [7:0]   fub_axi_arlen;")
            lines.append("    logic [2:0]   fub_axi_arsize;")
            lines.append("    logic [1:0]   fub_axi_arburst;")
            lines.append("    logic         fub_axi_arlock;")
            lines.append("    logic [3:0]   fub_axi_arcache;")
            lines.append("    logic [2:0]   fub_axi_arprot;")
            lines.append("    logic         fub_axi_arvalid;")
            lines.append("    logic         fub_axi_arready;")
            lines.append("")

            lines.append(f"    logic [{id_width-1}:0]   fub_axi_rid;")
            lines.append(f"    logic [{data_width-1}:0]  fub_axi_rdata;")
            lines.append("    logic [1:0]   fub_axi_rresp;")
            lines.append("    logic         fub_axi_rlast;")
            lines.append("    logic         fub_axi_rvalid;")
            lines.append("    logic         fub_axi_rready;")
            lines.append("")

        # Wrapper busy signals
        if self.master.channels in ["wr", "rw"]:
            lines.append("    logic         wrapper_wr_busy;")
        if self.master.channels in ["rd", "rw"]:
            lines.append("    logic         wrapper_rd_busy;")
        lines.append("")

        return lines

    def _generate_wrapper(self) -> List[str]:
        """
        Generate timing wrapper instantiation.

        Signal names must match what was generated in _generate_external_ports().
        Uses master.name to build correct signal names (not prefix).
        """
        lines = []

        # Build signal prefix using master name (consistent with _generate_external_ports)
        # Format: <master_name>_axi_ (e.g., "cpu_axi_")
        signal_prefix = f"{self.master.name}_axi_"

        id_width = self.master.id_width
        addr_width = 32  # Use global 32-bit address width
        data_width = self.master.data_width

        # Determine wrapper module names (standard or monitoring)
        wr_wrapper_name = "axi4_slave_wr_mon" if self.enable_monitoring else "axi4_slave_wr"
        rd_wrapper_name = "axi4_slave_rd_mon" if self.enable_monitoring else "axi4_slave_rd"

        # Write wrapper
        if self.master.channels in ["wr", "rw"]:
            lines.append("    // ================================================================")
            lines.append(f"    // Timing isolation wrapper ({wr_wrapper_name})")
            lines.append("    // ================================================================")
            lines.append(f"    {wr_wrapper_name} #(")
            lines.append("        .SKID_DEPTH_AW(SKID_DEPTH_AW),")
            lines.append("        .SKID_DEPTH_W(SKID_DEPTH_W),")
            lines.append("        .SKID_DEPTH_B(SKID_DEPTH_B),")
            lines.append(f"        .AXI_ID_WIDTH({id_width}),")
            lines.append(f"        .AXI_ADDR_WIDTH({addr_width}),")
            lines.append(f"        .AXI_DATA_WIDTH({data_width}),")
            lines.append("        .AXI_USER_WIDTH(1)")
            lines.append("    ) u_timing_wrapper_wr (")
            lines.append("        .aclk(aclk),")
            lines.append("        .aresetn(aresetn),")
            lines.append("")
            lines.append("        // External boundary (slave side - accepts from master)")
            lines.append(f"        .s_axi_awid({signal_prefix}awid),")
            lines.append(f"        .s_axi_awaddr({signal_prefix}awaddr),")
            lines.append(f"        .s_axi_awlen({signal_prefix}awlen),")
            lines.append(f"        .s_axi_awsize({signal_prefix}awsize),")
            lines.append(f"        .s_axi_awburst({signal_prefix}awburst),")
            lines.append(f"        .s_axi_awlock({signal_prefix}awlock),")
            lines.append(f"        .s_axi_awcache({signal_prefix}awcache),")
            lines.append(f"        .s_axi_awprot({signal_prefix}awprot),")
            lines.append(f"        .s_axi_awqos({signal_prefix}awqos),")
            lines.append(f"        .s_axi_awregion({signal_prefix}awregion),")
            lines.append(f"        .s_axi_awuser({signal_prefix}awuser),")
            lines.append(f"        .s_axi_awvalid({signal_prefix}awvalid),")
            lines.append(f"        .s_axi_awready({signal_prefix}awready),")
            lines.append("")
            lines.append(f"        .s_axi_wdata({signal_prefix}wdata),")
            lines.append(f"        .s_axi_wstrb({signal_prefix}wstrb),")
            lines.append(f"        .s_axi_wlast({signal_prefix}wlast),")
            lines.append(f"        .s_axi_wuser({signal_prefix}wuser),")
            lines.append(f"        .s_axi_wvalid({signal_prefix}wvalid),")
            lines.append(f"        .s_axi_wready({signal_prefix}wready),")
            lines.append("")
            lines.append(f"        .s_axi_bid({signal_prefix}bid),")
            lines.append(f"        .s_axi_bresp({signal_prefix}bresp),")
            lines.append(f"        .s_axi_buser({signal_prefix}buser),")
            lines.append(f"        .s_axi_bvalid({signal_prefix}bvalid),")
            lines.append(f"        .s_axi_bready({signal_prefix}bready),")
            lines.append("")
            lines.append("        // Internal crossbar (master side - outputs to converter)")
            lines.append("        .fub_axi_awid(fub_axi_awid),")
            lines.append("        .fub_axi_awaddr(fub_axi_awaddr),")
            lines.append("        .fub_axi_awlen(fub_axi_awlen),")
            lines.append("        .fub_axi_awsize(fub_axi_awsize),")
            lines.append("        .fub_axi_awburst(fub_axi_awburst),")
            lines.append("        .fub_axi_awlock(fub_axi_awlock),")
            lines.append("        .fub_axi_awcache(fub_axi_awcache),")
            lines.append("        .fub_axi_awprot(fub_axi_awprot),")
            lines.append("        .fub_axi_awqos(),")
            lines.append("        .fub_axi_awregion(),")
            lines.append("        .fub_axi_awuser(),")
            lines.append("        .fub_axi_awvalid(fub_axi_awvalid),")
            lines.append("        .fub_axi_awready(fub_axi_awready),")
            lines.append("")
            lines.append("        .fub_axi_wdata(fub_axi_wdata),")
            lines.append("        .fub_axi_wstrb(fub_axi_wstrb),")
            lines.append("        .fub_axi_wlast(fub_axi_wlast),")
            lines.append("        .fub_axi_wuser(),")
            lines.append("        .fub_axi_wvalid(fub_axi_wvalid),")
            lines.append("        .fub_axi_wready(fub_axi_wready),")
            lines.append("")
            lines.append("        .fub_axi_bid(fub_axi_bid),")
            lines.append("        .fub_axi_bresp(fub_axi_bresp),")
            lines.append("        .fub_axi_buser(1'b0),")
            lines.append("        .fub_axi_bvalid(fub_axi_bvalid),")
            lines.append("        .fub_axi_bready(fub_axi_bready),")
            lines.append("")
            lines.append("        .busy(wrapper_wr_busy)")
            lines.append("    );")
            lines.append("")

        # Read wrapper
        if self.master.channels in ["rd", "rw"]:
            lines.append("    // ================================================================")
            lines.append(f"    // Timing isolation wrapper ({rd_wrapper_name})")
            lines.append("    // ================================================================")
            lines.append(f"    {rd_wrapper_name} #(")
            lines.append("        .SKID_DEPTH_AR(SKID_DEPTH_AR),")
            lines.append("        .SKID_DEPTH_R(SKID_DEPTH_R),")
            lines.append(f"        .AXI_ID_WIDTH({id_width}),")
            lines.append(f"        .AXI_ADDR_WIDTH({addr_width}),")
            lines.append(f"        .AXI_DATA_WIDTH({data_width}),")
            lines.append("        .AXI_USER_WIDTH(1)")
            lines.append("    ) u_timing_wrapper_rd (")
            lines.append("        .aclk(aclk),")
            lines.append("        .aresetn(aresetn),")
            lines.append("")
            lines.append("        // External boundary (slave side - accepts from master)")
            lines.append(f"        .s_axi_arid({signal_prefix}arid),")
            lines.append(f"        .s_axi_araddr({signal_prefix}araddr),")
            lines.append(f"        .s_axi_arlen({signal_prefix}arlen),")
            lines.append(f"        .s_axi_arsize({signal_prefix}arsize),")
            lines.append(f"        .s_axi_arburst({signal_prefix}arburst),")
            lines.append(f"        .s_axi_arlock({signal_prefix}arlock),")
            lines.append(f"        .s_axi_arcache({signal_prefix}arcache),")
            lines.append(f"        .s_axi_arprot({signal_prefix}arprot),")
            lines.append(f"        .s_axi_arqos({signal_prefix}arqos),")
            lines.append(f"        .s_axi_arregion({signal_prefix}arregion),")
            lines.append(f"        .s_axi_aruser({signal_prefix}aruser),")
            lines.append(f"        .s_axi_arvalid({signal_prefix}arvalid),")
            lines.append(f"        .s_axi_arready({signal_prefix}arready),")
            lines.append("")
            lines.append(f"        .s_axi_rid({signal_prefix}rid),")
            lines.append(f"        .s_axi_rdata({signal_prefix}rdata),")
            lines.append(f"        .s_axi_rresp({signal_prefix}rresp),")
            lines.append(f"        .s_axi_rlast({signal_prefix}rlast),")
            lines.append(f"        .s_axi_ruser({signal_prefix}ruser),")
            lines.append(f"        .s_axi_rvalid({signal_prefix}rvalid),")
            lines.append(f"        .s_axi_rready({signal_prefix}rready),")
            lines.append("")
            lines.append("        // Internal crossbar (master side - outputs to converter)")
            lines.append("        .fub_axi_arid(fub_axi_arid),")
            lines.append("        .fub_axi_araddr(fub_axi_araddr),")
            lines.append("        .fub_axi_arlen(fub_axi_arlen),")
            lines.append("        .fub_axi_arsize(fub_axi_arsize),")
            lines.append("        .fub_axi_arburst(fub_axi_arburst),")
            lines.append("        .fub_axi_arlock(fub_axi_arlock),")
            lines.append("        .fub_axi_arcache(fub_axi_arcache),")
            lines.append("        .fub_axi_arprot(fub_axi_arprot),")
            lines.append("        .fub_axi_arqos(),")
            lines.append("        .fub_axi_arregion(),")
            lines.append("        .fub_axi_aruser(),")
            lines.append("        .fub_axi_arvalid(fub_axi_arvalid),")
            lines.append("        .fub_axi_arready(fub_axi_arready),")
            lines.append("")
            lines.append("        .fub_axi_rid(fub_axi_rid),")
            lines.append("        .fub_axi_rdata(fub_axi_rdata),")
            lines.append("        .fub_axi_rresp(fub_axi_rresp),")
            lines.append("        .fub_axi_rlast(fub_axi_rlast),")
            lines.append("        .fub_axi_ruser(1'b0),")
            lines.append("        .fub_axi_rvalid(fub_axi_rvalid),")
            lines.append("        .fub_axi_rready(fub_axi_rready),")
            lines.append("")
            lines.append("        .busy(wrapper_rd_busy)")
            lines.append("    );")
            lines.append("")

        return lines

    def _generate_address_decode(self) -> List[str]:
        """Generate address decode logic."""
        lines = []

        # Write address decode
        if self.master.channels in ["wr", "rw"]:
            lines.append("    // ================================================================")
            lines.append("    // Address decode (slave selection) - Write")
            lines.extend(self._generate_decode_comment())
            lines.append("    // ================================================================")
            lines.append("    always_comb begin")
            lines.append("        slave_select_aw = '0;")
            lines.extend(self._generate_decode_logic("fub_axi_awaddr", "slave_select_aw"))
            lines.append("    end")
            lines.append("")
            lines.append("    // Bridge ID for write channel (constant - tied to BRIDGE_ID parameter)")
            lines.append(f"    assign bridge_id_aw = BRIDGE_ID_WIDTH'(BRIDGE_ID);")
            lines.append("")

        # Read address decode
        if self.master.channels in ["rd", "rw"]:
            lines.append("    // ================================================================")
            lines.append("    // Address decode (slave selection) - Read")
            lines.extend(self._generate_decode_comment())
            lines.append("    // ================================================================")
            lines.append("    always_comb begin")
            lines.append("        slave_select_ar = '0;")
            lines.extend(self._generate_decode_logic("fub_axi_araddr", "slave_select_ar"))
            lines.append("    end")
            lines.append("")
            lines.append("    // Bridge ID for read channel (constant - tied to BRIDGE_ID parameter)")
            lines.append(f"    assign bridge_id_ar = BRIDGE_ID_WIDTH'(BRIDGE_ID);")
            lines.append("")

        return lines

    def _generate_decode_comment(self) -> List[str]:
        """Generate comment listing slave address ranges."""
        lines = []
        for idx in self.master.slave_connections:
            slave = self.slaves[idx]
            lines.append(f"    // Slave {idx} ({slave.name}): 0x{slave.base_addr:08X} - 0x{slave.base_addr + slave.addr_range - 1:08X}")
        return lines

    def _generate_decode_logic(self, addr_signal: str, select_signal: str) -> List[str]:
        """Generate address decode logic for one channel."""
        lines = []
        addr_width = 32  # Use global 32-bit address width
        max_addr = (1 << addr_width) - 1  # Maximum address value for this width

        # Simple decode based on address ranges
        for i, idx in enumerate(self.master.slave_connections):
            slave = self.slaves[idx]
            end_addr = slave.base_addr + slave.addr_range - 1

            # Build comparison string intelligently to avoid Verilator warnings
            # - Skip "addr >= 0" (unsigned is always >= 0)
            # - Skip "addr <= max" when max is full address range

            if slave.base_addr == 0 and end_addr == max_addr:
                # Full address range - no comparison needed (catch-all)
                if i == 0:
                    lines.append(f"        if (1'b1) begin  // Full address range")
                else:
                    lines.append(f"        else begin  // Full address range (catch-all)")
            elif slave.base_addr == 0:
                # Starts at 0 - only upper bound check
                if i == 0:
                    lines.append(f"        if ({addr_signal} <= {addr_width}'h{end_addr:08X}) begin")
                else:
                    lines.append(f"        else if ({addr_signal} <= {addr_width}'h{end_addr:08X}) begin")
            elif end_addr == max_addr:
                # Ends at max - only lower bound check
                if i == 0:
                    lines.append(f"        if ({addr_signal} >= {addr_width}'h{slave.base_addr:08X}) begin")
                else:
                    lines.append(f"        else if ({addr_signal} >= {addr_width}'h{slave.base_addr:08X}) begin")
            else:
                # Both bounds needed
                if i == 0:
                    lines.append(f"        if ({addr_signal} >= {addr_width}'h{slave.base_addr:08X} && {addr_signal} <= {addr_width}'h{end_addr:08X}) begin")
                else:
                    lines.append(f"        else if ({addr_signal} >= {addr_width}'h{slave.base_addr:08X} && {addr_signal} <= {addr_width}'h{end_addr:08X}) begin")

            lines.append(f"            {select_signal}[{idx}] = 1'b1;  // {slave.name}")
            lines.append("        end")

        return lines

    def _get_connected_slave_widths(self) -> List[int]:
        """
        Get unique adapter output widths for slaves this master connects to.

        For AXI4 slaves: Use slave's native width
        For APB slaves: Use LCD width (min of all masters connecting to same APB slaves)

        This implements Option B (LCD approach) where:
        - Adapter downsizes to LCD for APB slaves
        - APB shim handles final LCD→APB conversion
        """
        widths = set()

        # Separate AXI4 and APB slaves
        axi4_slave_indices = [idx for idx in self.master.slave_connections
                              if self.slaves[idx].protocol == 'axi4']
        apb_slave_indices = [idx for idx in self.master.slave_connections
                             if self.slaves[idx].protocol == 'apb']

        # For AXI4 slaves: use their native widths
        for idx in axi4_slave_indices:
            widths.add(self.slaves[idx].data_width)

        # For APB slaves: use LCD width (calculated once for all APB connections)
        if apb_slave_indices:
            lcd_width = self._calculate_lcd_width_for_apb()
            widths.add(lcd_width)

        return sorted(list(widths))

    def _get_masters_connecting_to_apb_slaves(self) -> List[MasterConfig]:
        """
        Get all masters (including this one) that connect to the same APB slaves.

        This is used for LCD (Lowest Common Denominator) width calculation:
        When multiple masters with different widths connect to the same APB slaves,
        we need to find the minimum width among them.

        Returns:
            List of MasterConfig objects that connect to same APB slaves as this master
        """
        # Find APB slaves this master connects to
        apb_slave_indices = [idx for idx in self.master.slave_connections
                             if self.slaves[idx].protocol == 'apb']

        if not apb_slave_indices:
            return []  # This master doesn't connect to any APB slaves

        # Find all masters that connect to ANY of these APB slaves
        connecting_masters = []
        seen_names = set()  # Track by name to avoid duplicates
        for apb_idx in apb_slave_indices:
            for master in self.all_masters:
                if apb_idx in master.slave_connections and master.name not in seen_names:
                    connecting_masters.append(master)
                    seen_names.add(master.name)

        return connecting_masters

    def _calculate_lcd_width_for_apb(self) -> int:
        """
        Calculate LCD (Lowest Common Denominator) width for APB slave connections.

        Returns the minimum data width among all masters connecting to the same
        APB slaves. This width will be used as the adapter output width.

        Returns:
            LCD width in bits, or master's native width if no APB connections
        """
        masters_to_apb = self._get_masters_connecting_to_apb_slaves()

        if not masters_to_apb:
            # No APB connections - use master's native width
            return self.master.data_width

        # Find minimum width among all masters connecting to APB
        lcd_width = min(m.data_width for m in masters_to_apb)

        if lcd_width != self.master.data_width:
            master_names = ', '.join(f"{m.name}({m.data_width}b)" for m in masters_to_apb)
            print(f"INFO: Adapter '{self.master.name}' LCD width for APB: {lcd_width}b")
            print(f"      Masters connecting to same APB slaves: {master_names}")

        return lcd_width

    def _generate_width_adaptation(self) -> List[str]:
        """
        Generate width converters and/or direct passthrough.

        Creates one output path per unique slave width:
        - If master_width == slave_width: direct passthrough
        - If master_width != slave_width: converter instance
        """
        lines = []

        # Get unique slave widths this master connects to
        slave_widths = self._get_connected_slave_widths()

        lines.append("    // ================================================================")
        lines.append(f"    // Width adaptation - Master: {self.master.data_width}b")
        lines.append(f"    // Connected to slaves with widths: {slave_widths}")
        lines.append("    // ================================================================")
        lines.append("")

        # Generate one path per unique width
        for slave_width in slave_widths:
            if slave_width == self.master.data_width:
                # Direct passthrough - no conversion
                lines.extend(self._generate_direct_passthrough(slave_width))
            else:
                # Width conversion needed
                lines.extend(self._generate_converter_instance(slave_width))

        # Generate response MUX logic (only needed if we have converters)
        has_converters = any(w != self.master.data_width for w in slave_widths)
        if has_converters:
            lines.extend(self._generate_response_mux(slave_widths))

        return lines

    def _generate_response_mux(self, slave_widths: List[int]) -> List[str]:
        """
        Generate MUX logic to route responses from converters/passthroughs back to fub_axi_*.

        The MUX selects based on slave_select signals (address decode output).
        """
        lines = []

        lines.append("    // ================================================================")
        lines.append("    // Response MUX - Route responses from width-specific paths")
        lines.append("    // back to fub_axi_* based on address decode")
        lines.append("    // ================================================================")
        lines.append("")

        master_width = self.master.data_width

        # Build mapping: adapter_output_width -> list of slave indices with that width
        # NOTE: For APB slaves, use LCD width; for AXI4 slaves, use native width
        width_to_slaves = {}
        lcd_width_apb = None  # Cache LCD calculation

        for slave_idx in self.master.slave_connections:
            slave = self.slaves[slave_idx]

            # Determine adapter output width for this slave
            if slave.protocol == 'apb':
                if lcd_width_apb is None:
                    lcd_width_apb = self._calculate_lcd_width_for_apb()
                adapter_output_width = lcd_width_apb
            else:
                adapter_output_width = slave.data_width

            if adapter_output_width not in width_to_slaves:
                width_to_slaves[adapter_output_width] = []
            width_to_slaves[adapter_output_width].append(slave_idx)

        # Write channel MUX
        if self.master.channels in ["wr", "rw"]:
            lines.append("    // Write response MUX (B channel)")
            lines.append("    always_comb begin")

            # Default assignments
            lines.append("        fub_axi_awready = 1'b0;")
            lines.append("        fub_axi_wready = 1'b0;")
            lines.append(f"        fub_axi_bid = {self.master.id_width}'d0;")
            lines.append("        fub_axi_bresp = 2'b00;")
            lines.append("        fub_axi_bvalid = 1'b0;")
            lines.append("")

            # Case statement based on slave_select_aw
            lines.append("        case (slave_select_aw)")
            for width_idx, slave_width in enumerate(sorted(set(slave_widths))):
                suffix = f"{slave_width}b"
                slave_indices = width_to_slaves[slave_width]

                # Build one-hot pattern for these slaves
                # Example: If slaves 0, 2 connect to 32b → pattern is 4'b0101
                for slave_idx in slave_indices:
                    pattern = f"{len(self.slaves)}'b" + ''.join(
                        '1' if i == slave_idx else '0'
                        for i in range(len(self.slaves)-1, -1, -1)
                    )
                    lines.append(f"            {pattern}: begin  // Slave {slave_idx} ({slave_width}b)")

                    if slave_width == master_width:
                        # Direct passthrough signals
                        lines.append(f"                fub_axi_awready = {self.master.name}_{suffix}_awready;")
                        lines.append(f"                fub_axi_wready = {self.master.name}_{suffix}_wready;")
                        lines.append(f"                fub_axi_bid = {self.master.name}_{suffix}_b.id;")
                        lines.append(f"                fub_axi_bresp = {self.master.name}_{suffix}_b.resp;")
                        lines.append(f"                fub_axi_bvalid = {self.master.name}_{suffix}_bvalid;")
                    else:
                        # Converter intermediate signals
                        lines.append(f"                fub_axi_awready = conv_{suffix}_awready;")
                        lines.append(f"                fub_axi_wready = conv_{suffix}_wready;")
                        lines.append(f"                fub_axi_bid = conv_{suffix}_bid;")
                        lines.append(f"                fub_axi_bresp = conv_{suffix}_bresp;")
                        lines.append(f"                fub_axi_bvalid = conv_{suffix}_bvalid;")

                    lines.append("            end")

            lines.append("            default: begin")
            lines.append("                // No slave selected - hold defaults")
            lines.append("            end")
            lines.append("        endcase")
            lines.append("    end")
            lines.append("")

        # Read channel MUX
        if self.master.channels in ["rd", "rw"]:
            lines.append("    // Read response MUX (R channel)")
            lines.append("    always_comb begin")

            # Default assignments
            lines.append("        fub_axi_arready = 1'b0;")
            lines.append(f"        fub_axi_rid = {self.master.id_width}'d0;")
            lines.append(f"        fub_axi_rdata = {master_width}'d0;")
            lines.append("        fub_axi_rresp = 2'b00;")
            lines.append("        fub_axi_rlast = 1'b0;")
            lines.append("        fub_axi_rvalid = 1'b0;")
            lines.append("")

            # Case statement based on slave_select_ar
            lines.append("        case (slave_select_ar)")
            for width_idx, slave_width in enumerate(sorted(set(slave_widths))):
                suffix = f"{slave_width}b"
                slave_indices = width_to_slaves[slave_width]

                for slave_idx in slave_indices:
                    pattern = f"{len(self.slaves)}'b" + ''.join(
                        '1' if i == slave_idx else '0'
                        for i in range(len(self.slaves)-1, -1, -1)
                    )
                    lines.append(f"            {pattern}: begin  // Slave {slave_idx} ({slave_width}b)")

                    if slave_width == master_width:
                        # Direct passthrough signals
                        lines.append(f"                fub_axi_arready = {self.master.name}_{suffix}_arready;")
                        lines.append(f"                fub_axi_rid = {self.master.name}_{suffix}_r.id;")
                        lines.append(f"                fub_axi_rdata = {self.master.name}_{suffix}_r.data;")
                        lines.append(f"                fub_axi_rresp = {self.master.name}_{suffix}_r.resp;")
                        lines.append(f"                fub_axi_rlast = {self.master.name}_{suffix}_r.last;")
                        lines.append(f"                fub_axi_rvalid = {self.master.name}_{suffix}_rvalid;")
                    else:
                        # Converter intermediate signals
                        lines.append(f"                fub_axi_arready = conv_{suffix}_arready;")
                        lines.append(f"                fub_axi_rid = conv_{suffix}_rid;")
                        lines.append(f"                fub_axi_rdata = conv_{suffix}_rdata;")
                        lines.append(f"                fub_axi_rresp = conv_{suffix}_rresp;")
                        lines.append(f"                fub_axi_rlast = conv_{suffix}_rlast;")
                        lines.append(f"                fub_axi_rvalid = conv_{suffix}_rvalid;")

                    lines.append("            end")

            lines.append("            default: begin")
            lines.append("                // No slave selected - hold defaults")
            lines.append("            end")
            lines.append("        endcase")
            lines.append("    end")
            lines.append("")

        return lines

    def _generate_direct_passthrough(self, width: int) -> List[str]:
        """
        Generate direct assign passthrough for matching width.

        NOTE: Requests broadcast to output, responses come from MUX (not direct assigns).
        """
        lines = []
        suffix = f"{width}b"

        lines.append(f"    // ================================================================")
        lines.append(f"    // Direct passthrough: {self.master.data_width}b → {width}b (no converter)")
        lines.append(f"    // Requests: fub_axi_* → {self.master.name}_{suffix}_*")
        lines.append(f"    // Responses: {self.master.name}_{suffix}_* → MUX → fub_axi_*")
        lines.append(f"    // ================================================================")
        lines.append("")

        # Write channels
        if self.master.channels in ["wr", "rw"]:
            lines.append("    // AW channel (request: fub → output)")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.id     = fub_axi_awid;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.addr   = fub_axi_awaddr;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.len    = fub_axi_awlen;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.size   = fub_axi_awsize;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.burst  = fub_axi_awburst;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.lock   = fub_axi_awlock;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.cache  = fub_axi_awcache;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.prot   = fub_axi_awprot;")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.qos    = 4'b0;  // Tie to 0")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.region = 4'b0;  // Tie to 0")
            lines.append(f"    assign {self.master.name}_{suffix}_aw.user   = 1'b0;  // Tie to 0")
            lines.append(f"    assign {self.master.name}_{suffix}_awvalid   = fub_axi_awvalid;")
            lines.append("    // awready routed via MUX")
            lines.append("")

            lines.append("    // W channel (request: fub → output)")
            lines.append(f"    assign {self.master.name}_{suffix}_w.data  = fub_axi_wdata;")
            lines.append(f"    assign {self.master.name}_{suffix}_w.strb  = fub_axi_wstrb;")
            lines.append(f"    assign {self.master.name}_{suffix}_w.last  = fub_axi_wlast;")
            lines.append(f"    assign {self.master.name}_{suffix}_w.user  = 1'b0;  // Tie to 0")
            lines.append(f"    assign {self.master.name}_{suffix}_wvalid  = fub_axi_wvalid;")
            lines.append("    // wready routed via MUX")
            lines.append("")

            lines.append("    // B channel (response: output → MUX → fub)")
            lines.append(f"    assign {self.master.name}_{suffix}_bready = fub_axi_bready;")
            lines.append("    // bid, bresp, bvalid routed via MUX (user field ignored)")
            lines.append("")

        # Read channels
        if self.master.channels in ["rd", "rw"]:
            lines.append("    // AR channel (request: fub → output)")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.id     = fub_axi_arid;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.addr   = fub_axi_araddr;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.len    = fub_axi_arlen;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.size   = fub_axi_arsize;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.burst  = fub_axi_arburst;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.lock   = fub_axi_arlock;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.cache  = fub_axi_arcache;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.prot   = fub_axi_arprot;")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.qos    = 4'b0;  // Tie to 0")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.region = 4'b0;  // Tie to 0")
            lines.append(f"    assign {self.master.name}_{suffix}_ar.user   = 1'b0;  // Tie to 0")
            lines.append(f"    assign {self.master.name}_{suffix}_arvalid   = fub_axi_arvalid;")
            lines.append("    // arready routed via MUX")
            lines.append("")

            lines.append("    // R channel (response: output → MUX → fub)")
            lines.append(f"    assign {self.master.name}_{suffix}_rready = fub_axi_rready;")
            lines.append("    // rid, rdata, rresp, rlast, rvalid routed via MUX (user field ignored)")
            lines.append("")

        return lines

    def _generate_converter_instance(self, slave_width: int) -> List[str]:
        """Generate width converter instance for mismatched width with proper signal isolation."""
        lines = []
        suffix = f"{slave_width}b"
        master_width = self.master.data_width

        lines.append(f"    // ================================================================")
        lines.append(f"    // Width converter: {master_width}b → {slave_width}b")
        lines.append(f"    // ================================================================")
        lines.append("")

        # Intermediate signals for converter slave side (from fub_axi_*)
        # These isolate converter responses from direct fub_axi_* assignments
        lines.append(f"    // Intermediate signals for {suffix} converter")
        if self.master.channels in ["wr", "rw"]:
            lines.append(f"    logic conv_{suffix}_awready;")
            lines.append(f"    logic conv_{suffix}_wready;")
            lines.append(f"    logic [{self.master.id_width-1}:0] conv_{suffix}_bid;")
            lines.append(f"    logic [1:0] conv_{suffix}_bresp;")
            lines.append(f"    logic conv_{suffix}_bvalid;")
        if self.master.channels in ["rd", "rw"]:
            lines.append(f"    logic conv_{suffix}_arready;")
            lines.append(f"    logic [{self.master.id_width-1}:0] conv_{suffix}_rid;")
            lines.append(f"    logic [{master_width-1}:0] conv_{suffix}_rdata;")
            lines.append(f"    logic [1:0] conv_{suffix}_rresp;")
            lines.append(f"    logic conv_{suffix}_rlast;")
            lines.append(f"    logic conv_{suffix}_rvalid;")
        lines.append("")

        # Write converter
        if self.master.channels in ["wr", "rw"]:
            lines.append(f"    axi4_dwidth_converter_wr #(")
            lines.append(f"        .S_AXI_DATA_WIDTH({master_width}),")
            lines.append(f"        .M_AXI_DATA_WIDTH({slave_width}),")
            lines.append(f"        .AXI_ID_WIDTH({self.master.id_width}),")
            lines.append(f"        .AXI_ADDR_WIDTH(32),")  # Use global 32-bit address width
            lines.append("        .AXI_USER_WIDTH(1),")
            lines.append("        .SKID_DEPTH_AW(2),")
            lines.append("        .SKID_DEPTH_W(4),")
            lines.append("        .SKID_DEPTH_B(2)")
            lines.append(f"    ) u_wr_conv_{suffix} (")
            lines.append("        .aclk(aclk),")
            lines.append("        .aresetn(aresetn),")
            lines.append("")
            lines.append("        // Slave side (from wrapper) - BROADCAST requests")
            lines.append("        .s_axi_awid(fub_axi_awid),")
            lines.append("        .s_axi_awaddr(fub_axi_awaddr),")
            lines.append("        .s_axi_awlen(fub_axi_awlen),")
            lines.append("        .s_axi_awsize(fub_axi_awsize),")
            lines.append("        .s_axi_awburst(fub_axi_awburst),")
            lines.append("        .s_axi_awlock(fub_axi_awlock),")
            lines.append("        .s_axi_awcache(fub_axi_awcache),")
            lines.append("        .s_axi_awprot(fub_axi_awprot),")
            lines.append("        .s_axi_awqos(4'b0),")
            lines.append("        .s_axi_awregion(4'b0),")
            lines.append("        .s_axi_awuser(1'b0),")
            lines.append("        .s_axi_awvalid(fub_axi_awvalid),")
            lines.append(f"        .s_axi_awready(conv_{suffix}_awready),  // Intermediate signal")
            lines.append("")
            lines.append("        .s_axi_wdata(fub_axi_wdata),")
            lines.append("        .s_axi_wstrb(fub_axi_wstrb),")
            lines.append("        .s_axi_wlast(fub_axi_wlast),")
            lines.append("        .s_axi_wuser(1'b0),")
            lines.append("        .s_axi_wvalid(fub_axi_wvalid),")
            lines.append(f"        .s_axi_wready(conv_{suffix}_wready),  // Intermediate signal")
            lines.append("")
            lines.append(f"        .s_axi_bid(conv_{suffix}_bid),  // Intermediate signal")
            lines.append(f"        .s_axi_bresp(conv_{suffix}_bresp),  // Intermediate signal")
            lines.append("        .s_axi_buser(),")
            lines.append(f"        .s_axi_bvalid(conv_{suffix}_bvalid),  // Intermediate signal")
            lines.append("        .s_axi_bready(fub_axi_bready),")
            lines.append("")
            lines.append("        // Master side (to crossbar)")
            lines.append(f"        .m_axi_awid({self.master.name}_{suffix}_aw.id),")
            lines.append(f"        .m_axi_awaddr({self.master.name}_{suffix}_aw.addr),")
            lines.append(f"        .m_axi_awlen({self.master.name}_{suffix}_aw.len),")
            lines.append(f"        .m_axi_awsize({self.master.name}_{suffix}_aw.size),")
            lines.append(f"        .m_axi_awburst({self.master.name}_{suffix}_aw.burst),")
            lines.append(f"        .m_axi_awlock({self.master.name}_{suffix}_aw.lock),")
            lines.append(f"        .m_axi_awcache({self.master.name}_{suffix}_aw.cache),")
            lines.append(f"        .m_axi_awprot({self.master.name}_{suffix}_aw.prot),")
            lines.append(f"        .m_axi_awqos({self.master.name}_{suffix}_aw.qos),      // Tie to 0 in packet")
            lines.append(f"        .m_axi_awregion({self.master.name}_{suffix}_aw.region), // Tie to 0 in packet")
            lines.append(f"        .m_axi_awuser({self.master.name}_{suffix}_aw.user),     // Tie to 0 in packet")
            lines.append(f"        .m_axi_awvalid({self.master.name}_{suffix}_awvalid),")
            lines.append(f"        .m_axi_awready({self.master.name}_{suffix}_awready),")
            lines.append("")
            lines.append(f"        .m_axi_wdata({self.master.name}_{suffix}_w.data),")
            lines.append(f"        .m_axi_wstrb({self.master.name}_{suffix}_w.strb),")
            lines.append(f"        .m_axi_wlast({self.master.name}_{suffix}_w.last),")
            lines.append(f"        .m_axi_wuser({self.master.name}_{suffix}_w.user),       // Tie to 0 in packet")
            lines.append(f"        .m_axi_wvalid({self.master.name}_{suffix}_wvalid),")
            lines.append(f"        .m_axi_wready({self.master.name}_{suffix}_wready),")
            lines.append("")
            lines.append(f"        .m_axi_bid({self.master.name}_{suffix}_b.id),")
            lines.append(f"        .m_axi_bresp({self.master.name}_{suffix}_b.resp),")
            lines.append(f"        .m_axi_buser({self.master.name}_{suffix}_b.user),       // From packet (ignored)")
            lines.append(f"        .m_axi_bvalid({self.master.name}_{suffix}_bvalid),")
            lines.append(f"        .m_axi_bready({self.master.name}_{suffix}_bready)")
            lines.append("    );")
            lines.append("")

        # Read converter
        if self.master.channels in ["rd", "rw"]:
            lines.append(f"    axi4_dwidth_converter_rd #(")
            lines.append(f"        .S_AXI_DATA_WIDTH({master_width}),")
            lines.append(f"        .M_AXI_DATA_WIDTH({slave_width}),")
            lines.append(f"        .AXI_ID_WIDTH({self.master.id_width}),")
            lines.append(f"        .AXI_ADDR_WIDTH(32),")  # Use global 32-bit address width
            lines.append("        .AXI_USER_WIDTH(1),")
            lines.append("        .SKID_DEPTH_AR(2),")
            lines.append("        .SKID_DEPTH_R(4)")
            lines.append(f"    ) u_rd_conv_{suffix} (")
            lines.append("        .aclk(aclk),")
            lines.append("        .aresetn(aresetn),")
            lines.append("")
            lines.append("        // Slave side (from wrapper) - BROADCAST requests")
            lines.append("        .s_axi_arid(fub_axi_arid),")
            lines.append("        .s_axi_araddr(fub_axi_araddr),")
            lines.append("        .s_axi_arlen(fub_axi_arlen),")
            lines.append("        .s_axi_arsize(fub_axi_arsize),")
            lines.append("        .s_axi_arburst(fub_axi_arburst),")
            lines.append("        .s_axi_arlock(fub_axi_arlock),")
            lines.append("        .s_axi_arcache(fub_axi_arcache),")
            lines.append("        .s_axi_arprot(fub_axi_arprot),")
            lines.append("        .s_axi_arqos(4'b0),")
            lines.append("        .s_axi_arregion(4'b0),")
            lines.append("        .s_axi_aruser(1'b0),")
            lines.append("        .s_axi_arvalid(fub_axi_arvalid),")
            lines.append(f"        .s_axi_arready(conv_{suffix}_arready),  // Intermediate signal")
            lines.append("")
            lines.append(f"        .s_axi_rid(conv_{suffix}_rid),  // Intermediate signal")
            lines.append(f"        .s_axi_rdata(conv_{suffix}_rdata),  // Intermediate signal")
            lines.append(f"        .s_axi_rresp(conv_{suffix}_rresp),  // Intermediate signal")
            lines.append(f"        .s_axi_rlast(conv_{suffix}_rlast),  // Intermediate signal")
            lines.append("        .s_axi_ruser(),")
            lines.append(f"        .s_axi_rvalid(conv_{suffix}_rvalid),  // Intermediate signal")
            lines.append("        .s_axi_rready(fub_axi_rready),")
            lines.append("")
            lines.append("        // Master side (to crossbar)")
            lines.append(f"        .m_axi_arid({self.master.name}_{suffix}_ar.id),")
            lines.append(f"        .m_axi_araddr({self.master.name}_{suffix}_ar.addr),")
            lines.append(f"        .m_axi_arlen({self.master.name}_{suffix}_ar.len),")
            lines.append(f"        .m_axi_arsize({self.master.name}_{suffix}_ar.size),")
            lines.append(f"        .m_axi_arburst({self.master.name}_{suffix}_ar.burst),")
            lines.append(f"        .m_axi_arlock({self.master.name}_{suffix}_ar.lock),")
            lines.append(f"        .m_axi_arcache({self.master.name}_{suffix}_ar.cache),")
            lines.append(f"        .m_axi_arprot({self.master.name}_{suffix}_ar.prot),")
            lines.append(f"        .m_axi_arqos({self.master.name}_{suffix}_ar.qos),      // Tie to 0 in packet")
            lines.append(f"        .m_axi_arregion({self.master.name}_{suffix}_ar.region), // Tie to 0 in packet")
            lines.append(f"        .m_axi_aruser({self.master.name}_{suffix}_ar.user),     // Tie to 0 in packet")
            lines.append(f"        .m_axi_arvalid({self.master.name}_{suffix}_arvalid),")
            lines.append(f"        .m_axi_arready({self.master.name}_{suffix}_arready),")
            lines.append("")
            lines.append(f"        .m_axi_rid({self.master.name}_{suffix}_r.id),")
            lines.append(f"        .m_axi_rdata({self.master.name}_{suffix}_r.data),")
            lines.append(f"        .m_axi_rresp({self.master.name}_{suffix}_r.resp),")
            lines.append(f"        .m_axi_rlast({self.master.name}_{suffix}_r.last),")
            lines.append(f"        .m_axi_ruser({self.master.name}_{suffix}_r.user),       // From packet (ignored)")
            lines.append(f"        .m_axi_rvalid({self.master.name}_{suffix}_rvalid),")
            lines.append(f"        .m_axi_rready({self.master.name}_{suffix}_rready)")
            lines.append("    );")
            lines.append("")

        return lines

    def _get_module_name(self) -> str:
        """Get adapter module name."""
        return f"{self.master.name}_adapter"


def test_adapter_generator():
    """Test adapter generator with example configuration."""
    from bridge_pkg.generators.package_generator import PackageGenerator

    # Example configuration
    slaves = [
        SlaveInfo("ddr", 0x00000000, 0x80000000, 32, 32),
        SlaveInfo("sram", 0x80000000, 0x80000000, 32, 32)
    ]

    master_config = MasterConfig(
        name="cpu",
        prefix="cpu_m_axi_",
        data_width=32,
        addr_width=32,
        id_width=4,
        channels="wr",
        slave_connections=[0, 1]
    )

    gen = AdapterGenerator("bridge_1x2_wr", 2, master_config, slaves)
    adapter_src = gen.generate()
    print(adapter_src)


if __name__ == "__main__":
    test_adapter_generator()
