"""
Bridge Package Generator

Generates SystemVerilog packages with AXI channel struct definitions
for bridge crossbars.

Author: RTL Design Sherpa
Date: 2025-11-03
"""

from typing import List, Set


class PackageGenerator:
    """
    Generates bridge-specific SystemVerilog packages with AXI channel structs.

    Structs are created for:
    - Address channels (AW, AR) - width-independent
    - Write data channel (W) - width-specific variants
    - Read data channel (R) - width-specific variants
    - Write response channel (B) - width-independent
    """

    def __init__(self, bridge_name: str, id_width: int = 4, addr_width: int = 32):
        """
        Initialize package generator.

        Args:
            bridge_name: Name of bridge (e.g., "bridge_1x2_wr")
            id_width: Default ID width for masters (can vary per master)
            addr_width: Address width for all masters/slaves (must be uniform)
        """
        self.bridge_name = bridge_name
        self.id_width = id_width
        self.addr_width = addr_width  # Configurable address width
        self.data_widths: Set[int] = set()  # Collect unique data widths

    def add_data_width(self, width: int):
        """Add a data width that needs struct definitions."""
        self.data_widths.add(width)

    def generate(self) -> str:
        """
        Generate complete package file.

        Returns:
            SystemVerilog package source code
        """
        lines = []

        # Header
        lines.extend(self._generate_header())

        # Package declaration
        lines.append(f"package {self.bridge_name}_pkg;")
        lines.append("")

        # Address channel structs (width-independent)
        lines.extend(self._generate_aw_struct())
        lines.append("")
        lines.extend(self._generate_ar_struct())
        lines.append("")

        # Write data channel structs (width-specific)
        for width in sorted(self.data_widths):
            lines.extend(self._generate_w_struct(width))
            lines.append("")

        # Write response channel struct (width-independent)
        lines.extend(self._generate_b_struct())
        lines.append("")

        # Read data channel structs (width-specific)
        for width in sorted(self.data_widths):
            lines.extend(self._generate_r_struct(width))
            lines.append("")

        # Package end
        lines.append(f"endpackage : {self.bridge_name}_pkg")
        lines.append("")

        return "\n".join(lines)

    def _generate_header(self) -> List[str]:
        """Generate file header with description."""
        return [
            f"// Bridge Package: {self.bridge_name}",
            "// Generated by: PackageGenerator",
            "// Defines AXI channel structs for all data widths used in this bridge",
            "",
            "`timescale 1ns / 1ps",
            ""
        ]

    def _generate_aw_struct(self) -> List[str]:
        """Generate AXI4 Write Address Channel struct."""
        return [
            "    // AXI4 Write Address Channel (width-independent)",
            f"    // Note: ID width is {self.id_width}-bit for this bridge",
            "    typedef struct packed {",
            f"        logic [{self.id_width-1}:0]   id;      // Transaction ID",
            f"        logic [{self.addr_width-1}:0]  addr;    // Address",
            "        logic [7:0]   len;     // Burst length",
            "        logic [2:0]   size;    // Burst size",
            "        logic [1:0]   burst;   // Burst type",
            "        logic         lock;    // Lock type",
            "        logic [3:0]   cache;   // Cache type",
            "        logic [2:0]   prot;    // Protection type",
            "        logic [3:0]   qos;     // Quality of Service",
            "        logic [3:0]   region;  // Region identifier",
            "        logic         user;    // User signal",
            "    } axi4_aw_t;"
        ]

    def _generate_ar_struct(self) -> List[str]:
        """Generate AXI4 Read Address Channel struct."""
        return [
            "    // AXI4 Read Address Channel (width-independent)",
            "    typedef struct packed {",
            f"        logic [{self.id_width-1}:0]   id;      // Transaction ID",
            f"        logic [{self.addr_width-1}:0]  addr;    // Address",
            "        logic [7:0]   len;     // Burst length",
            "        logic [2:0]   size;    // Burst size",
            "        logic [1:0]   burst;   // Burst type",
            "        logic         lock;    // Lock type",
            "        logic [3:0]   cache;   // Cache type",
            "        logic [2:0]   prot;    // Protection type",
            "        logic [3:0]   qos;     // Quality of Service",
            "        logic [3:0]   region;  // Region identifier",
            "        logic         user;    // User signal",
            "    } axi4_ar_t;"
        ]

    def _generate_w_struct(self, data_width: int) -> List[str]:
        """
        Generate AXI4 Write Data Channel struct for specific width.

        Args:
            data_width: Data bus width in bits
        """
        strb_width = data_width // 8
        suffix = self._get_width_suffix(data_width)

        return [
            f"    // AXI4 Write Data Channel - {data_width}-bit data width",
            "    typedef struct packed {",
            f"        logic [{data_width-1}:0]  data;    // Write data",
            f"        logic [{strb_width-1}:0]   strb;    // Write strobes",
            "        logic         last;    // Last transfer in burst",
            "        logic         user;    // User signal",
            f"    }} axi4_w_{suffix}_t;"
        ]

    def _generate_b_struct(self) -> List[str]:
        """Generate AXI4 Write Response Channel struct."""
        return [
            "    // AXI4 Write Response Channel (width-independent)",
            "    typedef struct packed {",
            f"        logic [{self.id_width-1}:0]   id;      // Response ID",
            "        logic [1:0]   resp;    // Write response",
            "        logic         user;    // User signal",
            "    } axi4_b_t;"
        ]

    def _generate_r_struct(self, data_width: int) -> List[str]:
        """
        Generate AXI4 Read Data Channel struct for specific width.

        Args:
            data_width: Data bus width in bits
        """
        suffix = self._get_width_suffix(data_width)

        return [
            f"    // AXI4 Read Data Channel - {data_width}-bit data width",
            "    typedef struct packed {",
            f"        logic [{self.id_width-1}:0]   id;      // Response ID",
            f"        logic [{data_width-1}:0]  data;    // Read data",
            "        logic [1:0]   resp;    // Read response",
            "        logic         last;    // Last transfer in burst",
            "        logic         user;    // User signal",
            f"    }} axi4_r_{suffix}_t;"
        ]

    def _get_width_suffix(self, data_width: int) -> str:
        """
        Get suffix for width-specific struct names.

        Args:
            data_width: Data bus width in bits

        Returns:
            Suffix string (e.g., "32b", "512b")
        """
        return f"{data_width}b"


def test_package_generator():
    """Test package generator with example configuration."""
    gen = PackageGenerator("bridge_1x2_wr", id_width=4)
    gen.add_data_width(32)

    pkg_src = gen.generate()
    print(pkg_src)


if __name__ == "__main__":
    test_package_generator()
