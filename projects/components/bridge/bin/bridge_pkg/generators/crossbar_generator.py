"""
Crossbar Generator

Generates crossbar module that routes width-adapted signals from adapters to slaves.

The crossbar:
1. Takes multiple width-specific inputs from each adapter
2. Takes address decode one-hot signals (slave_select_aw/ar)
3. Selects correct width path based on target slave's width
4. Routes selected signals to slave outputs

Author: RTL Design Sherpa
Date: 2025-11-04
"""

from typing import List, Dict, Set
from dataclasses import dataclass

from bridge_pkg.generators.adapter_generator import MasterConfig, SlaveInfo
from bridge_pkg.signal_naming import SignalNaming, Direction, AXI4Channel, AXI4_SLAVE_SIGNALS, AXI4_MASTER_SIGNALS


class CrossbarGenerator:
    """
    Generates crossbar module for intelligent width-based routing.

    For each slave, routes signals from the correctly-sized path of each
    master that can target that slave.

    Example:
        Master A (64b) connects to Slave 0 (64b) and Slave 1 (128b)
        - Master A adapter outputs: 64b path, 128b path
        - Slave 0 gets: Master A 64b path (direct)
        - Slave 1 gets: Master A 128b path (converted)
    """

    def __init__(self, bridge_name: str, masters: List[MasterConfig], slaves: List[SlaveInfo]):
        """
        Initialize crossbar generator.

        Args:
            bridge_name: Name of bridge (e.g., "bridge_4x4_rw")
            masters: List of master configurations
            slaves: List of slave configurations
        """
        self.bridge_name = bridge_name
        self.masters = masters
        self.slaves = slaves

    def generate(self) -> str:
        """Generate complete crossbar module."""
        lines = []

        # Header
        lines.extend(self._generate_header())

        # Module declaration
        lines.extend(self._generate_module_declaration())

        # Crossbar routing logic
        lines.extend(self._generate_routing_logic())

        # Module end
        lines.append(f"endmodule : {self.bridge_name}_xbar")
        lines.append("")

        return "\n".join(lines)

    def _generate_header(self) -> List[str]:
        """Generate file header."""
        return [
            f"// Crossbar: {self.bridge_name}_xbar",
            "// Generated by: CrossbarGenerator",
            "// ",
            "// Routes width-adapted signals from adapters to slaves.",
            "// Selects correct width path based on address decode.",
            "",
            "`timescale 1ns / 1ps",
            "",
            f"import {self.bridge_name}_pkg::*;",
            ""
        ]

    def _generate_module_declaration(self) -> List[str]:
        """Generate module declaration with all ports."""
        lines = []

        lines.append(f"module {self.bridge_name}_xbar (")
        lines.append("    input  logic aclk,")
        lines.append("    input  logic aresetn,")
        lines.append("")

        # Adapter inputs (multiple width paths per master)
        for master_idx, master in enumerate(self.masters):
            is_last_master = (master_idx == len(self.masters) - 1)
            has_slaves = (len(self.slaves) > 0)
            lines.append(f"    // {master.name} adapter outputs (multiple width paths)")
            lines.extend(self._generate_adapter_input_ports(master, is_last_master, has_slaves))

            # Add comma if not last master or if slaves follow
            if not is_last_master or has_slaves:
                lines.append("")

        # Slave outputs
        for slave_idx, slave in enumerate(self.slaves):
            lines.append(f"    // Slave {slave_idx}: {slave.name}")
            lines.extend(self._generate_slave_output_ports(slave))

            # Add comma if not last slave
            if slave_idx < len(self.slaves) - 1:
                lines.append("")

        lines.append(");")
        lines.append("")

        return lines

    def _generate_adapter_input_ports(self, master: MasterConfig, is_last_master: bool, has_slaves: bool) -> List[str]:
        """
        Generate input ports from adapter for one master.

        Args:
            master: Master configuration
            is_last_master: True if this is the last master in the list
            has_slaves: True if there are slave ports following

        Includes:
        - Address decode one-hot signals
        - Width-specific channel signals (one set per unique slave width)
        """
        lines = []

        # Get unique slave widths this master connects to
        slave_widths = self._get_connected_slave_widths(master)

        # Address decode signals
        if master.channels in ["wr", "rw"]:
            lines.append(f"    input  logic [NUM_SLAVES-1:0] {master.name}_slave_select_aw,")
        if master.channels in ["rd", "rw"]:
            lines.append(f"    input  logic [NUM_SLAVES-1:0] {master.name}_slave_select_ar,")

        # Width-specific signals for each unique width
        for width_idx, width in enumerate(slave_widths):
            suffix = f"{width}b"
            is_last_width = (width_idx == len(slave_widths) - 1)
            # This port needs comma unless it's the VERY last port in the entire module
            needs_comma = not (is_last_master and is_last_width and not has_slaves)

            lines.append(f"    // {width}b path")

            # Write channels
            if master.channels in ["wr", "rw"]:
                lines.append(f"    input  axi4_aw_t     {master.name}_{suffix}_aw,")
                lines.append(f"    input  logic         {master.name}_{suffix}_awvalid,")
                lines.append(f"    output logic         {master.name}_{suffix}_awready,")
                lines.append(f"    input  axi4_w_{suffix}_t  {master.name}_{suffix}_w,")
                lines.append(f"    input  logic         {master.name}_{suffix}_wvalid,")
                lines.append(f"    output logic         {master.name}_{suffix}_wready,")
                lines.append(f"    output axi4_b_t      {master.name}_{suffix}_b,")
                lines.append(f"    output logic         {master.name}_{suffix}_bvalid,")
                # Determine if comma needed
                if master.channels == "wr" and is_last_width:
                    # This is last signal for write-only master
                    if needs_comma:
                        lines.append(f"    input  logic         {master.name}_{suffix}_bready,")
                    else:
                        lines.append(f"    input  logic         {master.name}_{suffix}_bready")
                else:
                    lines.append(f"    input  logic         {master.name}_{suffix}_bready,")

            # Read channels
            if master.channels in ["rd", "rw"]:
                lines.append(f"    input  axi4_ar_t     {master.name}_{suffix}_ar,")
                lines.append(f"    input  logic         {master.name}_{suffix}_arvalid,")
                lines.append(f"    output logic         {master.name}_{suffix}_arready,")
                lines.append(f"    output axi4_r_{suffix}_t  {master.name}_{suffix}_r,")
                lines.append(f"    output logic         {master.name}_{suffix}_rvalid,")
                # Determine if comma needed (rready is always last for rd/rw channels)
                if is_last_width:
                    # This is last signal for this master
                    if needs_comma:
                        lines.append(f"    input  logic         {master.name}_{suffix}_rready,")
                    else:
                        lines.append(f"    input  logic         {master.name}_{suffix}_rready")
                else:
                    lines.append(f"    input  logic         {master.name}_{suffix}_rready,")

        return lines

    def _determine_bridge_channels(self) -> List[AXI4Channel]:
        """
        Determine which AXI4 channels the bridge needs based on masters.

        Returns list of channels needed:
        - If ANY master has wr/rw: include AW, W, B
        - If ANY master has rd/rw: include AR, R
        """
        has_write = any(m.channels in ["wr", "rw"] for m in self.masters)
        has_read = any(m.channels in ["rd", "rw"] for m in self.masters)

        channels = []
        if has_write:
            channels.extend([AXI4Channel.AW, AXI4Channel.W, AXI4Channel.B])
        if has_read:
            channels.extend([AXI4Channel.AR, AXI4Channel.R])

        return channels

    def _determine_slave_channels(self, slave: SlaveInfo) -> List[AXI4Channel]:
        """
        Determine which AXI4 channels THIS SPECIFIC SLAVE needs based on
        the masters that connect to it.

        Args:
            slave: Slave to determine channels for

        Returns:
            List of channels needed for this slave:
            - If ANY connecting master has wr/rw: include AW, W, B
            - If ANY connecting master has rd/rw: include AR, R
        """
        # Get masters that connect to this slave
        connecting_masters = self._get_masters_connecting_to_slave(slave)

        if not connecting_masters:
            # No masters connect - shouldn't happen, but return empty for safety
            return []

        # Check if any connecting master needs write channels
        has_write = any(m.channels in ["wr", "rw"] for m in connecting_masters)
        # Check if any connecting master needs read channels
        has_read = any(m.channels in ["rd", "rw"] for m in connecting_masters)

        channels = []
        if has_write:
            channels.extend([AXI4Channel.AW, AXI4Channel.W, AXI4Channel.B])
        if has_read:
            channels.extend([AXI4Channel.AR, AXI4Channel.R])

        return channels

    def _generate_slave_output_ports(self, slave: SlaveInfo) -> List[str]:
        """
        Generate output ports to slave using SignalNaming convention.

        IMPORTANT:
        - Crossbar acts as MASTER to the slave, so port directions are from master perspective
        - Uses SignalNaming convention: <port_name>_axi_<channel><signal> (no direction prefix)
        - Only generates channels needed by THIS SPECIFIC SLAVE based on connecting masters
        """
        lines = []

        # Use SignalNaming convention: <port_name>_axi_<channel><signal>
        prefix = f"{slave.name}_axi_"

        # Determine correct interface width (for APB slaves, use connecting master's width)
        data_width, addr_width = self._determine_slave_interface_width(slave)

        # Width parameters for signal info queries
        width_values = {
            'ID_WIDTH': 4,  # Standard 4-bit ID for crossbar outputs
            'ADDR_WIDTH': addr_width,
            'DATA_WIDTH': data_width,
            'STRB_WIDTH': data_width // 8,
            'USER_WIDTH': 1
        }

        # Get channels needed by THIS SLAVE (based on connecting masters' channel types)
        channels = self._determine_slave_channels(slave)

        # Get signal info from SignalNaming (crossbar is master to slave)
        signal_db = AXI4_MASTER_SIGNALS  # Crossbar acts as MASTER to slaves (outputs request, inputs response)

        # Generate declarations for each channel
        first_channel = True

        # Pre-calculate which is the last signal for comma handling
        is_last_slave = (slave == self.slaves[-1])
        last_channel = channels[-1] if channels else None

        for channel_idx, channel in enumerate(channels):
            if not first_channel:
                lines.append("")
            first_channel = False

            if channel not in signal_db:
                continue

            channel_signals = list(signal_db[channel])
            for sig_idx, sig_info in enumerate(channel_signals):
                # Build signal name using prefix + channel + signal
                sig_name = f"{prefix}{channel.value}{sig_info.name}"
                # Get complete signal declaration
                declaration = sig_info.get_declaration(sig_name, width_values)

                # Check if this is the VERY last signal in the module port list
                is_last_channel = (channel == last_channel)
                is_last_signal_in_channel = (sig_idx == len(channel_signals) - 1)
                is_very_last_signal = (is_last_slave and is_last_channel and is_last_signal_in_channel)

                if is_very_last_signal:
                    lines.append(f"    {declaration}")  # No comma
                else:
                    lines.append(f"    {declaration},")

        return lines

    def _generate_routing_logic(self) -> List[str]:
        """
        Generate crossbar routing logic.

        For each slave:
        1. Determine the slave's data width
        2. For each master that connects to this slave:
           - Select the width path matching slave's width
           - Route based on address decode one-hot
        """
        lines = []

        lines.append("    // ================================================================")
        lines.append("    // Crossbar Routing")
        lines.append("    // ================================================================")
        lines.append(f"    localparam NUM_SLAVES = {len(self.slaves)};")
        lines.append("")

        # Route to each slave
        for slave_idx, slave in enumerate(self.slaves):
            lines.extend(self._generate_slave_routing(slave_idx, slave))
            lines.append("")

        # Generate response MUXes (OR together responses from all slaves)
        lines.extend(self._generate_response_muxes())

        return lines

    def _generate_slave_routing(self, slave_idx: int, slave: SlaveInfo) -> List[str]:
        """
        Generate routing logic for one slave.

        Selects correct width path from each master based on:
        - Whether master connects to this slave
        - Slave's data width
        - Address decode one-hot signal
        """
        lines = []
        slave_width = slave.data_width
        slave_suffix = f"{slave_width}b"

        lines.append(f"    // ================================================================")
        lines.append(f"    // Slave {slave_idx}: {slave.name} ({slave_width}b)")
        lines.append(f"    // ================================================================")

        # Find masters that connect to this slave
        connecting_masters = []
        for master in self.masters:
            if slave_idx in master.slave_connections:
                connecting_masters.append(master)

        if len(connecting_masters) == 0:
            lines.append(f"    // No masters connect to {slave.name}")
            # Use SignalNaming convention for signal names
            prefix = f"{slave.name}_axi_"
            # Only assign signals for channels that THIS SLAVE needs
            slave_channels = self._determine_slave_channels(slave)
            if AXI4Channel.AW in slave_channels:
                lines.append(f"    assign {prefix}awvalid = 1'b0;")
            if AXI4Channel.W in slave_channels:
                lines.append(f"    assign {prefix}wvalid = 1'b0;")
            if AXI4Channel.AR in slave_channels:
                lines.append(f"    assign {prefix}arvalid = 1'b0;")
            return lines

        # For single master case (simplified routing)
        if len(connecting_masters) == 1:
            master = connecting_masters[0]
            lines.extend(self._generate_single_master_routing(slave_idx, slave, master))
        else:
            # Multi-master case (requires arbitration)
            lines.append(f"    // TODO: Multi-master arbitration")
            lines.append(f"    // {len(connecting_masters)} masters connect to this slave:")
            for master in connecting_masters:
                lines.append(f"    //   - {master.name}")

        return lines

    def _generate_single_master_routing(self, slave_idx: int, slave: SlaveInfo,
                                       master: MasterConfig) -> List[str]:
        """
        Generate routing for slave with single master.

        Directly connects master's width-matched path to slave.
        For APB slaves, uses LCD width instead of slave native width.
        """
        lines = []

        # Determine adapter output width for this slave connection
        # For ALL slaves (both APB and AXI4), use the slave's native data width
        # The master adapter handles width conversion to produce correctly-sized paths
        adapter_width = slave.data_width

        suffix = f"{adapter_width}b"

        lines.append(f"    // Single master: {master.name} → {slave.name}")
        lines.append(f"    // Master width: {master.data_width}b, Slave width: {slave.data_width}b")
        lines.append(f"    // Using {suffix} path from adapter (APB LCD width)" if slave.protocol == 'apb' else f"    // Using {suffix} path from adapter")
        lines.append("")

        # Write channels
        if master.channels in ["wr", "rw"]:
            lines.extend(self._generate_write_channel_routing(slave_idx, slave, master, suffix))

        # Read channels
        if master.channels in ["rd", "rw"]:
            lines.extend(self._generate_read_channel_routing(slave_idx, slave, master, suffix))

        return lines

    def _generate_write_channel_routing(self, slave_idx: int, slave: SlaveInfo,
                                        master: MasterConfig, suffix: str) -> List[str]:
        """Generate AW, W, B channel routing."""
        lines = []
        # Use SignalNaming convention for slave signals
        prefix = f"{slave.name}_axi_"

        # AW channel (master → slave)
        lines.append("    // AW channel")
        lines.append(f"    assign {prefix}awid     = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.id : '0;")
        lines.append(f"    assign {prefix}awaddr   = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.addr : '0;")
        lines.append(f"    assign {prefix}awlen    = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.len : '0;")
        lines.append(f"    assign {prefix}awsize   = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.size : '0;")
        lines.append(f"    assign {prefix}awburst  = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.burst : '0;")
        lines.append(f"    assign {prefix}awlock   = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.lock : '0;")
        lines.append(f"    assign {prefix}awcache  = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.cache : '0;")
        lines.append(f"    assign {prefix}awprot   = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_aw.prot : '0;")
        lines.append(f"    assign {prefix}awvalid  = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_awvalid : '0;")
        lines.append("")

        # W channel (master → slave)
        lines.append("    // W channel")
        lines.append(f"    assign {prefix}wdata  = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_w.data : '0;")
        lines.append(f"    assign {prefix}wstrb  = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_w.strb : '0;")
        lines.append(f"    assign {prefix}wlast  = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_w.last : '0;")
        lines.append(f"    assign {prefix}wvalid = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_wvalid : '0;")
        lines.append("")

        # Ready/B channel routing is handled in response MUX (no individual assigns to avoid multi-driver)
        lines.append("    // Bready (master → slave)")
        lines.append(f"    assign {prefix}bready = {master.name}_slave_select_aw[{slave_idx}] ? {master.name}_{suffix}_bready : '0;")
        lines.append("")

        return lines

    def _generate_read_channel_routing(self, slave_idx: int, slave: SlaveInfo,
                                       master: MasterConfig, suffix: str) -> List[str]:
        """Generate AR, R channel routing."""
        lines = []
        # Use SignalNaming convention for slave signals
        prefix = f"{slave.name}_axi_"

        # AR channel (master → slave)
        lines.append("    // AR channel")
        lines.append(f"    assign {prefix}arid     = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.id : '0;")
        lines.append(f"    assign {prefix}araddr   = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.addr : '0;")
        lines.append(f"    assign {prefix}arlen    = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.len : '0;")
        lines.append(f"    assign {prefix}arsize   = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.size : '0;")
        lines.append(f"    assign {prefix}arburst  = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.burst : '0;")
        lines.append(f"    assign {prefix}arlock   = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.lock : '0;")
        lines.append(f"    assign {prefix}arcache  = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.cache : '0;")
        lines.append(f"    assign {prefix}arprot   = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_ar.prot : '0;")
        lines.append(f"    assign {prefix}arvalid  = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_arvalid : '0;")
        lines.append("")

        # Ready/R channel routing is handled in response MUX (no individual assigns to avoid multi-driver)
        lines.append("    // Rready (master → slave)")
        lines.append(f"    assign {prefix}rready = {master.name}_slave_select_ar[{slave_idx}] ? {master.name}_{suffix}_rready : '0;")
        lines.append("")

        return lines

    def _generate_response_muxes(self) -> List[str]:
        """
        Generate response MUX logic to OR together slave responses.

        For each master and width combination, generate OR-based muxing of:
        - Write responses: awready, wready, b.* (uses slave_select_aw)
        - Read responses: arready, r.* (uses slave_select_ar)

        This avoids multiple driver errors from individual slave routing.
        """
        lines = []

        lines.append("    // ================================================================")
        lines.append("    // Response MUXes (OR together all slave responses)")
        lines.append("    // ================================================================")
        lines.append("")

        # Generate response muxes for each master
        for master in self.masters:
            # Get unique widths this master connects to
            widths = self._get_connected_slave_widths(master)

            # Generate muxes for each width path
            for width in widths:
                suffix = f"{width}b"

                lines.append(f"    // Master: {master.name}, Width path: {suffix}")

                # Write channel responses (if master has write channels)
                if master.channels in ["wr", "rw"]:
                    lines.extend(self._generate_write_response_mux(master, width, suffix))

                # Read channel responses (if master has read channels)
                if master.channels in ["rd", "rw"]:
                    lines.extend(self._generate_read_response_mux(master, width, suffix))

                lines.append("")

        return lines

    def _generate_write_response_mux(self, master: MasterConfig, width: int,
                                     suffix: str) -> List[str]:
        """Generate write response MUX (awready, wready, b.*) using slave prefixes."""
        lines = []

        # Helper to get slave signal prefix using SignalNaming convention
        def get_slave_prefix(slave: SlaveInfo) -> str:
            return f"{slave.name}_axi_"

        # Find slaves at this width that master connects to
        connected_slaves = []
        for slave_idx in master.slave_connections:
            if self.slaves[slave_idx].data_width == width:
                connected_slaves.append((slave_idx, self.slaves[slave_idx]))

        if not connected_slaves:
            return lines

        # Generate awready MUX
        lines.append(f"    assign {master.name}_{suffix}_awready = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_aw[{slave_idx}] ? {prefix}awready : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        # Generate wready MUX
        lines.append(f"    assign {master.name}_{suffix}_wready = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_aw[{slave_idx}] ? {prefix}wready : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        # Generate B channel MUXes (bid, bresp, bvalid)
        lines.append(f"    assign {master.name}_{suffix}_b.id = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_aw[{slave_idx}] ? {prefix}bid : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        lines.append(f"    assign {master.name}_{suffix}_b.resp = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_aw[{slave_idx}] ? {prefix}bresp : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        lines.append(f"    assign {master.name}_{suffix}_bvalid = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_aw[{slave_idx}] ? {prefix}bvalid : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        return lines

    def _generate_read_response_mux(self, master: MasterConfig, width: int,
                                    suffix: str) -> List[str]:
        """Generate read response MUX (arready, r.*) using slave prefixes."""
        lines = []

        # Helper to get slave signal prefix using SignalNaming convention
        def get_slave_prefix(slave: SlaveInfo) -> str:
            return f"{slave.name}_axi_"

        # Find slaves at this width that master connects to
        connected_slaves = []
        for slave_idx in master.slave_connections:
            if self.slaves[slave_idx].data_width == width:
                connected_slaves.append((slave_idx, self.slaves[slave_idx]))

        if not connected_slaves:
            return lines

        # Generate arready MUX
        lines.append(f"    assign {master.name}_{suffix}_arready = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_ar[{slave_idx}] ? {prefix}arready : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        # Generate R channel MUXes (rid, rdata, rresp, rlast, rvalid)
        lines.append(f"    assign {master.name}_{suffix}_r.id = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_ar[{slave_idx}] ? {prefix}rid : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        lines.append(f"    assign {master.name}_{suffix}_r.data = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            # Explicitly size the default value to match the slave's data width
            mux_terms.append(f"        ({master.name}_slave_select_ar[{slave_idx}] ? {prefix}rdata : {width}'b0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        lines.append(f"    assign {master.name}_{suffix}_r.resp = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_ar[{slave_idx}] ? {prefix}rresp : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        lines.append(f"    assign {master.name}_{suffix}_r.last = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_ar[{slave_idx}] ? {prefix}rlast : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        lines.append(f"    assign {master.name}_{suffix}_rvalid = ")
        mux_terms = []
        for slave_idx, slave in connected_slaves:
            prefix = get_slave_prefix(slave)
            mux_terms.append(f"        ({master.name}_slave_select_ar[{slave_idx}] ? {prefix}rvalid : '0)")
        lines.append(" |\n".join(mux_terms) + ";")
        lines.append("")

        return lines

    def _calculate_lcd_width_for_apb(self, master: MasterConfig) -> int:
        """
        Calculate LCD (Lowest Common Denominator) width for APB slave connections.

        Args:
            master: Master to calculate LCD for

        Returns:
            LCD width in bits
        """
        apb_slave_indices = [idx for idx in master.slave_connections
                             if self.slaves[idx].protocol == 'apb']

        if not apb_slave_indices:
            return master.data_width

        # Find all masters connecting to these APB slaves
        connecting_masters = []
        seen_names = set()

        for apb_idx in apb_slave_indices:
            for m in self.masters:
                if apb_idx in m.slave_connections and m.name not in seen_names:
                    connecting_masters.append(m)
                    seen_names.add(m.name)

        if not connecting_masters:
            return master.data_width

        lcd_width = min(m.data_width for m in connecting_masters)
        return lcd_width

    def _get_connected_slave_widths(self, master: MasterConfig) -> List[int]:
        """
        Get sorted list of unique ADAPTER OUTPUT widths for slaves this master connects to.

        For AXI4 slaves: uses native slave width
        For APB slaves: uses LCD (Lowest Common Denominator) width
        """
        widths = set()

        # Separate AXI4 and APB slaves
        axi4_slave_indices = [idx for idx in master.slave_connections
                              if self.slaves[idx].protocol == 'axi4']
        apb_slave_indices = [idx for idx in master.slave_connections
                             if self.slaves[idx].protocol == 'apb']

        # For AXI4 slaves: use their native widths
        for idx in axi4_slave_indices:
            widths.add(self.slaves[idx].data_width)

        # For APB slaves: use LCD width
        if apb_slave_indices:
            lcd_width = self._calculate_lcd_width_for_apb(master)
            widths.add(lcd_width)

        return sorted(list(widths))

    def _get_masters_connecting_to_slave(self, slave: SlaveInfo) -> List[MasterConfig]:
        """
        Get list of masters that connect to a specific slave.

        Args:
            slave: Slave to check connections for

        Returns:
            List of MasterConfig objects that have this slave in their connections
        """
        # Find slave index
        try:
            slave_idx = self.slaves.index(slave)
        except ValueError:
            return []

        # Find all masters that connect to this slave
        connecting_masters = []
        for master in self.masters:
            if slave_idx in master.slave_connections:
                connecting_masters.append(master)

        return connecting_masters

    def _determine_slave_interface_width(self, slave: SlaveInfo) -> tuple:
        """
        Determine the correct AXI4 interface width for a slave.

        For all slaves (both AXI4 and APB), the crossbar interface uses the slave's
        native data width. Width converters in the master adapter handle any width
        mismatches between master and slave.

        This allows multiple slaves of the same width to share the same width-specific
        bus from the master adapter, even if they have different protocols.

        Example:
          - periph_rd (AXI4, 32b) and apb_periph (APB, 32b) both share cpu_rd_32b_* bus
          - Master adapter's width converter handles 64b master → 32b crossbar conversion

        Args:
            slave: Slave configuration

        Returns:
            (data_width, addr_width) tuple for the slave's AXI4 interface
        """
        # All slaves use their native data width at the crossbar interface
        # Width adaptation happens in the master adapter, not the crossbar
        return (slave.data_width, 32)  # Use global 32-bit address width
