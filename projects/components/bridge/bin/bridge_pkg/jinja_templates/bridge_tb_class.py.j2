#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# {{ tb_class_name }} - Testbench for {{ rtl_module_name }}
# Generated by bridge test generator from CSV configuration

import os
import sys

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from CocoTBFramework.tbclasses.shared.tbbase import TBBase
from CocoTBFramework.components.gaxi.gaxi_master import GAXIMaster
from CocoTBFramework.components.gaxi.gaxi_slave import GAXISlave
from CocoTBFramework.components.axi4.axi4_field_configs import AXI4FieldConfigHelper
from CocoTBFramework.components.apb.apb_components import APBMaster, APBSlave


class {{ tb_class_name }}(TBBase):
    """
    Testbench for {{ rtl_module_name }} bridge

    Configuration:
        Masters: {{ num_masters }} ({{ master_names }})
        Slaves:  {{ num_slaves }} ({{ slave_names }})
        Channels: {{ channel_type.upper() }}
        Data Width: {{ data_width }}
        Addr Width: {{ addr_width }}
        ID Width: {{ id_width }}
    """

    def __init__(self, dut):
        super().__init__(dut)
        self.dut = dut
        self.clock = dut.aclk
        self.clock_name = 'aclk'
        self.reset_n = dut.aresetn

        # Bridge configuration
        self.num_masters = {{ num_masters }}
        self.num_slaves = {{ num_slaves }}
        self.data_width = {{ data_width }}
        self.addr_width = {{ addr_width }}
        self.id_width = {{ id_width }}

        # Slave protocol types (for protocol-specific response handling)
        self.slave_protocols = {
{% for slave in slaves %}
            {{ loop.index0 }}: '{{ slave.protocol }}',  # {{ slave.port_name }}
{% endfor %}
        }

        # GAXI components for each master (slave interfaces on bridge)
{% for master in masters %}
        self._setup_master_{{ loop.index0 }}_{{ master.port_name }}()
{% endfor %}

        # GAXI components for each slave (master interfaces on bridge)
{% for slave in slaves %}
        self._setup_slave_{{ loop.index0 }}_{{ slave.port_name }}()
{% endfor %}

{%- for master in masters %}

    def _setup_master_{{ loop.index0 }}_{{ master.port_name }}(self):
        """Setup GAXI components for master {{ loop.index0 }}: {{ master.port_name }}"""
{% if master.has_write_channels() %}
        # AW channel (master {{ loop.index0 }} write address)
        self.aw_m{{ loop.index0 }} = GAXIMaster(
            dut=self.dut,
            title="AW_M{{ loop.index0 }}",
            prefix="{{ master.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                {{ 8 if master.id_width == 0 else master.id_width }}, {{ master.addr_width }}, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (master {{ loop.index0 }} write data)
        self.w_m{{ loop.index0 }} = GAXIMaster(
            dut=self.dut,
            title="W_M{{ loop.index0 }}",
            prefix="{{ master.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                {{ master.data_width }}, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (master {{ loop.index0 }} write response)
        self.b_m{{ loop.index0 }} = GAXISlave(
            dut=self.dut,
            title="B_M{{ loop.index0 }}",
            prefix="{{ master.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                {{ 8 if master.id_width == 0 else master.id_width }}, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
{%- endif %}
{%- if master.has_read_channels() %}

        # AR channel (master {{ loop.index0 }} read address)
        self.ar_m{{ loop.index0 }} = GAXIMaster(
            dut=self.dut,
            title="AR_M{{ loop.index0 }}",
            prefix="{{ master.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                {{ 8 if master.id_width == 0 else master.id_width }}, {{ master.addr_width }}, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (master {{ loop.index0 }} read data)
        self.r_m{{ loop.index0 }} = GAXISlave(
            dut=self.dut,
            title="R_M{{ loop.index0 }}",
            prefix="{{ master.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                {{ 8 if master.id_width == 0 else master.id_width }}, {{ master.data_width }}, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
{%- endif %}
{%- endfor %}

{%- for slave in slaves %}

    def _setup_slave_{{ loop.index0 }}_{{ slave.port_name }}(self):
        """Setup components for slave {{ loop.index0 }}: {{ slave.port_name }} (protocol: {{ slave.protocol }})"""
{%- if slave.protocol.lower() == 'apb' %}
        # APB protocol slave - use APB BFMs
        # APB Slave BFM (simulates APB slave device responding to transactions)
        self.apb_slave_{{ loop.index0 }} = APBSlave(
            entity=self.dut,
            title="APB_S{{ loop.index0 }}",
            prefix="{{ slave.prefix }}",
            clock=self.clock,
            registers=[0] * {{ slave.addr_range }},  # Initialize register space
            bus_width={{ slave.data_width }},
            addr_width={{ slave.addr_width }},
            log=self.log
        )
{%- else %}
        # AXI4 protocol slave - use GAXI BFMs
{%- if slave.has_write_channels() %}
        # AW channel (slave {{ loop.index0 }} write address)
        self.aw_s{{ loop.index0 }} = GAXISlave(
            dut=self.dut,
            title="AW_S{{ loop.index0 }}",
            prefix="{{ slave.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                {{ 8 if slave.id_width == 0 else slave.id_width }}, {{ slave.addr_width }}, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (slave {{ loop.index0 }} write data)
        self.w_s{{ loop.index0 }} = GAXISlave(
            dut=self.dut,
            title="W_S{{ loop.index0 }}",
            prefix="{{ slave.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                {{ slave.data_width }}, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (slave {{ loop.index0 }} write response)
        self.b_s{{ loop.index0 }} = GAXIMaster(
            dut=self.dut,
            title="B_S{{ loop.index0 }}",
            prefix="{{ slave.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                {{ 8 if slave.id_width == 0 else slave.id_width }}, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
{%- endif %}
{%- if slave.has_read_channels() %}

        # AR channel (slave {{ loop.index0 }} read address)
        self.ar_s{{ loop.index0 }} = GAXISlave(
            dut=self.dut,
            title="AR_S{{ loop.index0 }}",
            prefix="{{ slave.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                {{ 8 if slave.id_width == 0 else slave.id_width }}, {{ slave.addr_width }}, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (slave {{ loop.index0 }} read data)
        self.r_s{{ loop.index0 }} = GAXIMaster(
            dut=self.dut,
            title="R_S{{ loop.index0 }}",
            prefix="{{ slave.prefix }}",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                {{ 8 if slave.id_width == 0 else slave.id_width }}, {{ slave.data_width }}, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
{%- endif %}
{%- endif %}
{%- endfor %}

    async def setup_clocks_and_reset(self):
        """Complete initialization - starts clocks and performs reset"""
        await self.start_clock(self.clock_name, freq=10, units='ns')

        # Reset sequence
        await self.assert_reset()
        await self.wait_clocks(self.clock_name, 10)
        await self.deassert_reset()
        await self.wait_clocks(self.clock_name, 5)

    async def assert_reset(self):
        """Assert reset signal (active-low for AXI4)"""
        self.reset_n.value = 0

    async def deassert_reset(self):
        """Deassert reset signal"""
        self.reset_n.value = 1

    async def write_transaction(self, master_idx, address, data, burst_len=1, txn_id=0):
        """
        Perform a write transaction from specified master

        Args:
            master_idx: Master index (0-{{ num_masters - 1 }})
            address: Target address
            data: Data value or list of data values
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master components
        aw_master = getattr(self, f'aw_m{master_idx}')
        w_master = getattr(self, f'w_m{master_idx}')

        # Send AW
        aw_pkt = aw_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x{{ '%x' % ((data_width // 8).bit_length() - 1) }},
            burst=0x1  # INCR
        )
        await aw_master.send(aw_pkt)

        # Send W data
        if not isinstance(data, list):
            data = [data]

        for i, d in enumerate(data):
            w_pkt = w_master.create_packet(
                data=d,
                strb=(1 << ({{ data_width }} // 8)) - 1,
                last=1 if i == len(data) - 1 else 0
            )
            await w_master.send(w_pkt)

    async def read_transaction(self, master_idx, address, burst_len=1, txn_id=0):
        """
        Perform a read transaction from specified master

        Args:
            master_idx: Master index (0-{{ num_masters - 1 }})
            address: Target address
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master component
        ar_master = getattr(self, f'ar_m{master_idx}')

        # Send AR
        ar_pkt = ar_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x{{ '%x' % ((data_width // 8).bit_length() - 1) }},
            burst=0x1  # INCR
        )
        await ar_master.send(ar_pkt)

    async def slave_respond_write(self, slave_idx, txn_id=0, resp=0):
        """
        Send write response from specified slave

        Args:
            slave_idx: Slave index (0-{{ num_slaves - 1 }})
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual B channel response needed
            pass
        else:
            # AXI4 slave - send B response
            b_master = getattr(self, f'b_s{slave_idx}')

            b_pkt = b_master.create_packet(
                id=txn_id,
                resp=resp
            )
            await b_master.send(b_pkt)

    async def slave_respond_read(self, slave_idx, data, txn_id=0, resp=0, last=True):
        """
        Send read response from specified slave

        Args:
            slave_idx: Slave index (0-{{ num_slaves - 1 }})
            data: Data value or list of data values
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
            last: Last beat in burst
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual R channel response needed
            pass
        else:
            # AXI4 slave - send R response
            r_master = getattr(self, f'r_s{slave_idx}')

            if not isinstance(data, list):
                data = [data]

            for i, d in enumerate(data):
                r_pkt = r_master.create_packet(
                    id=txn_id,
                    data=d,
                    resp=resp,
                    last=1 if (i == len(data) - 1 and last) else 0
                )
                await r_master.send(r_pkt)
