#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# Test file for {{ rtl_module_name }}
# Generated by bridge test generator from CSV configuration
#
# Configuration:
#   Masters: {{ num_masters }} ({{ master_names }})
#   Slaves:  {{ num_slaves }} ({{ slave_names }})
#   Channels: {{ channel_type.upper() }}

import os
import sys
import pytest
import logging

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)
sys.path.insert(0, os.path.join(repo_root, 'bin'))

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from cocotb_test.simulator import run
from CocoTBFramework.tbclasses.shared.utilities import get_paths
from CocoTBFramework.tbclasses.shared.filelist_utils import get_sources_from_filelist

# Import generated testbench class
from projects.components.bridge.dv.tbclasses.{{ tb_class_module }} import {{ tb_class_name }}


# ============================================================================
# CocoTB Test Functions (prefixed with cocotb_test_* to prevent pytest collection)
# ============================================================================

@cocotb.test(timeout_time=200, timeout_unit="ms")
async def cocotb_test_basic_connectivity(dut):
    """
    Basic connectivity test - verify master-to-slave routing

    Test plan:
{% if channel_type == 'wr' or channel_type == 'rw' %}
    1. Initialize testbench
    2. For each master:
        - Send write to each connected slave
        - Verify address decode routes to correct slave
        - Slave responds with OKAY
        - Verify response reaches master
{% endif %}
{% if channel_type == 'rd' or channel_type == 'rw' %}
    3. For each master:
        - Send read to each connected slave
        - Verify address decode routes to correct slave
        - Slave responds with data
        - Verify response reaches master
{% endif %}
    """
    tb = {{ tb_class_name }}(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting basic connectivity test")
    tb.log.info(f"Configuration: {{ num_masters }}M x {{ num_slaves }}S, {{ channel_type.upper() }} channels")
    tb.log.info("=" * 80)

{% if channel_type == 'wr' or channel_type == 'rw' %}
    # Write connectivity test
{% for master_idx in range(num_masters) %}
{% set master = masters[master_idx] %}
{% if master.has_write_channels() %}
    tb.log.info(f"Testing master {{ master_idx }} ({{ master.port_name }}) write connectivity")
{% for slave in slaves %}
{% if slave.port_name in connectivity.get(master.port_name, []) %}
{% if slave.has_write_channels() %}

    # Master {{ master_idx }} → Slave {{ loop.index0 }} ({{ slave.port_name }})
    test_addr = {{ '0x%08x' % slave.base_addr }}
    test_data = 0xDEADBEEF{{ '%02d' % loop.index0 }}
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx={{ master_idx }},
        address=test_addr,
        data=test_data,
        txn_id={{ master_idx }}
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx={{ loop.index0 }},
        txn_id={{ master_idx }},
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")
{% endif %}
{% endif %}
{% endfor %}
{% endif %}
{% endfor %}
{% endif %}

{%- if channel_type == 'rd' or channel_type == 'rw' %}
    # Read connectivity test
{%- for master_idx in range(num_masters) %}
{%- set master = masters[master_idx] %}
{%- if master.has_read_channels() %}
    tb.log.info(f"Testing master {{ master_idx }} ({{ master.port_name }}) read connectivity")
{%- for slave in slaves %}
{%- if slave.port_name in connectivity.get(master.port_name, []) %}
{%- if slave.has_read_channels() %}

    # Master {{ master_idx }} → Slave {{ loop.index0 }} ({{ slave.port_name }})
    test_addr = {{ '0x%08x' % (slave.base_addr + 0x100) }}
    test_data = 0xCAFEBABE{{ '%02d' % loop.index0 }}
    tb.log.info(f"  Read: addr=0x{test_addr:08x}, expect_data=0x{test_data:08x}")

    # Master sends read transaction
    await tb.read_transaction(
        master_idx={{ master_idx }},
        address=test_addr,
        txn_id={{ master_idx }}
    )

    # Wait for read to propagate
    await ClockCycles(tb.clock, 5)

    # Slave responds with data
    await tb.slave_respond_read(
        slave_idx={{ loop.index0 }},
        data=test_data,
        txn_id={{ master_idx }},
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    tb.log.info(f"  Read completed successfully")
{% endif %}
{% endif %}
{% endfor %}
{% endif %}
{% endfor %}
{% endif %}

    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Basic connectivity test PASSED")
    tb.log.info("=" * 80)


@cocotb.test(timeout_time=500, timeout_unit="ms")
async def cocotb_test_address_decode(dut):
    """
    Address decode verification test

    Test plan:
    1. For each master:
        - Send transactions to boundary addresses of each slave region
        - Verify correct slave is selected via address decode
        - Test: base_addr, base_addr + range - 1, out-of-range addresses
    """
    tb = {{ tb_class_name }}(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting address decode test")
    tb.log.info("=" * 80)

{%- for master_idx in range(num_masters) %}
{%- set master = masters[master_idx] %}
{%- if master.has_write_channels() or master.has_read_channels() %}
    # Master {{ master_idx }}: {{ master.port_name }}
    tb.log.info(f"Testing master {{ master_idx }} address decode")
{%- for slave in slaves %}
{%- if slave.port_name in connectivity.get(master.port_name, []) %}

    # Slave {{ loop.index0 }}: {{ slave.port_name }}
    # Range: {{ '0x%08x' % slave.base_addr }} - {{ '0x%08x' % (slave.base_addr + slave.addr_range - 1) }}
    tb.log.info(f"  Slave {{ loop.index0 }} ({{ slave.port_name }}): 0x{{ '%08x' % slave.base_addr }}-0x{{ '%08x' % (slave.base_addr + slave.addr_range - 1) }}")

{%- if master.has_write_channels() and slave.has_write_channels() %}
    # Test base address
    await tb.write_transaction({{ master_idx }}, {{ '0x%08x' % slave.base_addr }}, 0x{{ '%08x' % (0x00000000 + loop.index0) }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write({{ loop.index0 }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction({{ master_idx }}, {{ '0x%08x' % (slave.base_addr + slave.addr_range - 4) }}, 0x{{ '%08x' % (0x11111111 + loop.index0) }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write({{ loop.index0 }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)
{%- elif master.has_read_channels() and slave.has_read_channels() %}
    # Test base address
    await tb.read_transaction({{ master_idx }}, {{ '0x%08x' % slave.base_addr }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_read({{ loop.index0 }}, 0x{{ '%08x' % (0x22222222 + loop.index0) }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.read_transaction({{ master_idx }}, {{ '0x%08x' % (slave.base_addr + slave.addr_range - 4) }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_read({{ loop.index0 }}, 0x{{ '%08x' % (0x33333333 + loop.index0) }}, txn_id={{ master_idx }})
    await ClockCycles(tb.clock, 3)
{%- endif %}
{%- endif %}
{%- endfor %}
{%- endif %}
{%- endfor %}

    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Address decode test PASSED")
    tb.log.info("=" * 80)


{%- if num_masters > 1 %}

@cocotb.test(timeout_time=1000, timeout_unit="ms")
async def cocotb_test_arbitration(dut):
    """
    Multi-master arbitration test

    Test plan:
    1. Multiple masters simultaneously request same slave
    2. Verify round-robin arbitration grants access
    3. Verify non-winning masters are backpressured
    4. Verify transactions complete correctly
    """
    tb = {{ tb_class_name }}(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting arbitration test")
    tb.log.info("=" * 80)

    # TODO: Implement concurrent transaction test
    # This requires cocotb.start_soon() for parallel master activity

    await ClockCycles(tb.clock, 100)
    tb.log.info("Arbitration test PASSED")
{%- endif %}


# ============================================================================
# Pytest Wrapper Functions (collected by pytest, call specific cocotb_test_*)
# ============================================================================

def test_{{ rtl_module_name }}_basic_connectivity(request):
    """Pytest wrapper for basic connectivity test"""

    # Get standard paths
    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '{{ rtl_relative_path }}',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "{{ rtl_module_name }}"

    # Get sources from filelist
    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='{{ filelist_path }}'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_{{ rtl_module_name }}_basic_connectivity"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    # Compilation arguments
    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_basic_connectivity",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_basic',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )


def test_{{ rtl_module_name }}_address_decode(request):
    """Pytest wrapper for address decode test"""

    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '{{ rtl_relative_path }}',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "{{ rtl_module_name }}"

    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='{{ filelist_path }}'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_{{ rtl_module_name }}_address_decode"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_address_decode",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_decode',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )


{%- if num_masters > 1 %}

def test_{{ rtl_module_name }}_arbitration(request):
    """Pytest wrapper for arbitration test"""

    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '{{ rtl_relative_path }}',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "{{ rtl_module_name }}"

    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='{{ filelist_path }}'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_{{ rtl_module_name }}_arbitration"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_arbitration",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_arb',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )
{%- endif %}


if __name__ == "__main__":
    # Run pytest on this file
    pytest.main([__file__, '-v', '-s'])
