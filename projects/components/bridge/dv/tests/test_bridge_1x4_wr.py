#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# Test file for bridge_1x4_wr
# Generated by bridge test generator from CSV configuration
#
# Configuration:
#   Masters: 1 (cpu_wr)
#   Slaves:  4 (periph_wr, ddr_wr, hbm_wr, apb_periph)
#   Channels: WR

import os
import sys
import pytest
import logging

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)
sys.path.insert(0, os.path.join(repo_root, 'bin'))

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from cocotb_test.simulator import run
from CocoTBFramework.tbclasses.shared.utilities import get_paths
from CocoTBFramework.tbclasses.shared.filelist_utils import get_sources_from_filelist

# Import generated testbench class
from projects.components.bridge.dv.tbclasses.bridge1x4_wr_tb import Bridge1x4WrTB


# ============================================================================
# CocoTB Test Functions (prefixed with cocotb_test_* to prevent pytest collection)
# ============================================================================

@cocotb.test(timeout_time=200, timeout_unit="ms")
async def cocotb_test_basic_connectivity(dut):
    """
    Basic connectivity test - verify master-to-slave routing

    Test plan:
    1. Initialize testbench
    2. For each master:
        - Send write to each connected slave
        - Verify address decode routes to correct slave
        - Slave responds with OKAY
        - Verify response reaches master
    """
    tb = Bridge1x4WrTB(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting basic connectivity test")
    tb.log.info(f"Configuration: 1M x 4S, WR channels")
    tb.log.info("=" * 80)

    tb.log.info("=== Scenario BRIDGE-1x4-01: Four-way address routing ===")
    tb.log.info("=== Scenario BRIDGE-1x4-02: AXI4 slave routing ===")
    tb.log.info("=== Scenario BRIDGE-1x4-05: Transaction ID preservation ===")
    tb.log.info("=== Scenario BRIDGE-1x4-07: Backpressure per slave ===")

    # Write connectivity test
    tb.log.info(f"Testing master 0 (cpu_wr) write connectivity")

    # Master 0 → Slave 0 (periph_wr)
    test_addr = 0x00000000
    test_data = 0xDEADBEEF00
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=0,
        address=test_addr,
        data=test_data,
        txn_id=0
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=0,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")

    # Master 0 → Slave 1 (ddr_wr)
    test_addr = 0x10000000
    test_data = 0xDEADBEEF01
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=0,
        address=test_addr,
        data=test_data,
        txn_id=0
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=1,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")

    # Master 0 → Slave 2 (hbm_wr)
    test_addr = 0x50000000
    test_data = 0xDEADBEEF02
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=0,
        address=test_addr,
        data=test_data,
        txn_id=0
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=2,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")

    # Master 0 → Slave 3 (apb_periph)
    test_addr = 0x80000000
    test_data = 0xDEADBEEF03
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=0,
        address=test_addr,
        data=test_data,
        txn_id=0
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=3,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")

    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Basic connectivity test PASSED")
    tb.log.info("=" * 80)


@cocotb.test(timeout_time=500, timeout_unit="ms")
async def cocotb_test_address_decode(dut):
    """
    Address decode verification test

    Test plan:
    1. For each master:
        - Send transactions to boundary addresses of each slave region
        - Verify correct slave is selected via address decode
        - Test: base_addr, base_addr + range - 1, out-of-range addresses
    """
    tb = Bridge1x4WrTB(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting address decode test")
    tb.log.info("=" * 80)    # Master 0: cpu_wr
    tb.log.info(f"Testing master 0 address decode")
    # Slave 0: periph_wr
    # Range: 0x00000000 - 0x0fffffff
    tb.log.info(f"  Slave 0 (periph_wr): 0x00000000-0x0fffffff")    # Test base address
    await tb.write_transaction(0, 0x00000000, 0x00000000, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(0, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(0, 0x0ffffffc, 0x11111111, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(0, txn_id=0)
    await ClockCycles(tb.clock, 3)
    # Slave 1: ddr_wr
    # Range: 0x10000000 - 0x4fffffff
    tb.log.info(f"  Slave 1 (ddr_wr): 0x10000000-0x4fffffff")    # Test base address
    await tb.write_transaction(0, 0x10000000, 0x00000001, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(1, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(0, 0x4ffffffc, 0x11111112, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(1, txn_id=0)
    await ClockCycles(tb.clock, 3)
    # Slave 2: hbm_wr
    # Range: 0x50000000 - 0x7fffffff
    tb.log.info(f"  Slave 2 (hbm_wr): 0x50000000-0x7fffffff")    # Test base address
    await tb.write_transaction(0, 0x50000000, 0x00000002, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(2, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(0, 0x7ffffffc, 0x11111113, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(2, txn_id=0)
    await ClockCycles(tb.clock, 3)
    # Slave 3: apb_periph
    # Range: 0x80000000 - 0x8000ffff
    tb.log.info(f"  Slave 3 (apb_periph): 0x80000000-0x8000ffff")    # Test base address
    await tb.write_transaction(0, 0x80000000, 0x00000003, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(3, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(0, 0x8000fffc, 0x11111114, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(3, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Address decode test PASSED")
    tb.log.info("=" * 80)

# ============================================================================
# Pytest Wrapper Functions (collected by pytest, call specific cocotb_test_*)
# ============================================================================

def test_bridge_1x4_wr_basic_connectivity(request):
    """Pytest wrapper for basic connectivity test"""

    # Get standard paths
    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '../../../../rtl/bridge',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "bridge_1x4_wr"

    # Get sources from filelist
    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='projects/components/bridge/rtl/filelists/bridge_1x4_wr.f'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_bridge_1x4_wr_basic_connectivity"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    # Compilation arguments
    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_basic_connectivity",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_basic',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )


def test_bridge_1x4_wr_address_decode(request):
    """Pytest wrapper for address decode test"""

    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '../../../../rtl/bridge',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "bridge_1x4_wr"

    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='projects/components/bridge/rtl/filelists/bridge_1x4_wr.f'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_bridge_1x4_wr_address_decode"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_address_decode",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_decode',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )

if __name__ == "__main__":
    # Run pytest on this file
    pytest.main([__file__, '-v', '-s'])