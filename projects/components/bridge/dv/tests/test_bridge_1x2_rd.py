#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# Test file for bridge_1x2_rd
# Generated by bridge test generator from CSV configuration
#
# Configuration:
#   Masters: 1 (cpu_rd)
#   Slaves:  2 (ddr_rd, sram_rd)
#   Channels: RD

import os
import sys
import pytest
import logging

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)
sys.path.insert(0, os.path.join(repo_root, 'bin'))

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from cocotb_test.simulator import run
from CocoTBFramework.tbclasses.shared.utilities import get_paths
from CocoTBFramework.tbclasses.shared.filelist_utils import get_sources_from_filelist

# Import generated testbench class
from projects.components.bridge.dv.tbclasses.bridge1x2_rd_tb import Bridge1x2RdTB


# ============================================================================
# CocoTB Test Functions (prefixed with cocotb_test_* to prevent pytest collection)
# ============================================================================

@cocotb.test(timeout_time=200, timeout_unit="ms")
async def cocotb_test_basic_connectivity(dut):
    """
    Basic connectivity test - verify master-to-slave routing

    Test plan:
    3. For each master:
        - Send read to each connected slave
        - Verify address decode routes to correct slave
        - Slave responds with data
        - Verify response reaches master
    """
    tb = Bridge1x2RdTB(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting basic connectivity test")
    tb.log.info(f"Configuration: 1M x 2S, RD channels")
    tb.log.info("=" * 80)

    # Read connectivity test    tb.log.info(f"Testing master 0 (cpu_rd) read connectivity")
    # Master 0 → Slave 0 (ddr_rd)
    test_addr = 0x00000100
    test_data = 0xCAFEBABE00
    tb.log.info(f"  Read: addr=0x{test_addr:08x}, expect_data=0x{test_data:08x}")

    # Master sends read transaction
    await tb.read_transaction(
        master_idx=0,
        address=test_addr,
        txn_id=0
    )

    # Wait for read to propagate
    await ClockCycles(tb.clock, 5)

    # Slave responds with data
    await tb.slave_respond_read(
        slave_idx=0,
        data=test_data,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    tb.log.info(f"  Read completed successfully")

    # Master 0 → Slave 1 (sram_rd)
    test_addr = 0x80000100
    test_data = 0xCAFEBABE01
    tb.log.info(f"  Read: addr=0x{test_addr:08x}, expect_data=0x{test_data:08x}")

    # Master sends read transaction
    await tb.read_transaction(
        master_idx=0,
        address=test_addr,
        txn_id=0
    )

    # Wait for read to propagate
    await ClockCycles(tb.clock, 5)

    # Slave responds with data
    await tb.slave_respond_read(
        slave_idx=1,
        data=test_data,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    tb.log.info(f"  Read completed successfully")

    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Basic connectivity test PASSED")
    tb.log.info("=" * 80)


@cocotb.test(timeout_time=500, timeout_unit="ms")
async def cocotb_test_address_decode(dut):
    """
    Address decode verification test

    Test plan:
    1. For each master:
        - Send transactions to boundary addresses of each slave region
        - Verify correct slave is selected via address decode
        - Test: base_addr, base_addr + range - 1, out-of-range addresses
    """
    tb = Bridge1x2RdTB(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting address decode test")
    tb.log.info("=" * 80)    # Master 0: cpu_rd
    tb.log.info(f"Testing master 0 address decode")
    # Slave 0: ddr_rd
    # Range: 0x00000000 - 0x7fffffff
    tb.log.info(f"  Slave 0 (ddr_rd): 0x00000000-0x7fffffff")    # Test base address
    await tb.read_transaction(0, 0x00000000, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_read(0, 0x22222222, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.read_transaction(0, 0x7ffffffc, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_read(0, 0x33333333, txn_id=0)
    await ClockCycles(tb.clock, 3)
    # Slave 1: sram_rd
    # Range: 0x80000000 - 0xffffffff
    tb.log.info(f"  Slave 1 (sram_rd): 0x80000000-0xffffffff")    # Test base address
    await tb.read_transaction(0, 0x80000000, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_read(1, 0x22222223, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.read_transaction(0, 0xfffffffc, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_read(1, 0x33333334, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Address decode test PASSED")
    tb.log.info("=" * 80)

# ============================================================================
# Pytest Wrapper Functions (collected by pytest, call specific cocotb_test_*)
# ============================================================================

def test_bridge_1x2_rd_basic_connectivity(request):
    """Pytest wrapper for basic connectivity test"""

    # Get standard paths
    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '../../../../rtl/bridge',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "bridge_1x2_rd"

    # Get sources from filelist
    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='projects/components/bridge/rtl/filelists/bridge_1x2_rd.f'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_bridge_1x2_rd_basic_connectivity"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    # Compilation arguments
    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_basic_connectivity",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_basic',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )


def test_bridge_1x2_rd_address_decode(request):
    """Pytest wrapper for address decode test"""

    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '../../../../rtl/bridge',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "bridge_1x2_rd"

    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='projects/components/bridge/rtl/filelists/bridge_1x2_rd.f'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_bridge_1x2_rd_address_decode"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_address_decode",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_decode',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )

if __name__ == "__main__":
    # Run pytest on this file
    pytest.main([__file__, '-v', '-s'])