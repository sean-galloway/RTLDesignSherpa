#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# Test file for bridge_2x2_rw
# Generated by bridge test generator from CSV configuration
#
# Configuration:
#   Masters: 2 (cpu, dma)
#   Slaves:  2 (ddr, sram)
#   Channels: RW

import os
import sys
import pytest
import logging

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)
sys.path.insert(0, os.path.join(repo_root, 'bin'))

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from cocotb_test.simulator import run
from CocoTBFramework.tbclasses.shared.utilities import get_paths
from CocoTBFramework.tbclasses.shared.filelist_utils import get_sources_from_filelist

# Import generated testbench class
from projects.components.bridge.dv.tbclasses.bridge2x2_rw_tb import Bridge2x2RwTB


# ============================================================================
# CocoTB Test Functions (prefixed with cocotb_test_* to prevent pytest collection)
# ============================================================================

@cocotb.test(timeout_time=200, timeout_unit="ms")
async def cocotb_test_basic_connectivity(dut):
    """
    Basic connectivity test - verify master-to-slave routing

    Test plan:
    1. Initialize testbench
    2. For each master:
        - Send write to each connected slave
        - Verify address decode routes to correct slave
        - Slave responds with OKAY
        - Verify response reaches master
    3. For each master:
        - Send read to each connected slave
        - Verify address decode routes to correct slave
        - Slave responds with data
        - Verify response reaches master
    """
    tb = Bridge2x2RwTB(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting basic connectivity test")
    tb.log.info(f"Configuration: 2M x 2S, RW channels")
    tb.log.info("=" * 80)

    # Write connectivity test
    tb.log.info(f"Testing master 0 (cpu) write connectivity")

    # Master 0 → Slave 0 (ddr)
    test_addr = 0x00000000
    test_data = 0xDEADBEEF00
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=0,
        address=test_addr,
        data=test_data,
        txn_id=0
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=0,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")

    # Master 0 → Slave 1 (sram)
    test_addr = 0x80000000
    test_data = 0xDEADBEEF01
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=0,
        address=test_addr,
        data=test_data,
        txn_id=0
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=1,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")
    tb.log.info(f"Testing master 1 (dma) write connectivity")

    # Master 1 → Slave 0 (ddr)
    test_addr = 0x00000000
    test_data = 0xDEADBEEF00
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=1,
        address=test_addr,
        data=test_data,
        txn_id=1
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=0,
        txn_id=1,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")

    # Master 1 → Slave 1 (sram)
    test_addr = 0x80000000
    test_data = 0xDEADBEEF01
    tb.log.info(f"  Write: addr=0x{test_addr:08x}, data=0x{test_data:08x}")

    # Master sends write transaction
    await tb.write_transaction(
        master_idx=1,
        address=test_addr,
        data=test_data,
        txn_id=1
    )

    # Wait for write to propagate through bridge
    await ClockCycles(tb.clock, 5)

    # Slave responds
    await tb.slave_respond_write(
        slave_idx=1,
        txn_id=1,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    # Verify response received at master (check via monitor)
    tb.log.info(f"  Write completed successfully")
    # Read connectivity test    tb.log.info(f"Testing master 0 (cpu) read connectivity")
    # Master 0 → Slave 0 (ddr)
    test_addr = 0x00000100
    test_data = 0xCAFEBABE00
    tb.log.info(f"  Read: addr=0x{test_addr:08x}, expect_data=0x{test_data:08x}")

    # Master sends read transaction
    await tb.read_transaction(
        master_idx=0,
        address=test_addr,
        txn_id=0
    )

    # Wait for read to propagate
    await ClockCycles(tb.clock, 5)

    # Slave responds with data
    await tb.slave_respond_read(
        slave_idx=0,
        data=test_data,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    tb.log.info(f"  Read completed successfully")

    # Master 0 → Slave 1 (sram)
    test_addr = 0x80000100
    test_data = 0xCAFEBABE01
    tb.log.info(f"  Read: addr=0x{test_addr:08x}, expect_data=0x{test_data:08x}")

    # Master sends read transaction
    await tb.read_transaction(
        master_idx=0,
        address=test_addr,
        txn_id=0
    )

    # Wait for read to propagate
    await ClockCycles(tb.clock, 5)

    # Slave responds with data
    await tb.slave_respond_read(
        slave_idx=1,
        data=test_data,
        txn_id=0,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    tb.log.info(f"  Read completed successfully")
    tb.log.info(f"Testing master 1 (dma) read connectivity")
    # Master 1 → Slave 0 (ddr)
    test_addr = 0x00000100
    test_data = 0xCAFEBABE00
    tb.log.info(f"  Read: addr=0x{test_addr:08x}, expect_data=0x{test_data:08x}")

    # Master sends read transaction
    await tb.read_transaction(
        master_idx=1,
        address=test_addr,
        txn_id=1
    )

    # Wait for read to propagate
    await ClockCycles(tb.clock, 5)

    # Slave responds with data
    await tb.slave_respond_read(
        slave_idx=0,
        data=test_data,
        txn_id=1,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    tb.log.info(f"  Read completed successfully")

    # Master 1 → Slave 1 (sram)
    test_addr = 0x80000100
    test_data = 0xCAFEBABE01
    tb.log.info(f"  Read: addr=0x{test_addr:08x}, expect_data=0x{test_data:08x}")

    # Master sends read transaction
    await tb.read_transaction(
        master_idx=1,
        address=test_addr,
        txn_id=1
    )

    # Wait for read to propagate
    await ClockCycles(tb.clock, 5)

    # Slave responds with data
    await tb.slave_respond_read(
        slave_idx=1,
        data=test_data,
        txn_id=1,
        resp=0  # OKAY
    )

    # Wait for response to return
    await ClockCycles(tb.clock, 5)

    tb.log.info(f"  Read completed successfully")

    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Basic connectivity test PASSED")
    tb.log.info("=" * 80)


@cocotb.test(timeout_time=500, timeout_unit="ms")
async def cocotb_test_address_decode(dut):
    """
    Address decode verification test

    Test plan:
    1. For each master:
        - Send transactions to boundary addresses of each slave region
        - Verify correct slave is selected via address decode
        - Test: base_addr, base_addr + range - 1, out-of-range addresses
    """
    tb = Bridge2x2RwTB(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting address decode test")
    tb.log.info("=" * 80)    # Master 0: cpu
    tb.log.info(f"Testing master 0 address decode")
    # Slave 0: ddr
    # Range: 0x00000000 - 0x7fffffff
    tb.log.info(f"  Slave 0 (ddr): 0x00000000-0x7fffffff")    # Test base address
    await tb.write_transaction(0, 0x00000000, 0x00000000, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(0, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(0, 0x7ffffffc, 0x11111111, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(0, txn_id=0)
    await ClockCycles(tb.clock, 3)
    # Slave 1: sram
    # Range: 0x80000000 - 0xffffffff
    tb.log.info(f"  Slave 1 (sram): 0x80000000-0xffffffff")    # Test base address
    await tb.write_transaction(0, 0x80000000, 0x00000001, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(1, txn_id=0)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(0, 0xfffffffc, 0x11111112, txn_id=0)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(1, txn_id=0)
    await ClockCycles(tb.clock, 3)    # Master 1: dma
    tb.log.info(f"Testing master 1 address decode")
    # Slave 0: ddr
    # Range: 0x00000000 - 0x7fffffff
    tb.log.info(f"  Slave 0 (ddr): 0x00000000-0x7fffffff")    # Test base address
    await tb.write_transaction(1, 0x00000000, 0x00000000, txn_id=1)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(0, txn_id=1)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(1, 0x7ffffffc, 0x11111111, txn_id=1)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(0, txn_id=1)
    await ClockCycles(tb.clock, 3)
    # Slave 1: sram
    # Range: 0x80000000 - 0xffffffff
    tb.log.info(f"  Slave 1 (sram): 0x80000000-0xffffffff")    # Test base address
    await tb.write_transaction(1, 0x80000000, 0x00000001, txn_id=1)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(1, txn_id=1)
    await ClockCycles(tb.clock, 3)

    # Test end address
    await tb.write_transaction(1, 0xfffffffc, 0x11111112, txn_id=1)
    await ClockCycles(tb.clock, 3)
    await tb.slave_respond_write(1, txn_id=1)
    await ClockCycles(tb.clock, 3)
    await ClockCycles(tb.clock, 20)
    tb.log.info("=" * 80)
    tb.log.info("Address decode test PASSED")
    tb.log.info("=" * 80)
@cocotb.test(timeout_time=1000, timeout_unit="ms")
async def cocotb_test_arbitration(dut):
    """
    Multi-master arbitration test

    Test plan:
    1. Multiple masters simultaneously request same slave
    2. Verify round-robin arbitration grants access
    3. Verify non-winning masters are backpressured
    4. Verify transactions complete correctly
    """
    tb = Bridge2x2RwTB(dut)
    await tb.setup_clocks_and_reset()

    tb.log.info("=" * 80)
    tb.log.info("Starting arbitration test")
    tb.log.info("=" * 80)

    # TODO: Implement concurrent transaction test
    # This requires cocotb.start_soon() for parallel master activity

    await ClockCycles(tb.clock, 100)
    tb.log.info("Arbitration test PASSED")

# ============================================================================
# Pytest Wrapper Functions (collected by pytest, call specific cocotb_test_*)
# ============================================================================

def test_bridge_2x2_rw_basic_connectivity(request):
    """Pytest wrapper for basic connectivity test"""

    # Get standard paths
    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '../../../../rtl/bridge',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "bridge_2x2_rw"

    # Get sources from filelist
    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='projects/components/bridge/rtl/filelists/bridge_2x2_rw.f'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_bridge_2x2_rw_basic_connectivity"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    # Compilation arguments
    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_basic_connectivity",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_basic',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )


def test_bridge_2x2_rw_address_decode(request):
    """Pytest wrapper for address decode test"""

    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '../../../../rtl/bridge',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "bridge_2x2_rw"

    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='projects/components/bridge/rtl/filelists/bridge_2x2_rw.f'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_bridge_2x2_rw_address_decode"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_address_decode",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_decode',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )
def test_bridge_2x2_rw_arbitration(request):
    """Pytest wrapper for arbitration test"""

    module, repo_root, tests_dir, log_dir, rtl_dict = get_paths({
        'rtl_bridge': '../../../../rtl/bridge',
        'rtl_common': '../../../../rtl/common',
        'rtl_amba': '../../../../rtl/amba'
    })

    dut_name = "bridge_2x2_rw"

    verilog_sources, includes = get_sources_from_filelist(
        repo_root=repo_root,
        filelist_path='projects/components/bridge/rtl/filelists/bridge_2x2_rw.f'
    )

    # Note: New adapter-based bridge has NO parameters
    # All configuration is fixed from YAML at generation time

    # Get worker ID for parallel execution isolation
    worker_id = os.environ.get('PYTEST_XDIST_WORKER', 'gw0')
    test_name = f"test_{worker_id}_bridge_2x2_rw_arbitration"
    log_path = os.path.join(log_dir, f'{test_name}.log')

    # VCD waveform generation support via WAVES environment variable
    compile_args = []
    if int(os.environ.get('WAVES', '0')) == 1:
        compile_args.extend([
            "--trace",                  # VCD tracing
            "--trace-depth", "99",      # Full depth
            "--trace-max-array", "1024" # Array tracing
        ])

    extra_args = [
        '--assert',
        '--coverage'
    ]
    extra_args.extend(compile_args)

    # Environment variables for cocotb
    extra_env = {
        'COCOTB_LOG_LEVEL': 'INFO',
        'LOG_PATH': log_path
    }

    run(
        python_search=[tests_dir],
        verilog_sources=verilog_sources,
        includes=includes,
        toplevel=dut_name,
        module=module,
        testcase="cocotb_test_arbitration",  # Call specific cocotb function
        # Note: No parameters - new bridge has fixed config from YAML
        sim_build=f'{log_dir}/sim_build_{dut_name}_arb',
        work_dir=log_dir,
        test_dir=log_dir,
        waves=False,  # Use compile_args for VCD control via WAVES env var
        extra_args=extra_args,
        extra_env=extra_env
    )

if __name__ == "__main__":
    # Run pytest on this file
    pytest.main([__file__, '-v', '-s'])