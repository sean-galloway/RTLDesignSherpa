#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# BridgeTestApbBridgeTB - Testbench for test_apb_bridge
# Generated by bridge test generator from CSV configuration

import os
import sys

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from CocoTBFramework.tbclasses.shared.tbbase import TBBase
from CocoTBFramework.components.gaxi.gaxi_master import GAXIMaster
from CocoTBFramework.components.gaxi.gaxi_slave import GAXISlave
from CocoTBFramework.components.axi4.axi4_field_configs import AXI4FieldConfigHelper


class BridgeTestApbBridgeTB(TBBase):
    """
    Testbench for test_apb_bridge bridge

    Configuration:
        Masters: 1 (cpu_master)
        Slaves:  1 (apb_periph)
        Channels: RW
        Data Width: 64
        Addr Width: 64
        ID Width: 8
    """

    def __init__(self, dut):
        # CRITICAL: Bridge tests need higher memory limits
        # Verilator compilation uses significant memory (20-80GB total system memory)
        safety_limits = {
            'max_memory_mb': 32768,  # 32GB limit (safe for bridge tests)
            'enable_safety_monitoring': True,
        }
        super().__init__(dut, safety_limits=safety_limits)
        self.dut = dut
        self.clock = dut.aclk
        self.clock_name = 'aclk'
        self.reset_n = dut.aresetn

        # Bridge configuration
        self.num_masters = 1
        self.num_slaves = 1
        self.data_width = 64
        self.addr_width = 64
        self.id_width = 8

        # GAXI components for each master (slave interfaces on bridge)
        self._setup_master_0_cpu_master()

        # GAXI components for each slave (master interfaces on bridge)
        self._setup_slave_0_apb_periph()

    def _setup_master_0_cpu_master(self):
        """Setup GAXI components for master 0: cpu_master"""
        # AW channel (master 0 write address)
        self.aw_m0 = GAXIMaster(
            dut=self.dut,
            title="AW_M0",
            prefix="cpu_m_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                4, 32, 1
            ),
            pkt_prefix="aw",
            timeout_cycles=200,  # Bridge routing delay
            multi_sig=True,            log=self.log
        )

        # W channel (master 0 write data)
        self.w_m0 = GAXIMaster(
            dut=self.dut,
            title="W_M0",
            prefix="cpu_m_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                64, 1
            ),
            pkt_prefix="w",
            timeout_cycles=200,  # Bridge routing delay
            multi_sig=True,            log=self.log
        )

        # B channel (master 0 write response)
        self.b_m0 = GAXISlave(
            dut=self.dut,
            title="B_M0",
            prefix="cpu_m_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                4, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
        # AR channel (master 0 read address)
        self.ar_m0 = GAXIMaster(
            dut=self.dut,
            title="AR_M0",
            prefix="cpu_m_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                4, 32, 1
            ),
            pkt_prefix="ar",
            timeout_cycles=200,  # Bridge routing delay
            multi_sig=True,            log=self.log
        )

        # R channel (master 0 read data)
        self.r_m0 = GAXISlave(
            dut=self.dut,
            title="R_M0",
            prefix="cpu_m_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                4, 64, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_0_apb_periph(self):
        """Setup GAXI components for slave 0: apb_periph"""        # AW channel (slave 0 write address)
        self.aw_s0 = GAXISlave(
            dut=self.dut,
            title="AW_S0",
            prefix="apb_periph_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                8, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (slave 0 write data)
        self.w_s0 = GAXISlave(
            dut=self.dut,
            title="W_S0",
            prefix="apb_periph_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                32, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (slave 0 write response)
        self.b_s0 = GAXIMaster(
            dut=self.dut,
            title="B_S0",
            prefix="apb_periph_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                8, 1
            ),
            pkt_prefix="b",
            timeout_cycles=200,  # Bridge routing delay
            multi_sig=True,            log=self.log
        )
        # AR channel (slave 0 read address)
        self.ar_s0 = GAXISlave(
            dut=self.dut,
            title="AR_S0",
            prefix="apb_periph_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                8, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (slave 0 read data)
        self.r_s0 = GAXIMaster(
            dut=self.dut,
            title="R_S0",
            prefix="apb_periph_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                8, 32, 1
            ),
            pkt_prefix="r",
            timeout_cycles=200,  # Bridge routing delay
            multi_sig=True,            log=self.log
        )
    async def setup_clocks_and_reset(self):
        """Complete initialization - starts clocks and performs reset"""
        await self.start_clock(self.clock_name, freq=10, units='ns')

        # Reset sequence
        await self.assert_reset()
        await self.wait_clocks(self.clock_name, 10)
        await self.deassert_reset()
        await self.wait_clocks(self.clock_name, 5)

    async def assert_reset(self):
        """Assert reset signal (active-low for AXI4)"""
        self.reset_n.value = 0

    async def deassert_reset(self):
        """Deassert reset signal"""
        self.reset_n.value = 1

    async def write_transaction(self, master_idx, address, data, burst_len=1, txn_id=0):
        """
        Perform a write transaction from specified master

        Args:
            master_idx: Master index (0-0)
            address: Target address
            data: Data value or list of data values
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master components
        aw_master = getattr(self, f'aw_m{master_idx}')
        w_master = getattr(self, f'w_m{master_idx}')

        # Send AW
        aw_pkt = aw_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x3,
            burst=0x1  # INCR
        )
        await aw_master.send(aw_pkt)

        # Send W data
        if not isinstance(data, list):
            data = [data]

        for i, d in enumerate(data):
            w_pkt = w_master.create_packet(
                data=d,
                strb=(1 << (64 // 8)) - 1,
                last=1 if i == len(data) - 1 else 0
            )
            await w_master.send(w_pkt)

    async def read_transaction(self, master_idx, address, burst_len=1, txn_id=0):
        """
        Perform a read transaction from specified master

        Args:
            master_idx: Master index (0-0)
            address: Target address
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master component
        ar_master = getattr(self, f'ar_m{master_idx}')

        # Send AR
        ar_pkt = ar_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x3,
            burst=0x1  # INCR
        )
        await ar_master.send(ar_pkt)

    async def slave_respond_write(self, slave_idx, txn_id=0, resp=0):
        """
        Send write response from specified slave

        Args:
            slave_idx: Slave index (0-0)
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
        """
        b_master = getattr(self, f'b_s{slave_idx}')

        b_pkt = b_master.create_packet(
            id=txn_id,
            resp=resp
        )
        await b_master.send(b_pkt)

    async def slave_respond_read(self, slave_idx, data, txn_id=0, resp=0, last=True):
        """
        Send read response from specified slave

        Args:
            slave_idx: Slave index (0-0)
            data: Data value or list of data values
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
            last: Last beat in burst
        """
        r_master = getattr(self, f'r_s{slave_idx}')

        if not isinstance(data, list):
            data = [data]

        for i, d in enumerate(data):
            r_pkt = r_master.create_packet(
                id=txn_id,
                data=d,
                resp=resp,
                last=1 if (i == len(data) - 1 and last) else 0
            )
            await r_master.send(r_pkt)