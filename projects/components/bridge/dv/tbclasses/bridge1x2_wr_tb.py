#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# Bridge1x2WrTB - Testbench for bridge_1x2_wr
# Generated by bridge test generator from CSV configuration

import os
import sys

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from CocoTBFramework.tbclasses.shared.tbbase import TBBase
from CocoTBFramework.components.gaxi.gaxi_master import GAXIMaster
from CocoTBFramework.components.gaxi.gaxi_slave import GAXISlave
from CocoTBFramework.components.axi4.axi4_field_configs import AXI4FieldConfigHelper
from CocoTBFramework.components.apb.apb_components import APBMaster, APBSlave


class Bridge1x2WrTB(TBBase):
    """
    Testbench for bridge_1x2_wr bridge

    Configuration:
        Masters: 1 (cpu_wr)
        Slaves:  2 (ddr_wr, sram_wr)
        Channels: WR
        Data Width: 32
        Addr Width: 64
        ID Width: 8
    """

    def __init__(self, dut):
        super().__init__(dut)
        self.dut = dut
        self.clock = dut.aclk
        self.clock_name = 'aclk'
        self.reset_n = dut.aresetn

        # Bridge configuration
        self.num_masters = 1
        self.num_slaves = 2
        self.data_width = 32
        self.addr_width = 64
        self.id_width = 8

        # Slave protocol types (for protocol-specific response handling)
        self.slave_protocols = {
            0: 'axi4',  # ddr_wr
            1: 'axi4',  # sram_wr
        }

        # GAXI components for each master (slave interfaces on bridge)
        self._setup_master_0_cpu_wr()

        # GAXI components for each slave (master interfaces on bridge)
        self._setup_slave_0_ddr_wr()
        self._setup_slave_1_sram_wr()

    def _setup_master_0_cpu_wr(self):
        """Setup GAXI components for master 0: cpu_wr"""
        # AW channel (master 0 write address)
        self.aw_m0 = GAXIMaster(
            dut=self.dut,
            title="AW_M0",
            prefix="cpu_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                4, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (master 0 write data)
        self.w_m0 = GAXIMaster(
            dut=self.dut,
            title="W_M0",
            prefix="cpu_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                32, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (master 0 write response)
        self.b_m0 = GAXISlave(
            dut=self.dut,
            title="B_M0",
            prefix="cpu_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                4, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_0_ddr_wr(self):
        """Setup components for slave 0: ddr_wr (protocol: axi4)"""        # AXI4 protocol slave - use GAXI BFMs        # AW channel (slave 0 write address)
        self.aw_s0 = GAXISlave(
            dut=self.dut,
            title="AW_S0",
            prefix="ddr_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                4, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (slave 0 write data)
        self.w_s0 = GAXISlave(
            dut=self.dut,
            title="W_S0",
            prefix="ddr_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                32, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (slave 0 write response)
        self.b_s0 = GAXIMaster(
            dut=self.dut,
            title="B_S0",
            prefix="ddr_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                4, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_1_sram_wr(self):
        """Setup components for slave 1: sram_wr (protocol: axi4)"""        # AXI4 protocol slave - use GAXI BFMs        # AW channel (slave 1 write address)
        self.aw_s1 = GAXISlave(
            dut=self.dut,
            title="AW_S1",
            prefix="sram_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                4, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (slave 1 write data)
        self.w_s1 = GAXISlave(
            dut=self.dut,
            title="W_S1",
            prefix="sram_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                32, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (slave 1 write response)
        self.b_s1 = GAXIMaster(
            dut=self.dut,
            title="B_S1",
            prefix="sram_wr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                4, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
    async def setup_clocks_and_reset(self):
        """Complete initialization - starts clocks and performs reset"""
        await self.start_clock(self.clock_name, freq=10, units='ns')

        # Reset sequence
        await self.assert_reset()
        await self.wait_clocks(self.clock_name, 10)
        await self.deassert_reset()
        await self.wait_clocks(self.clock_name, 5)

    async def assert_reset(self):
        """Assert reset signal (active-low for AXI4)"""
        self.reset_n.value = 0

    async def deassert_reset(self):
        """Deassert reset signal"""
        self.reset_n.value = 1

    async def write_transaction(self, master_idx, address, data, burst_len=1, txn_id=0):
        """
        Perform a write transaction from specified master

        Args:
            master_idx: Master index (0-0)
            address: Target address
            data: Data value or list of data values
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master components
        aw_master = getattr(self, f'aw_m{master_idx}')
        w_master = getattr(self, f'w_m{master_idx}')

        # Send AW
        aw_pkt = aw_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x2,
            burst=0x1  # INCR
        )
        await aw_master.send(aw_pkt)

        # Send W data
        if not isinstance(data, list):
            data = [data]

        for i, d in enumerate(data):
            w_pkt = w_master.create_packet(
                data=d,
                strb=(1 << (32 // 8)) - 1,
                last=1 if i == len(data) - 1 else 0
            )
            await w_master.send(w_pkt)

    async def read_transaction(self, master_idx, address, burst_len=1, txn_id=0):
        """
        Perform a read transaction from specified master

        Args:
            master_idx: Master index (0-0)
            address: Target address
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master component
        ar_master = getattr(self, f'ar_m{master_idx}')

        # Send AR
        ar_pkt = ar_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x2,
            burst=0x1  # INCR
        )
        await ar_master.send(ar_pkt)

    async def slave_respond_write(self, slave_idx, txn_id=0, resp=0):
        """
        Send write response from specified slave

        Args:
            slave_idx: Slave index (0-1)
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual B channel response needed
            pass
        else:
            # AXI4 slave - send B response
            b_master = getattr(self, f'b_s{slave_idx}')

            b_pkt = b_master.create_packet(
                id=txn_id,
                resp=resp
            )
            await b_master.send(b_pkt)

    async def slave_respond_read(self, slave_idx, data, txn_id=0, resp=0, last=True):
        """
        Send read response from specified slave

        Args:
            slave_idx: Slave index (0-1)
            data: Data value or list of data values
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
            last: Last beat in burst
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual R channel response needed
            pass
        else:
            # AXI4 slave - send R response
            r_master = getattr(self, f'r_s{slave_idx}')

            if not isinstance(data, list):
                data = [data]

            for i, d in enumerate(data):
                r_pkt = r_master.create_packet(
                    id=txn_id,
                    data=d,
                    resp=resp,
                    last=1 if (i == len(data) - 1 and last) else 0
                )
                await r_master.send(r_pkt)