#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# Bridge1x4RdTB - Testbench for bridge_1x4_rd
# Generated by bridge test generator from CSV configuration

import os
import sys

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from CocoTBFramework.tbclasses.shared.tbbase import TBBase
from CocoTBFramework.components.gaxi.gaxi_master import GAXIMaster
from CocoTBFramework.components.gaxi.gaxi_slave import GAXISlave
from CocoTBFramework.components.axi4.axi4_field_configs import AXI4FieldConfigHelper
from CocoTBFramework.components.apb.apb_components import APBMaster, APBSlave


class Bridge1x4RdTB(TBBase):
    """
    Testbench for bridge_1x4_rd bridge

    Configuration:
        Masters: 1 (cpu_rd)
        Slaves:  4 (periph_rd, ddr_rd, hbm_rd, apb_periph)
        Channels: RD
        Data Width: 128
        Addr Width: 64
        ID Width: 8
    """

    def __init__(self, dut):
        super().__init__(dut)
        self.dut = dut
        self.clock = dut.aclk
        self.clock_name = 'aclk'
        self.reset_n = dut.aresetn

        # Bridge configuration
        self.num_masters = 1
        self.num_slaves = 4
        self.data_width = 128
        self.addr_width = 64
        self.id_width = 8

        # Slave protocol types (for protocol-specific response handling)
        self.slave_protocols = {
            0: 'axi4',  # periph_rd
            1: 'axi4',  # ddr_rd
            2: 'axi4',  # hbm_rd
            3: 'apb',  # apb_periph
        }

        # GAXI components for each master (slave interfaces on bridge)
        self._setup_master_0_cpu_rd()

        # GAXI components for each slave (master interfaces on bridge)
        self._setup_slave_0_periph_rd()
        self._setup_slave_1_ddr_rd()
        self._setup_slave_2_hbm_rd()
        self._setup_slave_3_apb_periph()

    def _setup_master_0_cpu_rd(self):
        """Setup GAXI components for master 0: cpu_rd"""

        # AR channel (master 0 read address)
        self.ar_m0 = GAXIMaster(
            dut=self.dut,
            title="AR_M0",
            prefix="cpu_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                4, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (master 0 read data)
        self.r_m0 = GAXISlave(
            dut=self.dut,
            title="R_M0",
            prefix="cpu_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                4, 64, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_0_periph_rd(self):
        """Setup components for slave 0: periph_rd (protocol: axi4)"""        # AXI4 protocol slave - use GAXI BFMs
        # AR channel (slave 0 read address)
        self.ar_s0 = GAXISlave(
            dut=self.dut,
            title="AR_S0",
            prefix="periph_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                4, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (slave 0 read data)
        self.r_s0 = GAXIMaster(
            dut=self.dut,
            title="R_S0",
            prefix="periph_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                4, 32, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_1_ddr_rd(self):
        """Setup components for slave 1: ddr_rd (protocol: axi4)"""        # AXI4 protocol slave - use GAXI BFMs
        # AR channel (slave 1 read address)
        self.ar_s1 = GAXISlave(
            dut=self.dut,
            title="AR_S1",
            prefix="ddr_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                4, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (slave 1 read data)
        self.r_s1 = GAXIMaster(
            dut=self.dut,
            title="R_S1",
            prefix="ddr_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                4, 64, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_2_hbm_rd(self):
        """Setup components for slave 2: hbm_rd (protocol: axi4)"""        # AXI4 protocol slave - use GAXI BFMs
        # AR channel (slave 2 read address)
        self.ar_s2 = GAXISlave(
            dut=self.dut,
            title="AR_S2",
            prefix="hbm_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                4, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (slave 2 read data)
        self.r_s2 = GAXIMaster(
            dut=self.dut,
            title="R_S2",
            prefix="hbm_rd_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                4, 128, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_3_apb_periph(self):
        """Setup components for slave 3: apb_periph (protocol: apb)"""        # APB protocol slave - use APB BFMs
        # APB Slave BFM (simulates APB slave device responding to transactions)
        self.apb_slave_3 = APBSlave(
            entity=self.dut,
            title="APB_S3",
            prefix="apb_periph_",
            clock=self.clock,
            registers=[0] * 65536,  # Initialize register space
            bus_width=32,
            addr_width=32,
            log=self.log
        )
    async def setup_clocks_and_reset(self):
        """Complete initialization - starts clocks and performs reset"""
        await self.start_clock(self.clock_name, freq=10, units='ns')

        # Reset sequence
        await self.assert_reset()
        await self.wait_clocks(self.clock_name, 10)
        await self.deassert_reset()
        await self.wait_clocks(self.clock_name, 5)

    async def assert_reset(self):
        """Assert reset signal (active-low for AXI4)"""
        self.reset_n.value = 0

    async def deassert_reset(self):
        """Deassert reset signal"""
        self.reset_n.value = 1

    async def write_transaction(self, master_idx, address, data, burst_len=1, txn_id=0):
        """
        Perform a write transaction from specified master

        Args:
            master_idx: Master index (0-0)
            address: Target address
            data: Data value or list of data values
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master components
        aw_master = getattr(self, f'aw_m{master_idx}')
        w_master = getattr(self, f'w_m{master_idx}')

        # Send AW
        aw_pkt = aw_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x4,
            burst=0x1  # INCR
        )
        await aw_master.send(aw_pkt)

        # Send W data
        if not isinstance(data, list):
            data = [data]

        for i, d in enumerate(data):
            w_pkt = w_master.create_packet(
                data=d,
                strb=(1 << (128 // 8)) - 1,
                last=1 if i == len(data) - 1 else 0
            )
            await w_master.send(w_pkt)

    async def read_transaction(self, master_idx, address, burst_len=1, txn_id=0):
        """
        Perform a read transaction from specified master

        Args:
            master_idx: Master index (0-0)
            address: Target address
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master component
        ar_master = getattr(self, f'ar_m{master_idx}')

        # Send AR
        ar_pkt = ar_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x4,
            burst=0x1  # INCR
        )
        await ar_master.send(ar_pkt)

    async def slave_respond_write(self, slave_idx, txn_id=0, resp=0):
        """
        Send write response from specified slave

        Args:
            slave_idx: Slave index (0-3)
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual B channel response needed
            pass
        else:
            # AXI4 slave - send B response
            b_master = getattr(self, f'b_s{slave_idx}')

            b_pkt = b_master.create_packet(
                id=txn_id,
                resp=resp
            )
            await b_master.send(b_pkt)

    async def slave_respond_read(self, slave_idx, data, txn_id=0, resp=0, last=True):
        """
        Send read response from specified slave

        Args:
            slave_idx: Slave index (0-3)
            data: Data value or list of data values
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
            last: Last beat in burst
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual R channel response needed
            pass
        else:
            # AXI4 slave - send R response
            r_master = getattr(self, f'r_s{slave_idx}')

            if not isinstance(data, list):
                data = [data]

            for i, d in enumerate(data):
                r_pkt = r_master.create_packet(
                    id=txn_id,
                    data=d,
                    resp=resp,
                    last=1 if (i == len(data) - 1 and last) else 0
                )
                await r_master.send(r_pkt)