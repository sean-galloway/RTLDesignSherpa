#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# Bridge5x3ChannelsTB - Testbench for bridge_5x3_channels
# Generated by bridge test generator from CSV configuration

import os
import sys

# Add repo root to path
repo_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../../../..'))
sys.path.insert(0, repo_root)

import cocotb
from cocotb.triggers import RisingEdge, ClockCycles
from CocoTBFramework.tbclasses.shared.tbbase import TBBase
from CocoTBFramework.components.gaxi.gaxi_master import GAXIMaster
from CocoTBFramework.components.gaxi.gaxi_slave import GAXISlave
from CocoTBFramework.components.axi4.axi4_field_configs import AXI4FieldConfigHelper
from CocoTBFramework.components.apb.apb_components import APBMaster, APBSlave


class Bridge5x3ChannelsTB(TBBase):
    """
    Testbench for bridge_5x3_channels bridge

    Configuration:
        Masters: 5 (descr_wr_master, sink_wr_master, src_rd_master, stream_master, cpu_master)
        Slaves:  3 (sram_buffer, ddr_controller, apb_periph)
        Channels: RW
        Data Width: 256
        Addr Width: 64
        ID Width: 8
    """

    def __init__(self, dut):
        super().__init__(dut)
        self.dut = dut
        self.clock = dut.aclk
        self.clock_name = 'aclk'
        self.reset_n = dut.aresetn

        # Bridge configuration
        self.num_masters = 5
        self.num_slaves = 3
        self.data_width = 256
        self.addr_width = 64
        self.id_width = 8

        # Slave protocol types (for protocol-specific response handling)
        self.slave_protocols = {
            0: 'axi4',  # sram_buffer
            1: 'axi4',  # ddr_controller
            2: 'apb',  # apb_periph
        }

        # GAXI components for each master (slave interfaces on bridge)
        self._setup_master_0_descr_wr_master()
        self._setup_master_1_sink_wr_master()
        self._setup_master_2_src_rd_master()
        self._setup_master_3_stream_master()
        self._setup_master_4_cpu_master()

        # GAXI components for each slave (master interfaces on bridge)
        self._setup_slave_0_sram_buffer()
        self._setup_slave_1_ddr_controller()
        self._setup_slave_2_apb_periph()

    def _setup_master_0_descr_wr_master(self):
        """Setup GAXI components for master 0: descr_wr_master"""
        # AW channel (master 0 write address)
        self.aw_m0 = GAXIMaster(
            dut=self.dut,
            title="AW_M0",
            prefix="descr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                8, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (master 0 write data)
        self.w_m0 = GAXIMaster(
            dut=self.dut,
            title="W_M0",
            prefix="descr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                256, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (master 0 write response)
        self.b_m0 = GAXISlave(
            dut=self.dut,
            title="B_M0",
            prefix="descr_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                8, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
    def _setup_master_1_sink_wr_master(self):
        """Setup GAXI components for master 1: sink_wr_master"""
        # AW channel (master 1 write address)
        self.aw_m1 = GAXIMaster(
            dut=self.dut,
            title="AW_M1",
            prefix="sink_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                8, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (master 1 write data)
        self.w_m1 = GAXIMaster(
            dut=self.dut,
            title="W_M1",
            prefix="sink_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                256, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (master 1 write response)
        self.b_m1 = GAXISlave(
            dut=self.dut,
            title="B_M1",
            prefix="sink_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                8, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
    def _setup_master_2_src_rd_master(self):
        """Setup GAXI components for master 2: src_rd_master"""

        # AR channel (master 2 read address)
        self.ar_m2 = GAXIMaster(
            dut=self.dut,
            title="AR_M2",
            prefix="src_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                8, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (master 2 read data)
        self.r_m2 = GAXISlave(
            dut=self.dut,
            title="R_M2",
            prefix="src_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                8, 256, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_master_3_stream_master(self):
        """Setup GAXI components for master 3: stream_master"""
        # AW channel (master 3 write address)
        self.aw_m3 = GAXIMaster(
            dut=self.dut,
            title="AW_M3",
            prefix="stream_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                8, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (master 3 write data)
        self.w_m3 = GAXIMaster(
            dut=self.dut,
            title="W_M3",
            prefix="stream_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                256, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (master 3 write response)
        self.b_m3 = GAXISlave(
            dut=self.dut,
            title="B_M3",
            prefix="stream_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                8, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
        # AR channel (master 3 read address)
        self.ar_m3 = GAXIMaster(
            dut=self.dut,
            title="AR_M3",
            prefix="stream_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                8, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (master 3 read data)
        self.r_m3 = GAXISlave(
            dut=self.dut,
            title="R_M3",
            prefix="stream_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                8, 256, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_master_4_cpu_master(self):
        """Setup GAXI components for master 4: cpu_master"""
        # AW channel (master 4 write address)
        self.aw_m4 = GAXIMaster(
            dut=self.dut,
            title="AW_M4",
            prefix="cpu_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                8, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (master 4 write data)
        self.w_m4 = GAXIMaster(
            dut=self.dut,
            title="W_M4",
            prefix="cpu_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                64, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (master 4 write response)
        self.b_m4 = GAXISlave(
            dut=self.dut,
            title="B_M4",
            prefix="cpu_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                8, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
        # AR channel (master 4 read address)
        self.ar_m4 = GAXIMaster(
            dut=self.dut,
            title="AR_M4",
            prefix="cpu_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                8, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (master 4 read data)
        self.r_m4 = GAXISlave(
            dut=self.dut,
            title="R_M4",
            prefix="cpu_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                8, 64, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_0_sram_buffer(self):
        """Setup components for slave 0: sram_buffer (protocol: axi4)"""        # AXI4 protocol slave - use GAXI BFMs        # AW channel (slave 0 write address)
        self.aw_s0 = GAXISlave(
            dut=self.dut,
            title="AW_S0",
            prefix="sram_buffer_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                8, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (slave 0 write data)
        self.w_s0 = GAXISlave(
            dut=self.dut,
            title="W_S0",
            prefix="sram_buffer_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                256, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (slave 0 write response)
        self.b_s0 = GAXIMaster(
            dut=self.dut,
            title="B_S0",
            prefix="sram_buffer_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                8, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
        # AR channel (slave 0 read address)
        self.ar_s0 = GAXISlave(
            dut=self.dut,
            title="AR_S0",
            prefix="sram_buffer_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                8, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (slave 0 read data)
        self.r_s0 = GAXIMaster(
            dut=self.dut,
            title="R_S0",
            prefix="sram_buffer_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                8, 256, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_1_ddr_controller(self):
        """Setup components for slave 1: ddr_controller (protocol: axi4)"""        # AXI4 protocol slave - use GAXI BFMs        # AW channel (slave 1 write address)
        self.aw_s1 = GAXISlave(
            dut=self.dut,
            title="AW_S1",
            prefix="ddr_controller_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_aw_field_config(
                8, 32, 1
            ),
            pkt_prefix="aw",
            multi_sig=True,
            log=self.log
        )

        # W channel (slave 1 write data)
        self.w_s1 = GAXISlave(
            dut=self.dut,
            title="W_S1",
            prefix="ddr_controller_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_w_field_config(
                256, 1
            ),
            pkt_prefix="w",
            multi_sig=True,
            log=self.log
        )

        # B channel (slave 1 write response)
        self.b_s1 = GAXIMaster(
            dut=self.dut,
            title="B_S1",
            prefix="ddr_controller_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_b_field_config(
                8, 1
            ),
            pkt_prefix="b",
            multi_sig=True,
            log=self.log
        )
        # AR channel (slave 1 read address)
        self.ar_s1 = GAXISlave(
            dut=self.dut,
            title="AR_S1",
            prefix="ddr_controller_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_ar_field_config(
                8, 32, 1
            ),
            pkt_prefix="ar",
            multi_sig=True,
            log=self.log
        )

        # R channel (slave 1 read data)
        self.r_s1 = GAXIMaster(
            dut=self.dut,
            title="R_S1",
            prefix="ddr_controller_axi_",
            clock=self.clock,
            field_config=AXI4FieldConfigHelper.create_r_field_config(
                8, 256, 1
            ),
            pkt_prefix="r",
            multi_sig=True,
            log=self.log
        )
    def _setup_slave_2_apb_periph(self):
        """Setup components for slave 2: apb_periph (protocol: apb)"""        # APB protocol slave - use APB BFMs
        # APB Slave BFM (simulates APB slave device responding to transactions)
        self.apb_slave_2 = APBSlave(
            entity=self.dut,
            title="APB_S2",
            prefix="apb_periph_",
            clock=self.clock,
            registers=[0] * 268435456,  # Initialize register space
            bus_width=32,
            addr_width=32,
            log=self.log
        )
    async def setup_clocks_and_reset(self):
        """Complete initialization - starts clocks and performs reset"""
        await self.start_clock(self.clock_name, freq=10, units='ns')

        # Reset sequence
        await self.assert_reset()
        await self.wait_clocks(self.clock_name, 10)
        await self.deassert_reset()
        await self.wait_clocks(self.clock_name, 5)

    async def assert_reset(self):
        """Assert reset signal (active-low for AXI4)"""
        self.reset_n.value = 0

    async def deassert_reset(self):
        """Deassert reset signal"""
        self.reset_n.value = 1

    async def write_transaction(self, master_idx, address, data, burst_len=1, txn_id=0):
        """
        Perform a write transaction from specified master

        Args:
            master_idx: Master index (0-4)
            address: Target address
            data: Data value or list of data values
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master components
        aw_master = getattr(self, f'aw_m{master_idx}')
        w_master = getattr(self, f'w_m{master_idx}')

        # Send AW
        aw_pkt = aw_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x5,
            burst=0x1  # INCR
        )
        await aw_master.send(aw_pkt)

        # Send W data
        if not isinstance(data, list):
            data = [data]

        for i, d in enumerate(data):
            w_pkt = w_master.create_packet(
                data=d,
                strb=(1 << (256 // 8)) - 1,
                last=1 if i == len(data) - 1 else 0
            )
            await w_master.send(w_pkt)

    async def read_transaction(self, master_idx, address, burst_len=1, txn_id=0):
        """
        Perform a read transaction from specified master

        Args:
            master_idx: Master index (0-4)
            address: Target address
            burst_len: Burst length (default: 1 for single beat)
            txn_id: Transaction ID (default: 0)
        """
        # Get master component
        ar_master = getattr(self, f'ar_m{master_idx}')

        # Send AR
        ar_pkt = ar_master.create_packet(
            addr=address,
            id=txn_id,
            len=burst_len - 1,
            size=0x5,
            burst=0x1  # INCR
        )
        await ar_master.send(ar_pkt)

    async def slave_respond_write(self, slave_idx, txn_id=0, resp=0):
        """
        Send write response from specified slave

        Args:
            slave_idx: Slave index (0-2)
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual B channel response needed
            pass
        else:
            # AXI4 slave - send B response
            b_master = getattr(self, f'b_s{slave_idx}')

            b_pkt = b_master.create_packet(
                id=txn_id,
                resp=resp
            )
            await b_master.send(b_pkt)

    async def slave_respond_read(self, slave_idx, data, txn_id=0, resp=0, last=True):
        """
        Send read response from specified slave

        Args:
            slave_idx: Slave index (0-2)
            data: Data value or list of data values
            txn_id: Transaction ID to respond to
            resp: Response code (0=OKAY, 1=EXOKAY, 2=SLVERR, 3=DECERR)
            last: Last beat in burst
        """
        # Check protocol type for this slave
        protocol = self.slave_protocols.get(slave_idx, 'axi4').lower()

        if protocol == 'apb':
            # APB slaves handle response automatically via APBSlave BFM
            # No manual R channel response needed
            pass
        else:
            # AXI4 slave - send R response
            r_master = getattr(self, f'r_s{slave_idx}')

            if not isinstance(data, list):
                data = [data]

            for i, d in enumerate(data):
                r_pkt = r_master.create_packet(
                    id=txn_id,
                    data=d,
                    resp=resp,
                    last=1 if (i == len(data) - 1 and last) else 0
                )
                await r_master.send(r_pkt)