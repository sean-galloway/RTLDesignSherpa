<!-- RTL Design Sherpa Documentation Header -->
<table>
<tr>
<td width="80">
  <a href="https://github.com/sean-galloway/RTLDesignSherpa">
    <img src="https://raw.githubusercontent.com/sean-galloway/RTLDesignSherpa/main/docs/logos/Logo_200px.png" alt="RTL Design Sherpa" width="70">
  </a>
</td>
<td>
  <strong>RTL Design Sherpa</strong> · <em>Learning Hardware Design Through Practice</em><br>
  <sub>
    <a href="https://github.com/sean-galloway/RTLDesignSherpa">GitHub</a> ·
    <a href="https://github.com/sean-galloway/RTLDesignSherpa/blob/main/docs/DOCUMENTATION_INDEX.md">Documentation Index</a> ·
    <a href="https://github.com/sean-galloway/RTLDesignSherpa/blob/main/LICENSE">MIT License</a>
  </sub>
</td>
</tr>
</table>

---

<!-- End Header -->

# GAXI Drop FIFO Sync

## Overview

The `gaxi_drop_fifo_sync` module is a synchronous FIFO with dynamic drop capability. It provides standard GAXI (Generic AXI) valid/ready handshaking for both write and read operations, plus an additional drop interface for removing entries from the FIFO without reading them.

**Key Features:**
- Standard GAXI valid/ready handshaking
- Configurable data width and depth
- Drop by count (remove N oldest entries)
- Drop all (flush entire FIFO)
- I/O blocking during drop operations (3-cycle latency)
- Registered or mux-based output modes
- FIFO count and almost-full/almost-empty flags

**Location**: `rtl/amba/gaxi/gaxi_drop_fifo_sync.sv`

**Testbench**: `val/amba/test_gaxi_drop_fifo_sync.py`

## Module Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `DATA_WIDTH` | int | 32 | Width of data bus in bits |
| `DEPTH` | int | 16 | FIFO depth (must be power of 2) |
| `REGISTERED` | int | 0 | 0 = mux mode, 1 = registered output |
| `ALMOST_WR_MARGIN` | int | 1 | Threshold for almost_full flag |
| `ALMOST_RD_MARGIN` | int | 1 | Threshold for almost_empty flag |

## Interface Signals

### Clock and Reset

| Signal | Direction | Width | Description |
|--------|-----------|-------|-------------|
| `axi_aclk` | input | 1 | Clock signal |
| `axi_aresetn` | input | 1 | Active-low asynchronous reset |

### Write Interface (GAXI Master → FIFO)

| Signal | Direction | Width | Description |
|--------|-----------|-------|-------------|
| `wr_valid` | input | 1 | Write data valid |
| `wr_ready` | output | 1 | FIFO ready to accept write |
| `wr_data` | input | DATA_WIDTH | Write data |

**Handshake**: Write occurs when `wr_valid && wr_ready` on rising edge of clock.

### Read Interface (FIFO → GAXI Slave)

| Signal | Direction | Width | Description |
|--------|-----------|-------|-------------|
| `rd_valid` | output | 1 | Read data valid |
| `rd_ready` | input | 1 | Downstream ready to accept read |
| `rd_data` | output | DATA_WIDTH | Read data |

**Handshake**: Read occurs when `rd_valid && rd_ready` on rising edge of clock.

### Drop Interface

| Signal | Direction | Width | Description |
|--------|-----------|-------|-------------|
| `drop_valid` | input | 1 | Drop request valid |
| `drop_ready` | output | 1 | Drop operation complete |
| `drop_count` | input | 8 | Number of entries to drop |
| `drop_all` | input | 1 | Drop all entries (ignore count) |

**Handshake**: Drop completes when `drop_valid && drop_ready` on rising edge of clock.

**Drop Latency**: 3 clock cycles from `drop_valid` assertion to `drop_ready` assertion.

### Status Signals

| Signal | Direction | Width | Description |
|--------|-----------|-------|-------------|
| `count` | output | $clog2(DEPTH)+1 | Current number of entries in FIFO |
| `almost_full` | output | 1 | High when `count >= (DEPTH - ALMOST_WR_MARGIN)` |
| `almost_empty` | output | 1 | High when `count <= ALMOST_RD_MARGIN` |

## Drop Operation Behavior

### Drop by Count

When `drop_valid=1` and `drop_all=0`, the FIFO removes `drop_count` oldest entries:

1. **Cycle 0**: Assert `drop_valid`, set `drop_count=N`
2. **Cycle 1-2**: Drop operation in progress, `drop_ready=0`, I/O blocked
3. **Cycle 3**: Drop complete, `drop_ready=1`
4. **Result**: FIFO count decreases by min(N, current_count)

**I/O Blocking**: During drop operation (cycles 1-2):
- `wr_ready = 0` (writes blocked)
- `rd_valid = 0` (reads blocked)

### Drop All

When `drop_valid=1` and `drop_all=1`, the FIFO is completely flushed:

1. **Cycle 0**: Assert `drop_valid` and `drop_all=1`
2. **Cycle 1-2**: Drop operation in progress
3. **Cycle 3**: Drop complete, `drop_ready=1`
4. **Result**: FIFO count becomes 0

**Note**: `drop_count` is ignored when `drop_all=1`.

### Simultaneous Operations

**Write + Drop**: Blocked - writes cannot proceed during drop operation.

**Read + Drop**: Blocked - reads cannot proceed during drop operation.

**Drop + Drop**: Not supported - wait for `drop_ready` before issuing next drop.

## Timing Diagrams

### Fill FIFO

*Generated by test_gaxi_drop_fifo_wavedrom.py*

This scenario shows writing 4 entries to an empty FIFO:
- Write handshakes occur when `wr_valid && wr_ready`
- FIFO count increments with each successful write
- Data values: 0xA0, 0xA1, 0xA2, 0xA3

```
[WaveDrom diagram: gaxi_drop_fifo_fill.json]
```

### Drop by Count

*Generated by test_gaxi_drop_fifo_wavedrom.py*

This scenario demonstrates dropping 2 oldest entries:
- `drop_valid` asserted with `drop_count=2`
- 3-cycle latency until `drop_ready` assertion
- FIFO count decreases by 2
- Normal I/O blocked during drop

```
[WaveDrom diagram: gaxi_drop_fifo_drop_by_count.json]
```

### Drop All

*Generated by test_gaxi_drop_fifo_wavedrom.py*

This scenario shows flushing the entire FIFO:
- `drop_valid` asserted with `drop_all=1`
- 3-cycle latency until `drop_ready` assertion
- FIFO count becomes 0
- All entries discarded

```
[WaveDrom diagram: gaxi_drop_fifo_drop_all.json]
```

### Comprehensive Scenario

*Generated by test_gaxi_drop_fifo_wavedrom.py*

This scenario demonstrates mixed operations:
- Read 1 entry from FIFO
- Drop remaining entries with `drop_all=1`
- Shows interaction between read and drop interfaces

```
[WaveDrom diagram: gaxi_drop_fifo_comprehensive.json]
```

## Usage Examples

### Basic Write/Read

```systemverilog
// Instantiate FIFO
gaxi_drop_fifo_sync #(
    .DATA_WIDTH(32),
    .DEPTH(16),
    .REGISTERED(0)
) u_fifo (
    .axi_aclk    (clk),
    .axi_aresetn (rst_n),
    .wr_valid    (wr_valid),
    .wr_ready    (wr_ready),
    .wr_data     (wr_data),
    .rd_valid    (rd_valid),
    .rd_ready    (rd_ready),
    .rd_data     (rd_data),
    .drop_valid  (1'b0),        // No drop
    .drop_ready  (),
    .drop_count  (8'h0),
    .drop_all    (1'b0),
    .count       (fifo_count),
    .almost_full (almost_full),
    .almost_empty(almost_empty)
);

// Write logic
always_ff @(posedge clk) begin
    if (!rst_n) begin
        wr_valid <= 1'b0;
    end else if (wr_valid && wr_ready) begin
        wr_valid <= 1'b0;  // Deassert after handshake
    end else if (have_data_to_write && !almost_full) begin
        wr_valid <= 1'b1;
        wr_data  <= next_data;
    end
end
```

### Drop Operation

```systemverilog
// Drop state machine
typedef enum logic [1:0] {
    IDLE,
    DROP_WAIT,
    DROP_DONE
} drop_state_t;

drop_state_t state;

always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state      <= IDLE;
        drop_valid <= 1'b0;
    end else begin
        case (state)
            IDLE: begin
                if (trigger_drop_all) begin
                    drop_valid <= 1'b1;
                    drop_all   <= 1'b1;
                    drop_count <= 8'h0;  // Ignored when drop_all=1
                    state      <= DROP_WAIT;
                end else if (trigger_drop_count) begin
                    drop_valid <= 1'b1;
                    drop_all   <= 1'b0;
                    drop_count <= num_to_drop;
                    state      <= DROP_WAIT;
                end
            end

            DROP_WAIT: begin
                if (drop_ready) begin
                    drop_valid <= 1'b0;
                    state      <= DROP_DONE;
                end
            end

            DROP_DONE: begin
                // Single-cycle state
                state <= IDLE;
            end
        endcase
    end
end
```

## Test Coverage

Comprehensive verification is provided in `val/amba/test_gaxi_drop_fifo_sync.py`:

| Test Scenario | Coverage |
|---------------|----------|
| **Basic FIFO Operation** | Standard write/read without drops |
| **Drop by Count** | Partial FIFO flush with specific count |
| **Drop All** | Complete FIFO flush |
| **Drop During I/O** | Verify I/O blocking during drop |
| **Wraparound with Drop** | Drop across pointer wraparound boundary |

**Test Configurations**:
- Data widths: 8, 32, 64 bits
- Depths: 8, 16, 64, 256 entries
- Modes: Mux (REGISTERED=0) and Flop (REGISTERED=1)

**Results**: All 8 parameterized test cases pass ✅

### Running Tests

```bash
# Run all drop FIFO tests
pytest val/amba/test_gaxi_drop_fifo_sync.py -v

# Run specific test configuration
pytest "val/amba/test_gaxi_drop_fifo_sync.py::test_gaxi_drop_fifo_sync[8-8-0-minimal-mux]" -v

# Run smoke test (quick verification)
pytest val/amba/test_gaxi_drop_fifo_sync.py::test_gaxi_drop_fifo_smoke -v

# Generate waveforms for documentation
env ENABLE_WAVEDROM=1 pytest val/amba/test_gaxi_drop_fifo_wavedrom.py -v
```

## Design Notes

### FIFO Depth Requirements

**MUST** be a power of 2 for efficient address pointer implementation.

Valid: 8, 16, 32, 64, 128, 256, ...

Invalid: 10, 15, 20, 100, ...

### Registered vs. Mux Mode

**Mux Mode (REGISTERED=0)**:
- Lower latency (combinatorial path from FIFO RAM to `rd_data`)
- Better for timing-critical paths where output is registered downstream
- Simpler implementation

**Registered Mode (REGISTERED=1)**:
- Extra register stage on `rd_data` output
- Better timing closure for long data paths
- Adds 1 cycle of read latency

### Drop Latency

The 3-cycle drop latency is inherent to the implementation:
1. **Cycle 1**: Latch drop request
2. **Cycle 2**: Update read pointer
3. **Cycle 3**: Assert drop_ready

This latency ensures clean separation between normal FIFO operations and drop operations.

### Almost Full/Empty Margins

Configure `ALMOST_WR_MARGIN` and `ALMOST_RD_MARGIN` based on:
- Pipeline depth of upstream producer
- Pipeline depth of downstream consumer
- Latency tolerance requirements

Example: If upstream has 4-cycle latency, set `ALMOST_WR_MARGIN >= 4`.

## Related Modules

- `fifo_control.sv` - Core FIFO control logic
- `counter_bin.sv` - Binary counter for address generation
- `counter_bin_load.sv` - Loadable binary counter for drop pointer updates
- `gaxi_drop_fifo_async.sv` - Asynchronous clock domain version (future)

## Revision History

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2025-10-17 | Initial documentation with WaveDrom examples |
