# Randomization Configuration Documentation

## Overview
The `RandomizationConfig` module provides a structured framework for configuring randomization behavior in protocol verification environments. Building on the `FlexRandomizer` engine, it adds protocol-specific features, dependency management, and comprehensive field configuration.

## Key Components

The module defines three primary components:

1. `RandomizationMode`: Enumeration of possible randomization modes
2. `FieldRandomizationConfig`: Configuration for individual fields
3. `RandomizationConfig`: Main class for managing field configurations

## RandomizationMode

An enumeration that defines the possible randomization modes:

```python
class RandomizationMode(Enum):
    """Defines possible randomization modes."""
    DETERMINISTIC = auto()  # Fixed values, not random
    CONSTRAINED = auto()    # Constrained random with weights
    DIRECTED = auto()       # Directed test patterns
    SEQUENCE = auto()       # Sequence of values in order
    CUSTOM = auto()         # Custom generator function
```

Each mode provides a different approach to value generation:
- `DETERMINISTIC`: Fixed, non-random values
- `CONSTRAINED`: Weighted random values from specified constraints
- `DIRECTED`: Specific test patterns (handled as a type of sequence)
- `SEQUENCE`: Values cycled in a predefined order
- `CUSTOM`: Values generated by a custom function

## FieldRandomizationConfig

A dataclass that contains the configuration for a single field:

```python
@dataclass
class FieldRandomizationConfig:
    """Configuration for randomizing a specific field."""
    enabled: bool = True
    mode: RandomizationMode = RandomizationMode.CONSTRAINED
    constraints: Optional[Dict] = None
    sequence: Optional[List[Any]] = None
    custom_generator: Optional[Callable] = None
    dependencies: List[str] = field(default_factory=list)
```

Attributes:
- `enabled`: Whether randomization is enabled for this field
- `mode`: The randomization mode for this field
- `constraints`: Definition of constraints for `CONSTRAINED` mode
- `sequence`: List of values for `SEQUENCE` mode
- `custom_generator`: Function for `CUSTOM` mode
- `dependencies`: List of field names this field depends on

## RandomizationConfig

The main class that manages field configurations and generates values:

```python
class RandomizationConfig:
    """
    Configuration for randomizing protocol fields.

    This class provides a flexible framework for configuring how
    protocol fields are randomized, using FlexRandomizer as the
    underlying randomization engine.
    """

    def __init__(self, protocol_name: str = "generic", seed: Optional[int] = None):
        """
        Initialize the randomization configuration.

        Args:
            protocol_name: Name of the protocol (e.g., "AXI4", "APB")
            seed: Master random seed for reproducibility
        """
```

### Key Features

#### Field Configuration
```python
def configure_field(self, field_name: str, config: FieldRandomizationConfig) -> 'RandomizationConfig':
    """
    Configure randomization for a specific field.
    """
```
Sets up randomization behavior for a specific field.

#### Group Management
```python
def add_to_group(self, group_name: str, field_name: str) -> 'RandomizationConfig':
    """
    Add a field to a named group for collective configuration.
    """
```
Adds a field to a named group for collective configuration.

```python
def configure_group(self, group_name: str, **config_kwargs) -> 'RandomizationConfig':
    """
    Configure all fields in a group with the same settings.
    """
```
Configures all fields in a group with the same settings.

#### Value Generation
```python
def generate_value(self, field_name: str) -> Any:
    """
    Generate a random value for a field based on its configuration.
    """
```
Generates a value for a single field.

```python
def generate_values(self, field_names: List[str]) -> Dict[str, Any]:
    """
    Generate values for multiple fields at once.
    """
```
Generates values for multiple fields, respecting dependencies.

#### Dependency Management
```python
def _build_dependency_graph(self, field_names: List[str]) -> Dict[str, List[str]]:
    """
    Build a dependency graph for fields.
    """
```
Builds a graph representing dependencies between fields.

```python
def _topological_sort(self, graph: Dict[str, List[str]]) -> List[str]:
    """
    Perform topological sorting of fields based on dependencies.
    """
```
Sorts fields to ensure dependencies are resolved in the correct order.

#### Configuration Factory Methods
```python
def create_constrained_config(self, field_name: str, bins: List[Union[Tuple[int, int], List[Any]]], weights: Optional[List[float]] = None) -> 'RandomizationConfig':
    """
    Create a constrained randomization configuration for a field.
    """
```
Creates a constrained randomization configuration for a field.

```python
def create_sequence_config(self, field_name: str, sequence: List[Any]) -> 'RandomizationConfig':
    """
    Create a sequence-based configuration for a field.
    """
```
Creates a sequence-based configuration for a field.

```python
def create_custom_config(self, field_name: str, generator: Callable) -> 'RandomizationConfig':
    """
    Create a custom randomization configuration for a field.
    """
```
Creates a custom randomization configuration for a field.

## Usage Examples

### Basic Configuration

```python
# Create randomization configuration
config = RandomizationConfig("APB_Protocol")

# Configure address field
config.configure_field("addr", FieldRandomizationConfig(
    mode=RandomizationMode.CONSTRAINED,
    constraints={
        "bins": [(0x1000, 0x1FFF), (0x2000, 0x2FFF)],
        "weights": [0.7, 0.3]
    }
))

# Configure data field
config.configure_field("data", FieldRandomizationConfig(
    mode=RandomizationMode.CONSTRAINED,
    constraints={
        "bins": [(0x0, 0xFF), (0x100, 0xFFFF)],
        "weights": [0.5, 0.5]
    }
))

# Configure protection field
config.configure_field("prot", FieldRandomizationConfig(
    mode=RandomizationMode.SEQUENCE,
    sequence=[0, 1, 2, 3]
))

# Generate values
fields = ["addr", "data", "prot"]
values = config.generate_values(fields)
print(values)
```

### Using Factory Methods

```python
# Create randomization configuration
config = RandomizationConfig("AXI4_Protocol")

# Configure fields using factory methods
config.create_constrained_config(
    "addr",
    bins=[(0x1000, 0x1FFF), (0x2000, 0x2FFF)],
    weights=[0.7, 0.3]
)

config.create_sequence_config(
    "burst",
    sequence=[0, 1, 2, 3]  # FIXED, INCR, WRAP, Reserved
)

config.create_custom_config(
    "len",
    generator=lambda values: random.randint(0, 15) if values.get('burst') != 0 else 0
)

# Generate values
fields = ["addr", "burst", "len"]
values = config.generate_values(fields)
print(values)
```

### Field Dependencies

```python
# Create randomization configuration
config = RandomizationConfig("AXI4_Protocol")

# Configure address field
config.configure_field("addr", FieldRandomizationConfig(
    mode=RandomizationMode.CONSTRAINED,
    constraints={
        "bins": [(0x1000, 0x1FFF), (0x2000, 0x2FFF)],
        "weights": [0.7, 0.3]
    }
))

# Configure burst type field
config.configure_field("burst", FieldRandomizationConfig(
    mode=RandomizationMode.CONSTRAINED,
    constraints={
        "bins": [(0, 0), (1, 1), (2, 2)],  # FIXED, INCR, WRAP
        "weights": [0.2, 0.6, 0.2]
    }
))

# Configure length field with dependency on burst
config.configure_field("len", FieldRandomizationConfig(
    mode=RandomizationMode.CUSTOM,
    custom_generator=lambda values: 0 if values['burst'] == 0 else random.randint(0, 15),
    dependencies=['burst']
))

# Configure size field with dependencies on addr and len
config.configure_field("size", FieldRandomizationConfig(
    mode=RandomizationMode.CUSTOM,
    custom_generator=lambda values: min(3, random.randint(0, 3)) if values['len'] > 0 else 0,
    dependencies=['len']
))

# Generate values
fields = ["addr", "burst", "len", "size"]
values = config.generate_values(fields)
print(values)
```

### Group Configuration

```python
# Create randomization configuration
config = RandomizationConfig("APB_Protocol")

# Add fields to groups
config.add_to_group("address", "addr")
config.add_to_group("address", "region")

config.add_to_group("data", "wdata")
config.add_to_group("data", "rdata")

config.add_to_group("control", "prot")
config.add_to_group("control", "strb")
config.add_to_group("control", "slverr")

# Configure groups
config.configure_group("address",
                      mode=RandomizationMode.CONSTRAINED,
                      constraints={
                          "bins": [(0x1000, 0x1FFF), (0x2000, 0x2FFF)],
                          "weights": [0.7, 0.3]
                      })

config.configure_group("data",
                      mode=RandomizationMode.CONSTRAINED,
                      constraints={
                          "bins": [(0x0, 0xFFFF)],
                          "weights": [1.0]
                      })

config.configure_group("control",
                      mode=RandomizationMode.SEQUENCE,
                      sequence=[0, 1, 2, 3])

# Generate values
fields = ["addr", "region", "wdata", "rdata", "prot", "strb", "slverr"]
values = config.generate_values(fields)
print(values)
```

### Testing Phases

```python
# Create randomization configuration
config = RandomizationConfig("AXI4_Protocol")

# Configure fields for initial random exploration
config.create_constrained_config("addr", [(0x1000, 0xFFFF)], [1.0])
config.create_constrained_config("data", [(0, 0xFFFFFFFF)], [1.0])
config.create_constrained_config("burst", [(0, 2)], [0.2, 0.6, 0.2])
config.create_constrained_config("len", [(0, 15)], [1.0])

# Phase 1: Fully random exploration
print("Phase 1: Random exploration")
config.enable()
for i in range(5):
    values = config.generate_values(["addr", "data", "burst", "len"])
    print(f"  Iteration {i+1}: {values}")

# Phase 2: Directed testing for INCR bursts
print("\nPhase 2: Directed testing for INCR bursts")
config.create_sequence_config("burst", [1])  # INCR only
for i in range(5):
    values = config.generate_values(["addr", "data", "burst", "len"])
    print(f"  Iteration {i+1}: {values}")

# Phase 3: Corner case testing
print("\nPhase 3: Corner case testing")
config.create_sequence_config("addr", [0x1000, 0x1FFC, 0xFFF0])
config.create_sequence_config("len", [0, 1, 15])
config.create_sequence_config("burst", [0, 1, 2])
for i in range(5):
    values = config.generate_values(["addr", "data", "burst", "len"])
    print(f"  Iteration {i+1}: {values}")

# Phase 4: Reset to random for regression
print("\nPhase 4: Random regression")
config.reset_to_random("addr")
config.reset_to_random("len")
config.reset_to_random("burst")
for i in range(5):
    values = config.generate_values(["addr", "data", "burst", "len"])
    print(f"  Iteration {i+1}: {values}")
```

## Integration with Verification Components

```python
# Create verification environment
class AXI4Testbench:
    def __init__(self):
        # Create randomization configuration
        self.rand_config = RandomizationConfig("AXI4_Protocol")
        
        # Configure address fields
        self.rand_config.create_constrained_config(
            "awaddr",
            bins=[(0x1000, 0x1FFF), (0x2000, 0x2FFF), (0x3000, 0x3FFF)],
            weights=[0.4, 0.4, 0.2]
        )
        
        # Configure burst types
        self.rand_config.create_constrained_config(
            "awburst",
            bins=[(0, 0), (1, 1), (2, 2)],  # FIXED, INCR, WRAP
            weights=[0.2, 0.6, 0.2]
        )
        
        # Configure length with dependency on burst
        self.rand_config.configure_field("awlen", FieldRandomizationConfig(
            mode=RandomizationMode.CUSTOM,
            custom_generator=lambda values: 0 if values['awburst'] == 0 else random.randint(0, 15),
            dependencies=['awburst']
        ))
        
        # Configure size with dependency on address alignment
        self.rand_config.configure_field("awsize", FieldRandomizationConfig(
            mode=RandomizationMode.CUSTOM,
            custom_generator=self._generate_size,
            dependencies=['awaddr', 'awlen']
        ))
        
    def _generate_size(self, values):
        """Generate appropriate size based on address and length"""
        addr = values['awaddr']
        burst = values.get('awburst', 1)
        
        # For FIXED bursts, only allow aligned addresses
        if burst == 0:
            max_size = min(3, (addr & -addr).bit_length() - 1) if addr != 0 else 3
            return random.randint(0, max_size)
            
        # For INCR bursts, allow any size
        elif burst == 1:
            return random.randint(0, 3)
            
        # For WRAP bursts, size affects wrap boundary
        else:
            # Calculate max size that keeps address aligned
            max_align = min(3, (addr & -addr).bit_length() - 1) if addr != 0 else 3
            return random.randint(0, max_align)
    
    async def generate_transaction(self):
        """Generate an AXI4 transaction using the randomization configuration"""
        # Generate values for write transaction
        write_fields = ["awaddr", "awburst", "awlen", "awsize"]
        write_values = self.rand_config.generate_values(write_fields)
        
        # Create transaction
        txn = AXI4Transaction()
        txn.awaddr = write_values['awaddr']
        txn.awburst = write_values['awburst']
        txn.awlen = write_values['awlen']
        txn.awsize = write_values['awsize']
        
        return txn
```

## Best Practices

### Configuration Organization

1. **Protocol-Specific Configurations**: Create configurations tailored to specific protocols:
   ```python
   axi4_config = RandomizationConfig("AXI4_Protocol")
   apb_config = RandomizationConfig("APB_Protocol")
   ```

2. **Group Related Fields**: Use groups for efficient configuration of related fields:
   ```python
   config.add_to_group("write_channel", "awaddr", "awlen", "awsize", "awburst")
   config.add_to_group("read_channel", "araddr", "arlen", "arsize", "arburst")
   ```

3. **Reusable Configurations**: Create factory functions for common configurations:
   ```python
   def create_axi4_config():
       config = RandomizationConfig("AXI4_Protocol")
       # Configure common fields
       return config
   ```

### Value Generation

1. **Respect Protocol Rules**: Create generators that enforce protocol rules:
   ```python
   # AXI4 rule: FIXED bursts must have length of 0
   config.configure_field("awlen", FieldRandomizationConfig(
       mode=RandomizationMode.CUSTOM,
       custom_generator=lambda values: 0 if values['awburst'] == 0 else random.randint(0, 15),
       dependencies=['awburst']
   ))
   ```

2. **Address Alignment**: Ensure proper address alignment based on size:
   ```python
   def align_address(self, addr, size):
       """Align address based on size (AXI4 requirement)"""
       mask = (1 << size) - 1
       return addr & ~mask
   ```

3. **Boundary Conditions**: Test boundary conditions explicitly:
   ```python
   # Configure address for boundary testing
   config.create_sequence_config(
       "addr",
       sequence=[
           0x00000000,  # Start of memory
           0x00000FFC,  # Page boundary - 4
           0x00001000,  # Page boundary
           0xFFFFFFF0   # End of memory - 16
       ]
   )
   ```

### Test Phases

1. **Progressive Testing**: Start with random, move to directed:
   ```python
   # Phase 1: Random exploration
   config.enable()
   
   # Phase 2: Directed testing
   config.create_sequence_config("burst", [1])  # INCR only
   
   # Phase 3: Corner case testing
   config.create_sequence_config("addr", [0x1000, 0x1FFC, 0xFFF0])
   ```

2. **Error Injection**: Include error scenarios in testing:
   ```python
   # Configure error injection
   config.create_sequence_config(
       "error_mode",
       sequence=["none", "timeout", "slave_error", "decode_error"]
   )
   ```

3. **Reproducibility**: Use seeds for reproducible tests:
   ```python
   # Set seed for reproducibility
   config.set_seed(12345)
   ```

### Integration

1. **Component Integration**: Integrate with other verification components:
   ```python
   # Create driver with randomization
   class AXI4Driver:
       def __init__(self, interface, config):
           self.interface = interface
           self.rand_config = config
   ```

2. **Coverage-Driven Configuration**: Adjust configurations based on coverage:
   ```python
   # Increase weight for uncovered areas
   if coverage.get_value("burst_type", 2) < 0.5:
       config.create_constrained_config(
           "burst",
           bins=[(0, 0), (1, 1), (2, 2)],
           weights=[0.1, 0.3, 0.6]  # Increase WRAP burst probability
       )
   ```

3. **Protocol Transitions**: Use configurations for protocol state machines:
   ```python
   # Configure for idle state
   config.create_sequence_config("valid", [0])
   
   # Configure for active state
   config.create_sequence_config("valid", [1])
   ```
