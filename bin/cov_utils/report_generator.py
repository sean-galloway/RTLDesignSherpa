# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024-2025 sean galloway
#
# RTL Design Sherpa - Industry-Standard RTL Design and Verification
# https://github.com/sean-galloway/RTLDesignSherpa
#
# Module: report_generator
# Purpose: Coverage report generation utilities
#
# Author: sean galloway
# Created: 2025-01-10

"""
Coverage Report Generation Utilities

Provides functions to generate coverage reports in various formats:
- Markdown reports (for documentation)
- JSON reports (for CI/CD integration)
- Console output (for quick feedback)

These utilities are AGNOSTIC and work with any project's coverage data.
Project-specific formatting (like "legal coverage" sections) should be
handled by the project's coverage module.
"""

import os
import json
from datetime import datetime
from typing import Dict, List, Any, Optional, Callable


class ReportGenerator:
    """Generate coverage reports from collected data.

    This is an AGNOSTIC report generator. Project-specific sections
    (like STREAM's "legal coverage") should be added via the
    `custom_sections` callback.

    Usage:
        generator = ReportGenerator(
            title="STREAM Coverage Report",
            coverage_target=80.0
        )

        # Add custom section generator for project-specific content
        generator.add_section_generator('legal_coverage', stream_legal_section)

        report = generator.generate_markdown(merged_data)
    """

    def __init__(self, title: str = "Coverage Report",
                 coverage_target: float = 80.0,
                 show_detailed_gaps: bool = True,
                 max_gaps_shown: int = 30):
        """Initialize report generator.

        Args:
            title: Report title
            coverage_target: Target coverage percentage for PASS/FAIL status
            show_detailed_gaps: Whether to show detailed coverage gaps
            max_gaps_shown: Maximum number of gaps to show in detail
        """
        self.title = title
        self.coverage_target = coverage_target
        self.show_detailed_gaps = show_detailed_gaps
        self.max_gaps_shown = max_gaps_shown

        # Custom section generators: name -> callable(data) -> List[str]
        self._section_generators: Dict[str, Callable[[Dict], List[str]]] = {}

    def add_section_generator(self, name: str, generator: Callable[[Dict], List[str]]):
        """Add a custom section generator.

        Args:
            name: Section name (for ordering)
            generator: Callable that takes merged data and returns list of markdown lines
        """
        self._section_generators[name] = generator

    def generate_markdown(self, data: Dict[str, Any]) -> str:
        """Generate markdown coverage report.

        Args:
            data: Merged coverage data dictionary

        Returns:
            Markdown formatted report string
        """
        lines = []

        # Header
        lines.append(f"# {self.title}")
        lines.append("")
        lines.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"**Tests Analyzed:** {data.get('test_count', 0)}")
        lines.append("")

        # Executive Summary
        lines.extend(self._generate_summary_section(data))

        # Custom sections (e.g., legal coverage)
        for name, generator in self._section_generators.items():
            section_lines = generator(data)
            if section_lines:
                lines.extend(section_lines)
                lines.append("")

        # Protocol Coverage by Group
        lines.extend(self._generate_group_coverage_section(data))

        # Per-Test Coverage
        lines.extend(self._generate_per_test_section(data))

        # Coverage Gaps
        if self.show_detailed_gaps:
            lines.extend(self._generate_gaps_section(data))

        # Footer
        lines.append("---")
        lines.append("*Report generated by RTLDesignSherpa coverage infrastructure*")

        return "\n".join(lines)

    def _generate_summary_section(self, data: Dict[str, Any]) -> List[str]:
        """Generate executive summary section."""
        lines = []
        lines.append("## Executive Summary")
        lines.append("")
        lines.append("| Metric | Coverage | Target | Status |")
        lines.append("|--------|----------|--------|--------|")

        protocol_pct = data.get('overall', {}).get('protocol_pct', 0)
        line_pct = data.get('overall', {}).get('line_pct', 0)

        def status(pct: float, target: float) -> str:
            if pct >= target:
                return "PASS"
            elif pct >= target * 0.8:
                return "WARN"
            else:
                return "FAIL"

        lines.append(f"| **Protocol Coverage** | {protocol_pct:.1f}% | {self.coverage_target:.0f}% | {status(protocol_pct, self.coverage_target)} |")

        # Show line coverage with counts if available
        line_covered = data.get('code_coverage', {}).get('line', {}).get('covered', 0)
        line_total = data.get('code_coverage', {}).get('line', {}).get('total', 0)
        if line_total > 0:
            lines.append(f"| **Line Coverage** | {line_pct:.1f}% ({line_covered}/{line_total}) | {self.coverage_target:.0f}% | {status(line_pct, self.coverage_target)} |")
        else:
            lines.append(f"| **Line Coverage** | {line_pct:.1f}% | {self.coverage_target:.0f}% | {status(line_pct, self.coverage_target)} |")

        lines.append("")
        return lines

    def _generate_group_coverage_section(self, data: Dict[str, Any]) -> List[str]:
        """Generate protocol coverage by group section."""
        lines = []
        lines.append("## Protocol Coverage by Group")
        lines.append("")
        lines.append("| Group | Covered | Total | Coverage | Status |")
        lines.append("|-------|---------|-------|----------|--------|")

        def status(pct: float) -> str:
            if pct >= self.coverage_target:
                return "PASS"
            elif pct >= self.coverage_target * 0.8:
                return "WARN"
            else:
                return "FAIL"

        for group_name, group_data in sorted(data.get('protocol_groups', {}).items()):
            covered = group_data.get('covered', 0)
            total = group_data.get('total', 0)
            pct = group_data.get('coverage_pct', 0)
            lines.append(f"| {group_name} | {covered} | {total} | {pct:.1f}% | {status(pct)} |")

        lines.append("")
        return lines

    def _generate_per_test_section(self, data: Dict[str, Any]) -> List[str]:
        """Generate per-test coverage section."""
        lines = []
        lines.append("## Per-Test Coverage")
        lines.append("")
        lines.append("| Test Name | Protocol | Line |")
        lines.append("|-----------|----------|------|")

        for test in data.get('tests', []):
            name = test.get('name', 'unknown')
            # Truncate long names
            if len(name) > 60:
                name = name[:57] + "..."
            protocol_pct = test.get('protocol_pct', 0)
            line_pct = test.get('line_pct', 0)
            lines.append(f"| {name} | {protocol_pct:.1f}% | {line_pct:.1f}% |")

        lines.append("")
        return lines

    def _generate_gaps_section(self, data: Dict[str, Any]) -> List[str]:
        """Generate coverage gaps section."""
        lines = []

        # Collect gaps from all groups
        gaps = []
        for group_name, group_data in data.get('protocol_groups', {}).items():
            for point_name, point_data in group_data.get('points', {}).items():
                if point_data.get('hits', 0) < point_data.get('goal', 1):
                    gaps.append((group_name, point_name, point_data.get('hits', 0), point_data.get('goal', 1)))

        if not gaps:
            return lines

        lines.append("## Coverage Gaps")
        lines.append("")
        lines.append(f"**{len(gaps)} coverage points not hit:**")
        lines.append("")

        for group_name, point_name, hits, goal in gaps[:self.max_gaps_shown]:
            lines.append(f"- **{group_name}**: {point_name} ({hits}/{goal} hits)")

        if len(gaps) > self.max_gaps_shown:
            lines.append(f"- ... and {len(gaps) - self.max_gaps_shown} more")

        lines.append("")
        return lines

    def generate_json(self, data: Dict[str, Any]) -> str:
        """Generate JSON coverage report.

        Args:
            data: Merged coverage data dictionary

        Returns:
            JSON formatted report string
        """
        report = {
            'title': self.title,
            'generated': datetime.now().isoformat(),
            'coverage_target': self.coverage_target,
            'data': data,
            'status': 'PASS' if self._check_pass(data) else 'FAIL'
        }
        return json.dumps(report, indent=2)

    def _check_pass(self, data: Dict[str, Any]) -> bool:
        """Check if coverage meets target."""
        protocol_pct = data.get('overall', {}).get('protocol_pct', 0)
        line_pct = data.get('overall', {}).get('line_pct', 0)
        return protocol_pct >= self.coverage_target and line_pct >= self.coverage_target


def generate_coverage_report(data: Dict[str, Any],
                             output_path: str,
                             title: str = "Coverage Report",
                             format: str = "markdown",
                             **kwargs) -> str:
    """Convenience function to generate a coverage report.

    Args:
        data: Merged coverage data
        output_path: Path to write report
        title: Report title
        format: Report format ("markdown" or "json")
        **kwargs: Additional arguments for ReportGenerator

    Returns:
        Generated report content
    """
    generator = ReportGenerator(title=title, **kwargs)

    if format == "json":
        content = generator.generate_json(data)
    else:
        content = generator.generate_markdown(data)

    # Write to file
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w') as f:
        f.write(content)

    return content


def generate_markdown_report(data: Dict[str, Any], **kwargs) -> str:
    """Generate markdown report without writing to file.

    Args:
        data: Merged coverage data
        **kwargs: Arguments for ReportGenerator

    Returns:
        Markdown report string
    """
    generator = ReportGenerator(**kwargs)
    return generator.generate_markdown(data)
