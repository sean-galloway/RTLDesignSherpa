#include <stdio.h>
#include <string.h>

/* dinv - inversion/division*/

/* File for generating BCH code using bch?.vht files b4: */

/* option 1 - for t=2 using S1^3==S3 
   option 2 - for t>2 parallel without inversion 
   option 3 - for t>2 serial without inversion 
   -m? - without minimization  */

  int n, nk, m=0, k=0 ,t=0;  /* (n,k) BCH code, nk=n-k, n=2^m-1, t - no. errors */
  int gen_basis10[8] = { 0x6, 0xC, 0x14, 0x30, 0x60, /* generate base for m=3..7 */
	0xB8, 0x110, 0x240 }; /* for m=8..10;  x^m is ignored */
   /* Polynomials m=3 -1+x+x^3; m=4 - 1+x+x^4; m=5 - 1+x^2+x^5; m=6 - 1+x+x^6
	m=7 - 1+x+x^7; m=8 - 1+x^2+x^3+x^4+x^8; m=9 - 1+x^4+x^9; m=10 - 1+x^3+x^10 */
  int gen_basis; /* gen standard base= gen_basis10[m-2]*/
  int one; /* one=L^0; one= 1<<(m-1) */
  int L1;  /* alpha= L^1, L1=1<<(m-2 */
  int Lmm; /* Lmm= L^(m*m) */
  int mm;  /* mm=m*m */
  int gen_sim=0; /* generate simulation files */
  int option=0; /* option in generating circuit */
  int optimization= 0; /* if != 0 circuit optimization  */
  int polyi;  /* polyi=i ; 1 + x^i + [x^(i+1) + x^(x+2)] + x^m */
  int sb2db[10]; /* Standard basis -> Dual basis */
  int iteration, sizea, sizeb, sizel, buf_size; 
	/*  no. of clock per one iteration in BMA, size of counters a & b */
  int vdout, chpe; /* vdout -no of clocks delay from data coming in and out in decoder - n */
  int interleave=0, sizei; /* the internal f_BMA= interleave * f_syndromes; */
  int blockXor, totalXor, blockReg, totalReg;  
   /* block and total number of XOR gates and registers for decoder or encoder */

/************* system ********************************************/
void
ErrMsg()  /* wrong input file */
{
 printf("\nError. Wrong input data\n");
  exit(0);
}


void
NoBchInFile()
{ printf("\nNo bch.in file, therefore enter input variable:\n");
  printf("Enter m= ");
  scanf("%d", &m);
  if(m>10 || m<3) 
	{ printf(" m should be m>2 and m<11\n"); return; }
  printf("Enter number of errors t= ");
  scanf("%d", &t);
  printf("Enter number of codewords to simulate -s");
  scanf("%d",&gen_sim);
  if(t>1)
  { printf("With design optimization (0= without; !=0 with (level -1 the best)  -m");
    scanf("%d", &optimization);
  }

  if(t>2)
  { printf("What option (optimal=0/ parallel=2/ serial=3 )?  -o");
    scanf("%d", &option);
    printf("BMA interleave (0- optimal) -i");
    scanf("%d", &interleave);
  }
  printf("\n");
} 


void  /* write to file converting from int into bin format e.g. "0110" */
PrintBin(fout, a)
FILE *fout;
int a;
{ int i, f;
  i= one;
  for(f=0; f<m; f++)
  { if( i & a) putc('1',fout);
     else putc('0',fout);
    i>>=1;
  }
}

/* Find next char '#' in file fin (bch.vht) */
void
FindMark(fin)
FILE *fin;
{ char c;
  c=' ';
  while( c!='#' && c!=EOF) c=getc(fin);
}

/* Copy file bch.vht into file fout until the char '#' or EOF is found */    
void        
CopyFile(fin, fout)
FILE *fin, *fout;
{ char c;
  c=getc(fin);
  while(c!='#' && c!=EOF) 
    { putc(c,fout); c= getc(fin); }
}

void     /* Copy only chosen option (1 or 2) and stop if option not digit - for all */
CopyOption(fi, fo, opt1, opt2)
FILE *fi, *fo;
int opt1, opt2;
{ char c;
  int i;
  while(1)
  { c=getc(fi);
    if(c==EOF || c<'0' || c>'9') return;
    i=c-'0';
    if(i==opt1 || i==opt2) 
      { CopyFile(fi,fo); continue; }
    FindMark(fi);
} }


	/* Print number of used XOR gates and Registers */
	/* option < 0 - block; |option| - number of entities */
void
PrintNoElem(ftxt, option, noReg, noXor)
FILE *ftxt;
int noReg, noXor;
{ int times;
  times= option;
  if(times<0) times= -times;

  if(option>1)
  { fprintf(ftxt,"\t\tReg= %d * %d = %d", noReg, times, times*noReg);
    fprintf(ftxt,"\tXOR= %d * %d = %d\n", noXor, times, times*noXor);
  }
  else 
   if(noReg || noXor)
     fprintf(ftxt,"\t\tReg= %d\t\tXOR= %d\n",noReg, noXor);
  
  blockXor+= noXor*times;  blockReg+= noReg*times;

  if(option<0)   /* block - include components */
  { if(option==-1)  
      fprintf(ftxt,"\ttotal\tReg= %d\t\tXOR= %d\n",blockReg, blockXor);
    else
    { fprintf(ftxt,"\ttotal\tReg= %d * %d = %d", blockReg, times, times*blockReg);
      fprintf(ftxt,"\tXOR= %d * %d = %d\n", blockXor, times, times*blockXor);
    }
    totalXor+= times * blockXor; totalReg+= times * blockReg; 
    blockXor= 0; blockReg= 0; 
  }
}


/* Write two integers with CopyFile() */
void
PrintDec(fi,fo,dec)
FILE *fi, *fo;
int dec;
{ CopyFile(fi,fo);
  fprintf(fo,"%d",dec);
}

/* Print beginning of file */
void
PrintFileBeg(fo, str)
FILE *fo;
char *str;
{ fprintf(fo,"-- File generated by bch.exe program.\n");
  fprintf(fo,"-- The %s for BCH code (%d,%d), t=%d\n",str,n,k,t);
  if(t>2) 
    fprintf(fo,"-- Option= %d,  Interleave= %d,", option, interleave);
  if(t>1) fprintf(fo," -- with optimization= %d.\n", optimization);
   else fprintf(fo,"\n");
  fprintf(fo,"-- GF(2^%d) is generated by polynomial [1+x+...] - ",m);
  PrintBin(fo,gen_basis);
  fprintf(fo,"1;\n");
}

/* Find mask for L^i */
int
Mask(i)
int i;
{ int ret=one;
  while(i--) ret>>=1; 
  return ret;
}

int
Log2(x)
int x;
{ int ret=0, y=1 ;
  while(y<x) 
	{ y<<=1; ret++; }
  return ret;
}

/***************** Galois field *********************************/
int
Mul1(x)  /* multiply by Alpha - return = x*L^1 */
int x;
{ int ret;
  ret= x>>1;	/* shift left (towards a(m-1) - MSB most significant bit) */
  if(x & 1) ret^=gen_basis;
	/* gen_basis = 1 + p1x^1 + p2x^2 + ... + p(m-1)x^(m-1) -- p(i) primitive polynomial coeff.*/
	/* if a(m-1)!= 0 enable feed back XOR gates   */
  return ret;
}


int   /* Multiply a * b  */
Mul(a, b)   /* ret=(..(b(m-1)*a*L + b(m-2)*a)*L..)*L+ b0*a  */
int a,b;
{ int f, ret, i;
  if (a==0 || b==0) return 0; 
  ret= 0;  i= 1;
  for(f=0; f<m; f++)  
  { ret= Mul1(ret);   /* Multiply by L^1  */
    if(b & i)  ret^=a;   /* if b(i)!= 0  add a to the result */
    i<<=1;
  }
  return ret;
}

int  /* return = (x)^n;  n>0 */
Pow(x, p)
int x, p;
{ int ret, x1;
  ret=x;	/* Multiply p-1 times ret by x */
  while(--p >0) ret=Mul(ret, x);  /* ret<- ret * x  */
}

/* LPow(x)= L^x  */
int
LPow(x)
int x;
{ int f, ret;
  ret= one;
  x%=n;   /* limit x to the range from 0 to n-1 by modulo n division */
  while(x >= mm)   /* if x is large multiply by L^(m*m) to speed up algorithm */
  { if(ret==one) ret=Lmm;	/* Do not multiply 1 -> 1*x= x  */
     else ret=Mul(ret,Lmm);	/* ret<= ret * L^(m*m)  */
    x-=mm;			
  }
  for(f=0; f<x; f++) ret=Mul1(ret);   /* if x is small repeat x times ret<= ret *L^1  */
  return ret;
}

	/* Hamming weight return number of non-zero coefficients of the primitive polynomial */
int
Ham()
{ int f, mask, ret=2;
  mask= L1;	/* mask = L^1  */
  for(f=1; f<m; f++)
  { if(mask & gen_basis) ret++;  /* if bit f is 1 in primitive polynomial increase return value */
    mask>>=1;
  }
  return ret;
}

  /* find next number that forms next irreducible polynomial (x+L^ret)*(x+L^(2*ret))*.....   */
  /* the next syndrome number is found by checking if return value ret satisfies: */
  /* ret^2 % n>= ret; ret^4 % n >= ret; ... ;ret>= ret;  ( % n <- modulo n ); */
  /* if ret does not satisfy the ret in increased by 2 and the algorithm is repeated */ 
int
NextSynNo(syn_no)
int syn_no;  
{ int ret, tmp;
  ret= syn_no+2;  tmp= ret;  /* the next possible ret number is greater by 2 */
  while(1)
  { tmp*=2;
    if (tmp>= n) tmp-=n;
    if (tmp==ret) return ret; /* ret is correct */
    if (tmp<ret)  /* ret is not correct, try next one */
    { ret+= 2; tmp=ret; /* proper return value can not be found - to many syndromes */
      if(ret>n)
         { printf("\nError. t is too large\n"); exit(0); }
} } }

void
GenEnc(ftxt, ch)  /* Generate encoder LFSR */
FILE *ftxt;
char *ch;
{ int poly[1024], polya[1024], *p, *pa, line, noXor; 
	/*  polynomials - poly[nk]*x^nk + ...+poly[1]*x + poly[0]; */
  int B,C, nk1, tmp, syn_no, next_syn_no, f, g, h;
  fprintf(ftxt,"\nThere are following BCH codes for m= %d and t<=%d. (n,k,t)\n",m,t); 
  B=L1;     /* B=L^1 */
  p=poly; line=0; 
  *p++= one;
  for(f=1; f< 1024; f++) *p++=0; /* poly={one,0,0,...} */
  nk1=m; nk=0;
  syn_no=1;
  while(1)
  { C= B;  /* B generate syndr (x+B)*(x+B^2)*... */
    while(1)
    { /*   multiply polynomials (x^(nk-1)+poly(nk-2)*x^(nk-2)+...+poly(0))*(x+C) */
	p=poly; pa=polya;
	for(h=0; h<=nk1; h++) 
		{ *pa++= *p;  *p++= 0; }
	p=poly; pa=polya;
	for(h=0; h<nk1; h++)
	{ *p++^= Mul(*pa, C);
	  *p^= *pa++;
	}
	nk++;
	C= Mul(C,C);  /* C= C^2 */
	if(C==B) break;  /* Calculate for next error  */
    }
    next_syn_no=NextSynNo(syn_no);
    for(g=0; g<next_syn_no - syn_no; g++)  B=Mul1(B);
    syn_no= next_syn_no;
    nk1=nk+m;
    fprintf(ftxt,"(%d, %d, %d) \t",n,n-nk,(next_syn_no-1)/2);
    line++;
    if(line==4) { fprintf(ftxt, "\n"); line= 0; } 
    if(2*t-1 < syn_no)
    { /* check if t is correct */
      if(2*t-1 != syn_no-2) 
      { printf("\n!!! Warning. There is not BCH code that can correct %d errors\n",t);
        t= (next_syn_no-1)/2;
      }
      break; /* exit all loops */
    }
  }
  k=n-nk;
  printf("Code BCH (%d,%d). %d error(s) may be corrected.\n",n,k,t);
  if(t>2)
    printf("  Option= %d;  Interleave= %d; ",option, interleave);
  if(optimization<0) optimization= 0;
  if(t>1)  printf("With optimization = %d; ",optimization);
  printf("Simulation= %d\n", gen_sim);
  if(k==1)
     { printf("\nError. This code is not a BCH code.\n"); exit(0);}
  for(f=0; f<nk; f++)
  { tmp= poly[f];
    if(tmp & (~one)) 
	{ printf("\nProgram error, a polynomial wrong value.\n"); exit(0); } 
    if(tmp) *ch++ =1; 
      else *ch++ =0;
} }   

/************** dual base ***************************************/

/* Find polyi 1 + x^i + [x^(i+1) + x^(x+2)] + x^m */
void 
FindPolyI(fo)  
FILE *fo;
{ int  mask;
  mask= L1; polyi= 1;
   while(!(mask & gen_basis)) 
      { polyi++; mask>>=1; }
}


	/* Standard Base -> Dual Base for sim.txt */
void 
PrintSB2DB(fo)
FILE *fo;
{ int f, i;
  i= polyi-1;
  if(m!=8)    /* if trinomial 1 + x^i + x^m  */
  { for(f=0; f<m; f++)
    { /* fprintf(fo,"\tdout(%d)<= din(%d);\n",f,i); */
      sb2db[i]= Mask(f);
      i--;
      if(i<0) i=m-1;
    }
    return;
  }
  /* m==8 pentanomial 1 + x^i + x^(i+1) + x^(x+2) + x^m */
  i= polyi;
  for(f=0; f<m; f++)
  { /* fprintf(fo,"\tdout(%d)<= din(%d)",f,i); */
    sb2db[i]= Mask(f);
    i--;
    if(i<0) i=m-1;
  }
  sb2db[0]= one | Mask(2);
  sb2db[7]= 1 | Mask(3);
}


int      /* Polynomial basis -> Dual basis */
SB2DB(sb)
int sb;
{ int f, mask, ret;
  mask= one; ret= 0;
  for(f=0; f<m; f++)
  { if(sb & mask)  ret^= sb2db[f];
    mask>>=1;
  }
  return ret;
}

/************** read bch.in *************************************/

int
OptionSel(opt)
int opt;
{ int ret, div, tmp;
  ret= opt;
  if(opt==0)
  { if(t==2) ret=1;
    if(t>2) ret=3;  /* the best (default) option is option 3 */
  }
  iteration=1;
  if(ret == 2) iteration=3;
  if(ret == 3) iteration= m+2;
  
  if(t>2 && interleave==0)  /* choose proper interleave */
  { interleave= 1;
    if(option!=2)
    { while(1)
      { chpe= t* iteration -2;  
        vdout= chpe + interleave +2 - chpe % interleave;
        if(vdout-2< n*interleave) break;  /* proper interleave */
        interleave++;
  } } }

  if(t<3)  
       { vdout= 3; interleave= 1; ret= 1;}
   else  /* t> 2 */
   { if(ret==2)  chpe= iteration*(t-1)+ 1;
      else chpe= t* iteration -2 ;  /* if option== 3 */
     vdout= chpe + interleave +2 - chpe % interleave; 
    if(vdout-2 >= n*interleave) printf("\n!!! Error: Interleave number too small.\n\n");
   }
  
  div= (n*interleave)/iteration +1;
  sizea= Log2(iteration);
  sizeb= Log2(div);
  if(sizeb<3) sizeb=3;  /* minimum value for generic statement */
  sizel= Log2(t+1);
  if(sizel<3) sizel=3;
  sizei= Log2(interleave);
  return ret;
}

void
ReadBchIn() 	/* read data from bch.in file */
{ FILE *fin;
  char line[400], c, *ch;
  int i=1;
  *line= '\0';
  if ((fin= fopen("bch.in", "r"))== NULL)
    NoBchInFile();
  else
  { while((c=getc(fin)) != EOF && i<399)
    	{ line[i++]=c;  /*read file */ }
    if(i>398 || i<6) ErrMsg();
    line[i]='\0';  fclose(fin);
    i=2; line[0]=' ';
    while(line[i]!='\0') 
    { if(line[i]=='=')
      { if(line[i-1]=='m' || line[i-2]=='m')  m=atoi(&line[i+1]); 
        if(line[i-1]=='t' || line[i-2]=='m')  t=atoi(&line[i+1]);
      }
      i++;
    }
  }

  printf("m= %d, t= %d.\nAnalyzing input data... \n",m,t);
  if(t==0 || m==0)
  {	printf("Value m or t has not been defined \n"); 
	ErrMsg(); 
  }
  if(m<3 || m>10)
  { 	printf("\nError. Wrong m value. It should be m>2 and m<11\n"); 
	exit(0); 
  }

  n=(1<<m) -1;
  L1= 1<<(m-2);
  one= L1<<1;
  gen_basis= gen_basis10[m-3];
  if(fin!= NULL)  /* it there is bch.in file*/
  { ch=line+1;
    ch= strstr(line, "-s");
    if(ch!=0) 
       gen_sim= atoi(ch+2);
    if(ch=strstr(line,"-i")) interleave= atoi(ch+2);
    ch=strstr(line,"-o");
    if(ch) option= atoi(ch+2);
    
    ch= strstr(line,"-m");
    if(ch) optimization= atoi(ch+2);
  }
  if(interleave<0 || interleave>1024) interleave= 0;
  option= OptionSel(option);
  FindPolyI();
}

		/* Parallel dual basis multiplier */
void
PrintParMul(fo)
FILE *fo;
{ int f, g, mask, first;
  fprintf(fo,"%d);\n  BEGIN\n\tb(0 TO m-1)<= din1;\n",(m-1)*(Ham()-1) );
       /* Print b(m)<= .......... */
  for(f=0; f<m-1; f++)
  { mask= L1; /* mask= L^1 */
    fprintf(fo,"\tb(%d)<= b(%d)",f+m, f);
    for(g=1; g<m; g++)
    { if(gen_basis & mask) fprintf(fo, " XOR b(%d)",f+g);
      mask>>=1;
    }
    fprintf(fo, ";\n");
  }
     /* port map (.... */
  for(f=0; f<m; f++)
  { fprintf(fo,"\tm%d:  dsdbm\n\t\tPORT MAP ",f);
    fprintf(fo,"(b(%d TO %d), din2, dout(%d));\n", f, f+m-1, f);
} }

/************* encoder const ******************************/

/* Print And statement that =1 if cout== i for finite field counter */
void
PrintAndCout(fo, i)
FILE *fo;
int i;
{ int f, mask, lx;
  lx=LPow(i);  /* lx=L^i */
  mask=one;
  if((mask & lx)==0) fprintf(fo," NOT");
  fprintf(fo, " cout(0)");
  mask>>=1;
  for(f=1; f<m; f++)
  { fprintf(fo," AND");
    if((mask & lx)==0) fprintf(fo," NOT");
    fprintf(fo, " cout(%d)",f);
    mask>>=1;
  }
}

/* Print finite field counter ring */
void
PrintCoutRing(fo)
FILE *fo;
{ int f, mask;
  mask=one; mask>>=1;
  for(f=1; f<m; f++)
  { if(mask & gen_basis) 
      fprintf(fo,"\tcout(%d)<= (cout(%d) XOR cout(m-1)) AND NOT reset;\n",f,f-1);
     else
      fprintf(fo,"\tcout(%d)<= cout(%d) AND NOT reset;\n",f,f-1);
    mask>>=1; 
} }

void
WriteEncVhd(fi, ftxt)  /* Write files: enc.vhd and sim.vhd */ 
FILE *fi, *ftxt;
{ FILE *fo;
  int f, buf_size, noXor=0; /* for the simulation compare buffer size */
  char gen_enc[1024];
  if ((fo= fopen("const.vhd", "w"))== NULL)
  {	printf("\nError. Can not write to file const.vhd\n");
	exit(0);
  }
  GenEnc(ftxt, gen_enc);
  Lmm=one; mm=m*m;
  for(f=0; f<mm; f++) 
    Lmm=Mul1(Lmm);    /* Lmm=L^(m*m) */
  
  printf("Writing to file const.vhd... ");
  FindMark(fi);
  PrintFileBeg(fo, "constant package");   /* const.vhd file writing */
  PrintDec(fi,fo, m);
  PrintDec(fi,fo, n);
  PrintDec(fi,fo, k);
  PrintDec(fi,fo, nk);
  PrintDec(fi,fo, t);
  PrintDec(fi,fo,sizea);
  PrintDec(fi,fo, sizeb);
  PrintDec(fi,fo, sizel);
  CopyFile(fi,fo);
  fclose(fo);

  printf("done.\nWriting to file enc.vhd... ");		/* enc.vhd writing */
  if ((fo= fopen("enc.vhd", "w"))== NULL)
  {	printf("\nError. Can not write to file enc.vhd\n");
	exit(0);
  }
  PrintFileBeg(fo,"encoder");  
  fprintf(ftxt,"\n\n\n\n\t---------------- ENCODER----------------\n\n");
  fprintf(ftxt,"ering - LFSR Linear Feedback Shift Registers\n");
  FindMark(fi);  /*find first character '#' */
  CopyFile(fi,fo);
  for(f=1; f<nk; f++)			/* write to ering entity */
  { if(gen_enc[f]) 
     { fprintf(fo,"\trin(%d)<= rout(%d) XOR rin0;\n",f,f-1);
       noXor++;
     }
     else fprintf(fo,"\trin(%d)<= rout(%d);\n",f,f-1);
  }
  fprintf(fo,"\t-- Polynomial generating encoder: 1+a1*x+a2*x^2+...\n\t--");
  for(f=0; f<nk; f++)
  { if(gen_enc[f]) putc('1',fo);
     else putc('0',fo);
  }
  fprintf(fo,"1\n");
  fprintf(fo,"\t-- Number of XOR gates= %d\n", noXor);
  blockXor= 0; blockReg= 0;
  PrintNoElem(ftxt, 1, nk, noXor);

  fprintf(ftxt,"ecount - counter (control system)\n");
  CopyFile(fi,fo); /*  beginning ecount*/
  PrintAndCout(fo,k-1);
  CopyFile(fi,fo);
  PrintAndCout(fo,n-1);
  CopyFile(fi,fo);
  PrintCoutRing(fo); /* finishing ecount and beginning enc */
  CopyFile(fi,fo);
  PrintNoElem(ftxt, 1, m+1, CountOnes(gen_basis)-1);
  fprintf(ftxt,"ENCODER --\n");
  PrintNoElem(ftxt,-1, 1, 0);
  fclose(fo);

  /* Writing to sim.vhd file */
  if ((fo= fopen("sim.vhd", "w"))== NULL)
  {	printf("\nError. Can not write to file sim.vhd\n");
	exit(0);
  }
  PrintFileBeg(fo, "simulation file");
  FindMark(fi);
  if(interleave>1) buf_size= n+ 2+ vdout/interleave;
   else buf_size= n+ vdout +1;
  PrintDec(fi,fo, buf_size); /* the comparison buffer size */
  CopyFile(fi,fo);
  if(interleave>1) CopyOption(fi,fo, 0,5); 
   else CopyOption(fi,fo,0,6);
  fclose(fo);
  printf("done\n");
}


/************* Simulation command files ***********************/

void
PrintSim(fi,fo)
FILE *fi, *fo;
{ int f,g,h, t1, nt, first;
  PrintDec(fi,fo, n*(gen_sim+2)*interleave); /* simulation time */
  for(f=0; f<gen_sim; f++) g=rand(); /* change initial random state */
  CopyFile(fi,fo);
  /* error  */
  nt= n/t-2;
  for(f=0; f<gen_sim; f++)
  { if(f!=0) fprintf(fo," +\n@%d00ns = ",f*n*interleave +10);
    t1= 0;
    for(g=0; g< n; g++) 
    { if((rand()%nt)==0 && t1<t) 
	   { putc('1',fo); t1++; }
      else putc('0',fo); 
  } }
  CopyFile(fi,fo);
  /* data random generating */
  for(f=0; f< gen_sim; f++)
  { if(f!=0) fprintf(fo," +\n@%d00ns = ",f*n*interleave +10);
    for(g=0; g< k; g++) 
    { if(rand()%3 == 0) putc('1',fo);
       else putc('0',fo); 
  } }
}


void
WriteSim()  /* Write to files: sim.cmd  and sim.cme*/ 
{ FILE *fi, *fo; 
  int i,j,f,g, first;
  if(!gen_sim) return;
  printf("Writing to simulation command files: sim.cmd and sim.cme... ");
  if ((fi= fopen("bchs.vht", "r"))== NULL)
  {	printf("\nError. Can not open file bchs.vht\n");
	exit(0);
  }
  if ((fo= fopen("sim.cmd", "w"))== NULL)
      { printf("\nError. Can not write to file sim.cmd.\n"); exit(0); }

    /* write sim.cmd file */
  FindMark(fi); FindMark(fi);
  PrintSim(fi,fo);
  CopyFile(fi,fo);
  fclose(fo);

  /* Writing to file sim.cme */
  if ((fo= fopen("sim.cme", "w"))== NULL)
     { printf("\nError. Can not write to file sim.cme.\n"); exit(0); }
  FindMark(fi); 
  PrintDec(fi, fo, k-1);
  PrintDec(fi, fo, n-1);
  PrintDec(fi, fo, k-1);
  PrintSim(fi,fo);
  PrintDec(fi,fo,nk+1);
  CopyFile(fi,fo);
  fclose(fo);
  printf("done.\n");
}


/****************** OPTIMIZATION *******************************************/
/* The optimization is made by checking how many XOR gates can be extracted
   e.g. dout1<= din1 XOR din2 XOR din3;  dout2<= din1 XOR din2 XOR din4;
	so one XOR gate can be reduced by substitution dxor1<= din1 XOR din2;
   at first are substituted that pairs of variables that are the most commonly occurring
   it is made by assuming the maximum number occurrences of the two variables that can be 
   substituted = m, and than substituting. If non pair of variable can be found the 
   number of 'suit' is decreased until suit = 2  */ 

/* Optimization for one input vector and one output vector */
int
OptimizationA(fo, str, print, map, size)
FILE *fo;
char *str;
int print, *map, size ;
{ /* map[j] - if bit i is 1 then the signal j is connected by XOR to output i */
  int f,g, *mapf, *mapg , suit, suit1, size1, suitMask, mask=1, save=0;
  size1= size;  /* no of signals that are to be optimize - signal once optimized can
		be optimized again, no of optimilisation = size1 - size(beginning size)  */
  suit=m; /* how many signals suit optimization = suit-1 max no. of the suits*/

   /* count number of optimization - size1 */
  while(--suit > optimization) /* optimize only down to optimization level */
  { mapf= map;
    for(f=0; f<size1-1; f++)
    { mapg= mapf+1;  /* find the best suitable signals to optimize */
      for(g=f+1; g<size1; g++)
      { suitMask= *mapf & *mapg;
        suit1=CountOnes(suitMask);
        if(suit1>=suit)  /* optimize - best suitable signals */
        { map[size1]= suitMask; 
          *mapf^= suitMask;  *mapg^= suitMask;
          if(print) 
            fprintf(fo,"\t%s(%d)<= %s(%d) XOR %s(%d); -- %d\n",str,size1,str,f,str,g, suit1-1);
          size1++;
          save+= suit1-1; /* gate saving due to the optimization */
        }
        mapg++;
      }         
      mapf++;
  } }
  if(print) fprintf(fo,"\t\t-- optimization saving = %d XOR gates\n",save);
  return size1;    
}

/* Optimization for one input vector and multiple outputs */

int
OptimizationB(fo, str, print, size, syn_size, map)
FILE *fo;
char *str;  /* the name of signal */
int print, size, syn_size; /* print - print optimization map; size - number of signals */
long int *map;
{ /* if a bit i of map[j] is '1' then input signal str(i) is connected by XOR to
     the output signal j */
  int f,g,h, suit, suit1, last, save=0;
  long *pmap, *mapg, maskf, maskg;
  last= syn_size;  /* last no. of input signals that drive size output signals */
  suit=size/2 +2; /* how many signals suit optimization, the optimization = suit */
  while(--suit > optimization)
  { maskf= 1;
    for(f=0; f<last-1; f++, maskf<<=1)
    { maskg= maskf<<1;  /* find the best suitable signals to optimize */
      for(g=f+1; g<last; g++, maskg<<=1)
      { pmap= map; suit1= 0;
        for(h=0; h<size; h++)  /* count how many signals can be optimize = suit1*/
        { if((maskf & *pmap) && (maskg & *pmap)) /* if signals suit */
            suit1++;
          pmap++;
        }
        if(suit1>=suit)  /* optimize - best suitable signals */
        { pmap= map;
          if(last >31)  /* if no of optimization > 32-syn_size */
	   { if(print)
		fprintf(fo,"\t\t-- Warning: Optimization stopped due to overloading \n"); 
             return 32; 
          }
          if(print) 
	    fprintf(fo,"\t%s(%d)<= %s(%d) XOR %s(%d); -- %d\n",str,last,str,f,str,g,suit1-1);
          for(h=0; h<size; h++)
          { if((maskf & *pmap) && (maskg & *pmap)) /* if signals suit */
	      { *pmap^= (maskf | maskg);   *pmap^= 1<<last; }        
            pmap++;
          }
          last++;
          save+= suit1-1; /* gate saving due to the optimization */    
  } } } } 
  if(print) fprintf(fo,"\t\t-- Saving due to optimization = %d\n", save);
  return last;    
}



/************* SYNDROME CALCULATION  ***************************************/

/* Print syndrome number no LFSR, gen-integer that generate ring */
void
PrintSyn(fo, ftxt, no, maxno)
FILE *fo, *ftxt;
int no, maxno;
{ int f, g, h, B, C, first, first_way, poly[11], syn_size, polya[11], mask, dxorNo, doutNo=0, tmp, noXor=0;
  long map[100], map1[100], *pmap, *pmap1, map10[10];
      /* map[0 - syn_size-2] - syn. ring - syn0 exclude always constant assignment
         map[syn_size-1 - syn_size-1+m*doutNo] - dout */
  /* generate syndrome polynomial by (x+B)*(x+B^2)*... */
  C= B= LPow(no);  /* B=L^syn_no */
  syn_size= 0;
  poly[0]= one; 
  for(f=1; f<11; f++) poly[f]=0;
  while(1)
  { for(g=0; g<11; g++) 
	{ polya[g]=poly[g]; poly[g]=0; }
    for(g=0; g<10; g++)  /* Multiply by (x+C) */
    { poly[g]^= Mul(polya[g],C);
      poly[g+1]^= polya[g];
    }
    syn_size++;
    C= Mul(C,C);
    if(C==B) break;  /* Syndrome bas been calculated */
  }
  fprintf(ftxt,"dsyn%d - syndromes ", no);

  fprintf(fo,"\n\tUSE WORK.const.ALL;\nENTITY dsyn%d IS\n",no);
  fprintf(fo,"PORT (clk");
  if(interleave>1)   fprintf(fo,", ce");
  fprintf(fo,", pe ,din: IN BIT;\n\t");
  f= no; first_way= 1;
  while(1)
  { if(f<= maxno)
    { if(f != no) fprintf(fo,", ");
      fprintf(fo,"dout%d",f);
      if(f!= no) first_way= 0;
      doutNo++;
      fprintf(ftxt, " %d", f);
    }
    f*=2;  f%=n;
    if(f == no) break;
  }
  first_way= first_way && syn_size==m; 

  if(!first_way && optimization)
  { pmap= map; 
    for(f=1; f<syn_size; f++)
    { *pmap = 1<<(f-1);   /* syndrome ring - previous and if poly[f]==1 - last bit */
      if(poly[f]!=0) *pmap |= 1<<(syn_size-1);
      pmap++;
    }   
    f= no;  
    while(1)
    { if(f<= maxno)   /* f - syndrome number */
      { for(g=0; g<syn_size; g++)
          map10[g]= LPow(g*f); /* =L^(g*f) - calculate syndrome f - g-th bit */  
        for(g=syn_size; g<m; g++)
          map10[g]= 0;        /* if syn_size<m reset higher bits  */  
        mask=one;        /* Calculate coefficients for next syndrome f */
        for(g=0;  g<m;  g++, mask>>=1, pmap++)
        { *pmap=0;     /* Convert from map10[a][b-bit] - a - no of output b -no. input to
			 map[a][b-bit] a- no of output b - no of input  */
          for(h=0;  h<m;  h++)
            if(mask & map10[h]) *pmap^= 1<<h;
      } }
      f*=2;  f%=n;
      if(f == no) break;
    }
    pmap=map; pmap1= map1;
    for(f= 0; f<100; f++)   /* Copy map => map1 */
      *pmap1++ = *pmap++;
  }
  tmp= syn_size;
  if(!first_way && optimization)
  { tmp = dxorNo = OptimizationB(fo, "dxor", 0, m*doutNo+syn_size-1, syn_size, map1);
    noXor+= dxorNo - syn_size;
  }

  fprintf(fo,": OUT BIT_VECTOR(0 TO m-1));\n");
  fprintf(fo,"END dsyn%d;\n\n",no);  
  fprintf(fo,"ARCHITECTURE dsyn%da OF dsyn%d IS\n",no,no);
  fprintf(fo,"\tSIGNAL syn: BIT_VECTOR(0 TO %d);\n",tmp-1);
  fprintf(fo,"  BEGIN\n");

  if(first_way)  /* first way of calculating syndromes = r(L^no) */
    fprintf(fo,"\tdout%d<= syn;\n",no);
  else           /* block for second way of calculating */
  if(!optimization)  
  { f=no;
    while(1)
    { if(f<= maxno)
      { for(g=0; g<m; g++)
          map[g]= LPow(g*f); /* =L^(g*f) */
        mask= one;
        for(g=0; g<m; g++)
        { if(f==1)
          { fprintf(fo,"\tdout1(0 TO m-1)<= syn(0 TO m-1);\n");
            break;
          }
          fprintf(fo,"\tdout%d(%d)<=",f,g);
          first=1;
          for(h=0; h<syn_size; h++)  /* mask  */
          { if(mask & map[h])
            { if(!first) { fprintf(fo," XOR"); noXor++; }
               else first=0; 
              fprintf(fo," syn(%d)",h);  
          } }
          mask>>=1;
          if(first) fprintf(fo," '0'");
          fprintf(fo,";\n");
      } } 
      f*=2;
      if(f > n) f-=n;
      if(f == no) break;
  } }
  else  /* block for second way of calculating with optimization */
  { f=no; pmap= map+syn_size-1;
    OptimizationB(fo, "syn", 1, m*doutNo + syn_size-1, syn_size, map);
    while(1)
    { if(f<= maxno)
      { for(g=0; g<m; g++)
        { if(f==1)
          { fprintf(fo,"\tdout1(0 TO m-1)<= syn(0 TO m-1);\n");
            pmap+= m;
            break;
          }
          fprintf(fo,"\tdout%d(%d)<=",f,g);
          first=1; mask= 1;
          for(h=0;  h<dxorNo;  h++, mask<<=1)  /* mask  */
          { if(mask & *pmap)
            { if(!first) { fprintf(fo," XOR"); noXor++; }
               else first=0;
              fprintf(fo," syn(%d)", h);
          } }
          if(first) fprintf(fo," '0'");
          fprintf(fo,";\n");
          pmap++;
      } } 
      f*=2; f%=n;
      if(f == no) break;
  } }
  
  fprintf(fo,"  PROCESS BEGIN\n");
  fprintf(fo,"\tWAIT UNTIL clk'EVENT AND clk='1';\n");  
  fprintf(fo,"\tIF pe='1' THEN\n");
  fprintf(fo,"\t  syn(0)<= din;\n\t  syn(1 TO %d)<= \"", syn_size-1);
  for(f=1; f<syn_size; f++) fputc('0',fo);
  if(interleave==1) fprintf(fo,"\";\n\tELSE\n"); 
   else fprintf(fo,"\";\n\tELSIF ce='1' THEN\n");
  if(first_way) /* first way of calculating syndromes = r(L^no) */
  { for(f=0; f<m; f++)
      map[f]= LPow(f+no); /* = L^(f+no) */
    mask= one; 
    for(f=0; f<m; f++)
    { fprintf(fo,"\tsyn(%d)<=",f);
      if(f==0) { fprintf(fo," din XOR");  noXor++; } 
      first=1;
      for(g=0; g<m; g++)   
      { if(mask & map[g])
        { if(!first) { fprintf(fo," XOR"); noXor++; }
          first=0;
          fprintf(fo," syn(%d)",g);
      } }
      fprintf(fo,";\n"); mask>>=1;
  } }  
  else  /* second way of calculating syndrome using minimal polynomial of L^no */
  if(!optimization)
  { fprintf(fo,"\t  syn(0)<= syn(%d) XOR din;\n",syn_size-1); noXor++;
    for(f=1; f<syn_size; f++)
    { fprintf(fo,"\t  syn(%d)<= syn(%d)",f,f-1);
      if(poly[f]!=0)  { fprintf(fo," XOR syn(%d)",syn_size-1); noXor++; }
      fprintf(fo,";\n");
  } } 
  else /* if optimization and second way */
  { fprintf(fo,"\t  syn(0)<= syn(%d) XOR din;\n",syn_size-1);
    pmap = map; noXor++;
    for(f=1; f<syn_size; f++)
    { fprintf(fo,"\t  syn(%d)<=",f);
      first=1; mask=1;
      for(g=0;  g<dxorNo;  g++, mask<<=1)
      { if(mask & *pmap)
        { if(first) first=0;
           else { fprintf(fo," XOR"); noXor++; }
          fprintf(fo, " syn(%d)",g);
      } }
      fprintf(fo,";\n");
      pmap++;
  } }
  fprintf(fo,"\tEND IF;\n  END PROCESS;\nEND dsyn%da;\n\n",no);
  fprintf(ftxt,"\n");
  PrintNoElem(ftxt, 1, syn_size, noXor);
}


/****************** Print Chien's search circuit ***************************/
void
PrintChien(fo, ftxt, no)
FILE *fo, *ftxt;
int no;
{ int f, g, first, mask, map[50], mapa[50], noOptim=0, noXor=0;

  for(f=0; f<m; f++)
  { map[f]= mapa[f]= LPow(f+no); /* = L^(f*no) - calculation of circuit */ 
    noXor+= CountOnes(map[f])-1;
  }
  fprintf(fo,"\n\tUSE WORK.const.ALL;\nENTITY dch%d IS\n",no);
  fprintf(fo,"PORT (clk,");
  if(interleave>1) fprintf(fo," ce,");
  if(t==2) fprintf(fo," err, errcheck,");
  fprintf(fo," pe: IN BIT;\n");
  fprintf(fo,"\tdin: IN BIT_VECTOR(0 TO m-1);\n");
  fprintf(fo,"\tdout: OUT BIT_VECTOR(0 TO m-1));\n");
  fprintf(fo,"END dch%d;\n\n",no);  

  fprintf(fo,"ARCHITECTURE dch%da OF dch%d IS\n",no,no);
  if(t==2) fprintf(fo,"\tSIGNAL ch0reg: BIT;\n");
   else if(optimization)
     noOptim= OptimizationA(fo,"ch", 0, mapa, m) - m; /* no. optimization */
  fprintf(fo,"\tSIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input\n"); 
  fprintf(fo,"\tSIGNAL ch: BIT_VECTOR(0 TO %d); -- ch registers and optimization \n", m-1+noOptim);

  fprintf(fo,"  BEGIN\n");
  if(t==2) 
  { fprintf(fo,"\tch0reg<= ch(0) XOR err; -- error was found so correct it\n");
    fprintf(fo,"\tdout(0)<= ch(0) XOR errcheck; -- suppose that an error has occured\n");
    fprintf(fo,"\tdout(1 TO m-1)<= ch(1 TO m-1);\n");
  }
   else fprintf(fo,"\tdout<= ch(0 TO m-1);\n");
  if(noOptim)  OptimizationA(fo,"ch", 1, map, m);
 
  mask= one;
  for(f=0; f<m; f++)
  { fprintf(fo,"\tchin(%d)<=",f);
    first=1;
    for(g=0; g<m+noOptim; g++)   
    { if(mask & map[g])
      { if(!first) fprintf(fo," XOR");
        first=0;
        if(g==0 && t==2) fprintf(fo," ch0reg");
         else  fprintf(fo," ch(%d)",g);
    } }
    fprintf(fo,";\n"); mask>>=1;
  }

  fprintf(fo,"  PROCESS BEGIN\n");
  fprintf(fo,"\tWAIT UNTIL clk'EVENT AND clk='1';\n"); 
  fprintf(fo,"\tIF pe='1' THEN\n\t  ch(0 TO m-1)<= din;\n");
  if(interleave==1)   fprintf(fo,"\tELSE\n");
   else fprintf(fo,"\tELSIF ce='1' THEN\n");
  fprintf(fo,"\t  ch(0 TO m-1)<= chin;\n");
  fprintf(fo,"\tEND IF;\n  END PROCESS;\n");
  fprintf(fo,"\t-- number XOR gates= %d;\n", noXor-noOptim);
  fprintf(fo,"END dch%da;\n\n",no);
  fprintf(ftxt,"dch%d - Chien Search for x^%d\n", no, no);
  PrintNoElem(ftxt, 1, m, noXor-noOptim);
}

/*************************** DECODER 1 t=1 *************************************/

void
WriteDec1Vhd(ftxt)  /* Write file dec.vhd if t==1*/
FILE *ftxt; 
{ FILE *fo, *fi;
  int f, mask;
  int syn_size[110]; /* the size of syndrome */
  if ((fi= fopen("bch1.vht", "r"))== NULL)
  {	fprintf(stderr,"\nError. Can not open file bch1.vht\n");
	exit(0);
  }
  if ((fo= fopen("dec.vhd", "w"))== NULL)
  {	fprintf(stderr,"\nError. Can not write to file dec.vhd\n");
	exit(0);
  }
  PrintFileBeg(fo,"decoder");
  FindMark(fi);
  CopyFile(fi,fo);	/* Counter */

  fprintf(ftxt,"dcount - counter - control system\n");
  PrintNoElem(ftxt, 1, m, CountOnes(gen_basis)-1);
  PrintAndCout(fo,0); /* pe <=  */
  CopyFile(fi,fo); 
  PrintAndCout(fo,1); /* vdoutS<= */
  CopyFile(fi,fo); 
  PrintAndCout(fo, k+1); /* vdoutR<= */
  CopyFile(fi,fo); 
  PrintCoutRing(fo);  /* End of dcount and beginning of dsyn */
  CopyFile(fi,fo);

  PrintSyn(fo,ftxt, 1, 1);  /* End of dsyn and beginning of dch */
  CopyFile(fi,fo);
  PrintChien(fo,ftxt,1);  /* End of dch */
  CopyFile(fi,fo);
  fclose(fi);
  fclose(fo);
  fprintf(ftxt, "dbuf - buffer for data to be corrected \n");
  PrintNoElem(ftxt, 1, n+2, 1);
  fprintf(ftxt,"dec - DECODER\n");
  PrintNoElem(ftxt, -1, 0, 0);
}
/********************* decoder2 *************************/

  /* Count ones in the binary representation of din */
int
CountOnes(din)
int din;
{ int f, ret=0, mask=1;
  for(f=0; f<m; f++)
  { if(mask & din) ret++;
    mask<<=1;
  }
  return ret;
}


/* Generate circuit for y=(x)^3 using (a+b)^3=a^3+3*a*a*b+... */
/* return number of XORs */

int
PrintPower3(fo)
FILE *fo;
{ int f, first, g, h, i, j, l, mask, noAnd, size, noDxor, noXor=0; 
  int map1[250], map2[250];
  /* map - map[i]= a0, a1, ...a(m-1) for i<m; map[i]= a0a1, a0a2, ...,a1a2 .... a(m-1)am, i>=m */
  for(f=0; f<m; f++) map1[f]=map2[f]= LPow(3*f);
  noAnd= (m*(m-1))/2; size= m+noAnd; 
    /* noAnd - number of and gates = (m-1)+(m-2)+..+1 = m*(m-1)/2 */
  i=m;
  for(f=0; f<m-1; f++)
    for(g=f+1; g<m; g++)
      { map1[i]= map2[i]= LPow(2*f+g) ^ LPow(2*g+f); i++; }
          /* dual = 3*a*a*b + 3*a*b*b  */
  if(optimization) noDxor= OptimizationA(fo,"dxor", 0, map1, size); 
    else noDxor= size;
  fprintf(fo,"\tSIGNAL dxor: BIT_VECTOR(0 TO %d);\n  BEGIN\n",noDxor-1);
  fprintf(fo,"\tdxor(0 TO m-1)<= din;\n");

  i=m;
  for(f=0; f<m-1; f++)
    for(g=f+1; g<m; g++)
      { fprintf(fo,"\tdxor(%d)<= din(%d) AND din(%d);\n",i,f,g); i++; }

  if(optimization) 
     { OptimizationA(fo,"dxor", 1, map2, size); noXor= noDxor-size; }

  mask=one; 
  for(f=0; f<m; f++)
  { first=1;
    fprintf(fo,"\tdout(%d)<=",f);
    for(g=0; g<noDxor; g++)
    { if(mask & map1[g])
      { if(first) first=0;
         else { fprintf(fo," XOR"); noXor++; }
        fprintf(fo," dxor(%d)",g);
    } }
    fprintf(fo,";\n");   mask>>=1;
  }
  fprintf(fo,"\t\t-- %d XOR gates\n", noXor);
  return noXor;
}


void
WriteDec2Vhd(ftxt)
FILE *ftxt;
{ FILE *fi, *fo;
  int noXor, f;
  if ((fi= fopen("bch2.vht", "r"))== NULL)
  {	printf("\nError. Can not open file bch2.vht\n");
	exit(0);
  }
  if ((fo= fopen("dec.vhd", "w"))== NULL)
  {	printf("\nError. Can not write to file dec.vhd\n");
	exit(0);
  }
  fprintf(ftxt, "ffce - flip flop register\n");
  PrintNoElem(ftxt,1, 1, 0);
  fprintf(ftxt, "dcount - counter - control system\n");
  PrintNoElem(ftxt,1, m, CountOnes(gen_basis)-1);
  fprintf(ftxt, "dbuf - buffer for data to be corrected\n");
  PrintNoElem(ftxt,1, n+2, 1);
  totalReg= blockReg; totalXor= blockXor; blockReg=0; blockXor= 0;
  PrintFileBeg(fo,"decoder");
  FindMark(fi);
  CopyFile(fi,fo);
  PrintAndCout(fo,0);  /* pe<= */
  CopyFile(fi,fo); 
  PrintAndCout(fo,1);  /* cef1<= */
  CopyFile(fi,fo); 
  PrintAndCout(fo,k+1);  /* vdoutR<= */
  CopyFile(fi,fo); 
  PrintCoutRing(fo);  /* End of dcount and beginning of deq */
  CopyFile(fi,fo);

  fprintf(ftxt, "\n----SYNDROMES----\n");
  PrintSyn(fo, ftxt, 1,1);
  PrintSyn(fo, ftxt, 3,3);
  fprintf(ftxt, "SYNDROMES -- total\n");
  PrintNoElem(ftxt,-1, 0, 0);
  totalReg+= blockReg; totalXor+= blockXor; blockReg=0; blockXor= 0;

  fprintf(ftxt, "\n---- Chien search ----\n");  
  CopyFile(fi,fo);
  noXor= PrintPower3(fo);

  fprintf(ftxt, "dpow3 - dout<= din^3\n");  
  PrintNoElem(ftxt,1, 0, noXor);
  fprintf(ftxt, "dcheq - comparison dout<= din^3\n");  
  PrintNoElem(ftxt, -1, 0, m);
  blockXor= m+ noXor; totalXor-= blockXor; /* dcheq is include to error search */

  CopyFile(fi,fo);
  PrintChien(fo,ftxt,1);
  PrintChien(fo,ftxt,3);

  CopyFile(fi,fo);
  fprintf(ftxt,"CHIEN'S SEARCH - total including dcheq\n");
  PrintNoElem(ftxt, -1, 0, 0);
  fprintf(ftxt,"\n------ DECODER ------\n");
  blockXor= totalXor; blockReg= totalReg;
  PrintNoElem(ftxt,-1, 0, 0);
  fclose(fi);
  fclose(fo);
}


/************************************************************************/ 
/**************** decoder3 t>2 ******************************************/

	/* print dual basis ring (LFSR) */
void
PrintRing(fo)
FILE *fo;
{ int f, mask;
  mask= L1; /* mask= L^1 */
  for(f=1; f<m; f++)
  { if(mask & gen_basis) fprintf(fo," XOR ring(%d)",f);
    mask>>=1;
  } 
}

	/* Parallel dual basis multiplier */
void
PrintParDualMul(fo)
FILE *fo;
{ int f, g, mask;
  for(f=1; f<m; f++) 
	fprintf(fo, ", m%din", f);  
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n  BEGIN\n");

  for(f=0; f<m-1; f++)   /* print a(m to 2*m-2) */
  { mask= L1; /* mask= L^1 */
    fprintf(fo,"\taux(%d)<= ddin(%d)",f, f);
    for(g=1; g<m; g++)
    { if(gen_basis & mask) 
      { if(f+g<m) fprintf(fo, " XOR ddin(%d)",f+g);
         else fprintf(fo, " XOR aux(%d)",f+g-m);
      }
      mask>>=1;
    }
    fprintf(fo, ";\n");
  }

  for(f=0; f<m; f++) 
  { fprintf(fo,"\tm%din<= ddin(%d)",f, f);   
    for(g=1; g<m; g++)
    { if(f+g<m) fprintf(fo, " & ddin(%d)", f+g);
       else fprintf(fo, " & aux(%d)", f+g-m);
    }
    fprintf(fo,";\n");
  }
     /* port map (.... */
  for(f=0; f<m; f++)
  { fprintf(fo,"\tm%d:  dsdbm\n\t\tPORT MAP ",f);
    fprintf(fo,"(m%din, dsin, dout(%d));\n", f, f);
} }


	/* Parallel Standard  basis multiplier */
void
PrintParStMul(fo)
FILE *fo;
{ int f, g, h, bi, max, pp[3], first, noXor=0;
  long int map[10][10], map1[100], *pmap, mask;
  /* map[f][g] - map of din1 on g position multiplied by L^f */  
  max= (Ham()-1) *(m-1);
    /* max - no of bx signals, Ham()-Hamming weight of generating basis poly.*/
  pp[0]= polyi; 
  if(m==8) /* generating polynomial = 1 + x^poly[0] +x^poly[1] +x^poly[2] + x^m */
	{ pp[1]= polyi+1;  pp[2]= polyi+2; }
   else  /* trinomial */
	{ pp[1]= 0;  pp[2]= 0; }
  fprintf(fo,"%d);\n\tSIGNAL c0", max);
  for(f=1; f<m; f++) fprintf(fo,", c%d",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n");
  for(f=0; f<m; f++) map[0][f]=f;
  fprintf(fo,"  BEGIN\n\tb(0 TO m-1)<= din1;\n");

  bi=m;
  for(f=1; f<m; f++)   /* where map[f][g] */
  { map[f][0]= map[f-1][m-1]; /* shifting last bit to first - * L^1 */
    for(g=1; g<m; g++)
    { if(g==pp[0] || g==pp[1] || g==pp[2])
      { map[f][g]= bi;
        fprintf(fo,"\tb(%d)<= b(%d) XOR b(%d);\n", bi, map[f-1][g-1], map[f-1][m-1]);
        bi++;
      }
      else map[f][g]= map[f-1][g-1];
  } }
  for(f=0; f<m; f++)
  { fprintf(fo,"\tc%d<= b(%d)",f, map[0][f]);
    for(g=1; g<m; g++) fprintf(fo," & b(%d)",map[g][f]);
    fprintf(fo,";\n\tm%d: dsdbm\n\t\tPORT MAP (din2, c%d, dout(%d));\n",f,f,f);
  }
  return;
}

	/* print serial standard basis multiplier (dssbm2) module2 */
void
PrintSerStMulRing(fo)
FILE *fo;
{ int f;
  for(f=1; f<m; f++)
  { fprintf(fo,"\tring(%d)<= din(%d) XOR (NOT pe AND ", f,f);
    if( gen_basis & Mask(f))
      fprintf(fo,"(ring(m-1) XOR ring(%d)));\n",f-1);
     else
       fprintf(fo,"ring(%d));\n",f-1);
} }

	/* Print dout<= (din)^2 in standard basis */
int		/* return number of XOR gates */
PrintSq(fo)
FILE *fo;
{ int f, g, mask, first, sq[30], noDxor, noXor=0;
  for(f=0; f<m; f++)
	sq[f]= LPow(f*2);  
  if(!optimization)
  { fprintf(fo,"  BEGIN\n");
    mask=one;
    for(f=0; f<m; f++)
    { fprintf(fo,"\tdout(%d)<=",f);
      first= 1;
      for(g=0; g<m; g++)
      { if(sq[g] & mask)
        { if(!first) { fprintf(fo," XOR");  noXor++; }
          first= 0;
          fprintf(fo," din(%d)",g);
      } }
      fprintf(fo,";\n");
      mask>>=1;
    } 
    fprintf(fo,"\t-- no. XOR gates = %d\n", noXor); 
    return noXor;
  } 
  /* if optimization */
  noDxor= OptimizationA(fo, "dxor", 0, sq, m);
  fprintf(fo,"\tSIGNAL dxor: BIT_VECTOR(0 TO %d);\n",noDxor-1);
  fprintf(fo,"  BEGIN\n\tdxor(0 TO m-1)<= din;\n");
  for(f=0; f<m; f++)  
	sq[f]= LPow(f*2);
  OptimizationA(fo, "dxor", 1, sq, m);
  mask=one;
  for(f=0; f<m; f++)
  { fprintf(fo,"\tdout(%d)<=",f);
    first= 1;
    for(g=0; g<noDxor; g++)
    { if(sq[g] & mask)
      { if(!first) { fprintf(fo," XOR"); noXor++; } 
        first= 0;
        fprintf(fo," dxor(%d)",g);
    } }
    fprintf(fo,";\n");
    mask>>=1;
  }
  noXor+= noDxor - m;
  fprintf(fo,"\t-- no. XOR gates = %d\n", noXor); 
  return noXor;  
}


void 
PrintRdrDualOne(fo)
FILE *fo;
{ int f;
  if(m!=8)
  { for(f=0; f<polyi-1; f++) fprintf(fo, "0");
    fprintf(fo, "1");
    for(f=polyi; f<m; f++) fprintf(fo, "0");
  }
  else fprintf(fo,"10100000"); /* for m=8 */
}
	/* print dcheq - entity */
void
PrintChEq(fi, fo)
FILE *fi, *fo;
{ int f,g, firstNo;
  if(option==2) firstNo=0;
   else firstNo= 1;
  fprintf(fo,"din%d", firstNo);
  for(f=firstNo+1; f<=t; f++) 
    fprintf(fo,", din%d", f);
  CopyFile(fi,fo);
  for(f=0; f<m; f++)
  { if(f==0 && firstNo!=0)     
       fprintf(fo,"\teq(0)<= NOT din1(0)");
    else  fprintf(fo,"\teq(%d)<= din%d(%d)",f,firstNo,f);
    for(g=firstNo+1; g<=t; g++) 
      fprintf(fo," XOR din%d(%d)",g,f);
    fprintf(fo,";\n");
  }
  fprintf(fo,"\tdout<= NOT (eq(0)");
  for(f=1; f<m; f++)
    fprintf(fo, " OR eq(%d)", f);
}

	/* print dmli - multiply by L^polyi (for m=8 *L^1) */
int
PrintMli(fo)
FILE *fo;
{ int f, g, B, isgen, first, mask, mul[10], times, noXor=0;
  mask=one;
  if(m!=8) times= polyi;  /* multiply by polyi */
   else times=1; /* multiply by L^1 if m=8 */
  for(f=0; f<m; f++)
  { B= mask;
    for(g=0; g<times; g++)
    { isgen= gen_basis & B;
      B<<=1;
      if(isgen) B^=1;
    }
    mul[f]= B; mask>>=1;
  }  
  mask= one;
  for(f=0; f<m; f++)
  { first= 1; 
    fprintf(fo,"\tdout(%d)<=",f);
    for(g=0; g<m; g++)
    { if(mask & mul[g])
      { if(first) first= 0;
         else { fprintf(fo," XOR"); noXor++; }
         fprintf(fo," din(%d)",g);
    } }
    mask>>=1;
    fprintf(fo,";\n");
  }
  return noXor;
}


/** Print Circuit decoder common for different option - syndrome and Chien's search ***/

PrintComTmec(fo)  
FILE *fo;
{ int f, g, h, smax, s=1, first, firstCh; /* s- syndrome no */

   	/******** syndrome circuit */
  s=1; smax=2*t-1;
  do
  { fprintf(fo,"\ts%d: dsyn%d\n\t\tPORT MAP (clk", s,s);
    if(interleave>1) fprintf(fo,", cei");
    fprintf(fo,", synpe, din,  syn%d",s);
    f= s*2;
    if(f>n) f-=n; 
    while(f!=s)
    { if(f<=smax) fprintf(fo,", syn%d",f);
      f*= 2;
      if(f>n) f-=n;
    }
    fprintf(fo, ");\n");
    s= NextSynNo(s);  
  } while(s<=smax);

      /********* x multiplexers */
  g= 2*t-3; h= 3;
  for(f=0; f< 2*t-1; f++)
  { if(f!=t+1 || t>3)
      fprintf(fo,"\tx%d: dmul21\n\t\tPORT MAP (synpe, sn%dout, syn%d, sn%din);\n",f,g,h,f);
    if(++g > 2*t-2) g=0;
    if(--h <1) h= 2*t-1;
  }

	/********* sn - drdce */
  for(f=0; f<2*t-1; f++)
  { fprintf(fo,"\tsn%d: drdce\n\t\tPORT MAP (clk, ",f);
    if(f==t+1 && t<4) 
	fprintf(fo,"synpe, syn%d, sn%dout);\n", 3*t-f-1, f);
     else fprintf(fo,"snce, sn%din, sn%dout);\n", f, f);
  }

	/********* print Chien's search */
  for(f=1; f<=t; f++)
  { fprintf(fo,"\tch%d: dch%d\n\t\tPORT MAP (clk", f, f);
    if(interleave>1) fprintf(fo,", cei");
    fprintf(fo,", chpe, c%dout, ch%dout);\n", f, f);
  }
  if(option==2) firstCh= 0;
   else firstCh= 1;
  fprintf(fo,"\tcheg: dcheq\n\t\tPORT MAP (ch%dout", firstCh);
  for(f=1+firstCh; f<=t; f++)  fprintf(fo,", ch%dout", f);
  fprintf(fo,",  err);\n");
}

/*********************** Counter functions **************************/
	/* For printing in ca or cb 'and' statement in PrintCount */
	/* print 'ca' and if cb=0; 'cb' if cb=1; 'ci' if cb=2 */
void
PrintCabAnd(fo, str, addLastLetter, cb, count)
FILE *fo;
char *str;
int addLastLetter, cb, count;
{ int mask=1, f, size;
  char strCount;
  if(cb==0) { size= sizea; strCount='a'; }
  if(cb==1) { size= sizeb; strCount= 'b'; }
  if(cb==2) { size= sizei; strCount= 'i'; }
  fprintf(fo, "\t%s",str);
  if(addLastLetter) putc(strCount, fo);
  fprintf(fo,"<=");
  for(f=0; f<size; f++)
  { if(f!=0) fprintf(fo," AND");
    if(!(mask & count)) fprintf(fo," NOT");
    fprintf(fo," c%c(%d)",strCount, f);
    mask<<=1;
  }
  fprintf(fo,";  -- c%c= %d\n", strCount, count);
}  
	/* For printing cb & ca 'and' statement in PrintCount3() */
void
PrintCountAnd(fo, str, count)
FILE *fo;
char *str;
int  count;
{ int mask=1, ca, cb,f;
  count%= n*interleave;  /*  count= ca+ iteration*cb*/
  cb= count/iteration;
  ca= count % iteration;
  PrintCabAnd(fo, str, 1, 1, cb);
  PrintCabAnd(fo, str, 1, 0, ca);
  fprintf(fo, "\t%s<= %sa AND %sb; -- count= %d\n",str, str, str, count);
}

	/* print dci - interleave counter */
void
PrintCounterInter(fi, fo)
FILE *fi, *fo;
{ int f;
  getc(fi); CopyFile(fi, fo); getc(fi);  /* getc -not to copy '5' */
  fprintf(fo,"%d",sizei);  /* constant sizei */
  CopyFile(fi,fo); getc(fi); 
  PrintCabAnd(fo,"cLast",0,2,interleave-1);
  PrintCabAnd(fo,"cBeg",0,2,0);
  CopyFile(fi,fo); getc(fi); 
  
  for(f=1; f<sizei; f++)
    fprintf(fo,"\tcin(%d)<= cand(%d) XOR ci(%d);\n",f,f-1,f);
  for(f=1; f<sizei-1; f++)
    fprintf(fo,"\tcand(%d)<= ci(%d) AND cand(%d);\n",f,f,f-1);
  CopyFile(fi,fo);
}
  
void
PrintCounter3(fi,fo)
FILE *fi, *fo;
{ int f, div, rest, sizel, msmpe;
  if(option == 3) 
  { fprintf(fo,",c0first, cce, caLast1, cbBeg");
    if(m==8) fprintf(fo,", ca3a, ca4a, ca5a");
     else fprintf(fo,", dringPe");
  }
  if(interleave>1) 
	{ fprintf(fo,", cei"); CopyOption(fi,fo, 0,5); }  /* insert dci */
  else CopyOption(fi,fo, 0,0);

  if(option!=2)    /* signal declaration */
    fprintf(fo,"\tSIGNAL cceR, cceS, cceSR, dringCe2, dringPe2: BIT;\n");

    /************ circuit */
  CopyFile(fi,fo);
  PrintCountAnd(fo, "clast", n*interleave -1);
  PrintCountAnd(fo,"chpe1", chpe);
  PrintCountAnd(fo,"vdout1R", vdout-2+ k*interleave);
  PrintCountAnd(fo,"vdout1S", vdout-2);
  PrintCountAnd(fo,"bufR", k*interleave -1);
  PrintCabAnd(fo,"cb0",0, 1, 0);

  if(option==2) 
    { msmpe= 2; fprintf(fo,"\tlCe<= ca0;\n"); }
  else 
  { msmpe= 1;
    fprintf(fo,"\tlCe<= caLast AND NOT cb0;\n");
    fprintf(fo,"\tcaLast1<= caLast;\n");
    PrintCabAnd(fo,"cceR",0,0,m-1);
    fprintf(fo,"\tcceS<= caLast OR synpe1;\n");
    fprintf(fo,"\tcceSR<= cceS OR cceR;\n");
    fprintf(fo,"\tcceP: drd1ce\n\t\tPORT MAP(clk, cceSR, cceS, cce);\n");
    fprintf(fo,"\tcbBeg<= cb0;\n");
    fprintf(fo,"\tc0first<= caNextLast;\n");
    if(m!=8) 
    { fprintf(fo,"\tdringPe<= caLast OR  dringPe2;\n");
      PrintCabAnd(fo,"dringPe2",0,0, m-polyi-1);
    }
    else
    { PrintCabAnd(fo,"ca3a",0,0,3);
      PrintCabAnd(fo,"ca4a",0,0,4);
      PrintCabAnd(fo,"ca5a",0,0,5);
  } }
  
  PrintCabAnd(fo,"msmpe1",0,0,msmpe);
  PrintCabAnd(fo,"ca0",0,0,0);
  PrintCabAnd(fo,"caNextLast",0, 0, iteration-2);
  if(chpe/interleave+2< k+2)  /* buf_size = chpe/interleave+2 or buf_size= k */
  { fprintf(fo,"\tbufCe<= ");
    if(interleave>1) fprintf(fo,"cei1;\n");
     else fprintf(fo,"'1';\n");  /* exclude bufCe register */
  }
  else
  { fprintf(fo,"\tbufSR<= vdout1S OR bufR;\n\tbufCeP: drd1ce\n");
    fprintf(fo,"\t\tPORT MAP (clk, bufSR, vdout1S, bufCe1);\n");
    if(interleave>1)  fprintf(fo,"\tbufCe<= bufCe1 AND cei1;\n");
     else fprintf(fo,"\tbufCe<= bufCe1;\n");
  }
  if(interleave>1)
  { fprintf(fo,"\n\ti1: dci\n\t\tPORT MAP (clk, reset, cei1);\n");
    fprintf(fo,"\tcei<= cei1;\n");
  }
  else 
    fprintf(fo,"\tcei1<= '1';\n");
}


/******* Option TMEC option 2 - parallel without inverse. ****/	  
	  /**** SIGNALS *******/
void
PrintOption2Sig(fo)
FILE *fo;
{  int f,g;
  fprintf(fo,"\tSIGNAL m0out");
  for(f=1; f<=t; f++)
    fprintf(fo,", m%dout",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL c1in");
  for(f=2; f<=t; f++)
    fprintf(fo,", c%din",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL mb2out");
  for(f=3; f<=t; f++)
   fprintf(fo,", mb%dout",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL mc0out");
  for(f=1; f<=t; f++)
    fprintf(fo,", mc%dout",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL b2in");  
  for(f=3; f<=t; f++)
    fprintf(fo,", b%din",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n");
}  

  /* Option 2 circuit ***/
void
PrintOption2Cir(fo)
FILE *fo;
{  int f,g;  
  for(f=0; f<m; f++)   					/* ms */
  { fprintf(fo,"\tms%d: dxort\n\t\tPORT MAP (",f); 
    for(g=0; g<=t; g++)  fprintf(fo,"m%dout(%d), ",g ,f);  
    fprintf(fo,"cs(%d));\n",f);
  }
  for(f=0; f<=t; f++)  	 				/* m */
    fprintf(fo,"\tm%d: dpm\n\t\tPORT MAP (c%dout, sn%dout, m%dout);\n",f,f,f,f);
  for(f=2; f<=t; f++)   					/* c */
    fprintf(fo,"\tc%d: drdcer\n\t\tPORT MAP (clk, snce, synpe, c%din, c%dout);\n",f,f,f);
  for(f=2; f<=t; f++)	   				/* cs */
    fprintf(fo,"\tcs%d: dxorm\n\t\tPORT MAP (mb%dout, mc%dout, c%din);\n",f,f,f,f);
  for(f=0; f<=t; f++)	   				/* mc */
    fprintf(fo,"\tmc%d: dpm\n\t\tPORT MAP (c%dout, dp, mc%dout);\n",f,f,f);
  for(f=2; f<=t; f++)	   				/* mb */
    fprintf(fo,"\tmb%d: dpm\n\t\tPORT MAP (b%dout, dr, mb%dout);\n",f,f,f);
  for(f=4; f<=t; f++)				/* b */
    fprintf(fo,"\tb%d: drdcer\n\t\tPORT MAP (clk, snce, synpe, b%din, b%dout);\n",f,f,f);
  for(f=4; f<=t; f++)	   				/* xb */  			
    fprintf(fo,"\txb%d: dmul21\n\t\tPORT MAP (bsel, b%dout, c%dout, b%din);\n",f,f-2,f-2,f); 
} 

/*********** OPTION 3 *******************/

void
PrintOption3Sig(fo)
FILE *fo;
{ int f,g;
  if(t>=4) fprintf(fo,"\tSIGNAL b4set, b4sIn: BIT;\n");
  fprintf(fo,"\tSIGNAL sn0en");
  for(f=1; f<=t; f++)
    fprintf(fo,", sn%den",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n");

  if(t>3)
  { fprintf(fo,"\tSIGNAL cc2out");
    for(f=3; f<t-1; f++)
    fprintf(fo,", cc%dout",f);
    fprintf(fo,": BIT_VECTOR(0 TO m-1);\n");
  }
  if(t>4)
  { fprintf(fo,"\tSIGNAL b5in");
    for(f=6; f<=t; f++)
      fprintf(fo,", b%din",f);
    fprintf(fo,": BIT_VECTOR(0 TO m-1);\n");
  }
  fprintf(fo,"\tCOMPONENT dcount --counter\n\t\tPORT (clk, reset, drnzero: IN BIT;\n");
  fprintf(fo,"\t\tbsel, bufCe, bufkCe, chpe, msmpe, snce, synpe, vdout, vdout1");
  fprintf(fo,", c0first, cce, caLast1, cbBeg");
  if(m!=8)   fprintf(fo,", dringPe");
   else fprintf(fo,", ca3a, ca4a, ca5a");
  if(interleave>1) fprintf(fo,", cei");
  fprintf(fo,": OUT BIT);\n\t\tEND COMPONENT;\n"); 
  fprintf(fo,"\t\tFOR ALL: dcount USE ENTITY WORK.dcount (dcounta);\n");
}  

  /* Option 3 circuit ***/
void
PrintOption3Cir(fo)
FILE *fo;
{ int f,g;  
  fprintf(fo,"\tsn0e: dandm\n\t\tPORT MAP (c0first, sn0out, sn0en);\n");
  for(f=1; f<=t; f++)   					/* snEn */
    fprintf(fo,"\tsn%de: dandm\n\t\tPORT MAP (c%dout(0), sn%dout, sn%den);\n",f,f,f,f);

  for(f=0; f<m; f++)   					/* ms */
  { fprintf(fo,"\tms%d: dxort\n\t\tPORT MAP (",f); 
    for(g=0; g<=t; g++)  fprintf(fo,"sn%den(%d), ",g ,f);  
    fprintf(fo,"cs(%d));\n",f);
  }
  for(f=2; f<=t; f++)   					/* c */
    fprintf(fo,"\tc%d: dshr\n\t\tPORT MAP (clk, cce, cbBeg, cin(%d), c%dout);\n",f,f,f);
  for(f=2; f<t-1; f++)		   				/* cc */
    fprintf(fo,"\tcc%d: drdce\n\t\tPORT MAP (clk, ccCe, c%dout, cc%dout);\n",f,f,f);
  for(f=3; f<=t; f++)	   					/* mb */
    fprintf(fo,"\tmb%d: dsdbm\n\t\tPORT MAP (b%dout, dm, cin(%d));\n",f,f,f);
  if(t>3) 							/* b4 <= */
  { fprintf(fo,"\tb4set<= caLast and NOT bsel;\n\tb4sIn<= NOT cbBeg AND b2out;\n");
    fprintf(fo,"\tb4: drdceSOne\n\t\tPORT MAP (clk, caLast, b4set, b4sIn, cc2out, b4out);\n");
  }
  for(f=5; f<=t; f++)						/* b */
    fprintf(fo,"\tb%d: drdce\n\t\tPORT MAP (clk, caLast, b%din, b%dout);\n",f,f,f);
  for(f=5; f<=t; f++)	   					/* xb */  			
    fprintf(fo,"\txb%d: dmul21\n\t\tPORT MAP (xbsel, b%dout, cc%dout, b%din);\n",f,f-2,f-2,f); 

     /* counter */
  fprintf(fo,"\tcount: dcount\n\t\tPORT MAP (clk, reset, drnzero, bsel, bufCe, bufkCe");
  fprintf(fo,", chpe, msmPe, snce, synpe, vdout, vdout1, c0first, cce, caLast, cbBeg");
  if(m!=8)  fprintf(fo,", dringPe");
   else fprintf(fo,", ca3, ca4, ca5");
  if(interleave>1)  fprintf(fo,", cei");
  fprintf(fo,");\n\n");
}

	/* Print sim.txt file for t>2 */
void
Print3Txt(ftxt)
FILE *ftxt;
{ fprintf(ftxt,"----- Berlekamp - Massey Algorithm ----\n\n"); }

/*************** TMEC MAIN *****************************************/
void
WriteDec3Vhd(ftxt)
FILE *ftxt;
{ FILE *fi, *fo;
  int f, g, h, smax, s=1, first, firstCh; /* s- syndrome no */
  int noXorDmli, noXorDsq;    
  if ((fi= fopen("bch3.vht", "r"))== NULL)
  {	printf("\nError. Can not write to file bch3.vht\n");
	exit(0);
  }
  if ((fo= fopen("dec.vhd", "w"))== NULL)
  {	printf("\nError. Can not write to file dec.vhd\n");
	exit(0);
  }
  PrintFileBeg(fo,"decoder");
  FindMark(fi);
  buf_size= chpe/interleave + 2; 
  if(buf_size>k+1) buf_size=k;
  PrintDec(fi, fo, buf_size);
  CopyFile(fi,fo);
  PrintRing(fo);  /* dsdbmring - dual basis mul. ring */
  CopyFile(fi,fo);
  PrintParDualMul(fo);   /* dual basis parallel basis multiplier */
  CopyFile(fi,fo);
  PrintParStMul(fo);  /* standard basis parallel basis multiplier */
  CopyFile(fi,fo);
  PrintSerStMulRing(fo);  /* serial standard basis multiplier ring*/
  CopyFile(fi,fo);        /* print dxort */
  for(f=1; f<=t; f++)  fprintf(fo,", din%d",f);
  CopyFile(fi,fo);
  for(f=1; f<=t; f++)  fprintf(fo," XOR din%d",f);
  PrintSB2DB(fo);    /* standard basis to dual basis converter */
  CopyFile(fi,fo); 
  noXorDmli= PrintMli(fo);      /* dout<= din* L^polyi */
  CopyFile(fi,fo);
  noXorDsq= PrintSq(fo);	/* dout<= (din)^2 */
  CopyFile(fi,fo);
  PrintRdrDualOne(fo);
  CopyFile(fi,fo);
  PrintChEq(fi,fo);
  CopyFile(fi,fo);


  fprintf(ftxt,"--------------- Syndromes calculation ------------\n");
  smax= 2*t-1;    
  do
  { PrintSyn(fo,ftxt, s,smax);
    s= NextSynNo(s);  
  }
   while(s<=smax);
  PrintNoElem(ftxt, -1, 0, 0);
  CopyFile(fi,fo);

  fprintf(ftxt,"\n--------------- Chien Search ------------\n");
  fprintf(ftxt, "dcheq - check if Chien search equal zero - found an error\n");
  if(option==2)
  { PrintNoElem(ftxt, 1, 0, m*t);
    fprintf(ftxt,"drdce - m registers for x^0\n");
    PrintNoElem(ftxt, 1, m, 0);
  }
   else PrintNoElem(ftxt, 1, 0, m*(t-1));
  for(f=1; f<=t; f++)
    PrintChien(fo,ftxt,f);
  PrintNoElem(ftxt, -1, 0, 0);	

  CopyFile(fi,fo);  /* dca  */
  PrintCabAnd(fo,"cLast",0, 0, iteration-1);
  CopyFile(fi,fo);
  if(interleave>1) 
     PrintCounterInter(fi, fo); /* print dci - interleave counter */
   else CopyOption(fi,fo, 0,0);  /* do not copy dci */
  CopyFile(fi,fo);
  PrintCounter3(fi,fo);
  CopyFile(fi,fo);

	/**************** DECODER entity **********/
  for(f=1; f<=t; f++)  fprintf(fo,", din%d",f);  /* dxort */
  CopyFile(fi,fo);
  if(option==2) firstCh=0;
   else firstCh=1;
  fprintf(fo,"%d",firstCh);
  for(f=firstCh+1; f<=t; f++)   /* dcheq */
    fprintf(fo,", din%d",f); 
  CopyFile(fi,fo);
	/* print syndromes COMPONENTS */
  s=1;
  do
  { fprintf(fo,"\tCOMPONENT dsyn%d\n\t\tPORT (clk",s);
    if(interleave>1) fprintf(fo,", ce");
    fprintf(fo,", pe, din: IN BIT;\n");
    fprintf(fo, "\t\tdout%d",s);
    f= s*2;
    if(f>n) f-=n; 
    while(f!=s)
    { if(f<=smax) fprintf(fo,", dout%d",f);
      f*= 2;
      if(f>n) f-=n;
    }
    fprintf(fo, ": OUT BIT_VECTOR(0 TO m-1));\n\t\tEND COMPONENT;\n");
    fprintf(fo," \t\tFOR ALL: dsyn%d USE ENTITY WORK.dsyn%d (dsyn%da);\n",s,s,s);
    s= NextSynNo(s);  
  }
   while(s<=smax);
	/* print dch - Chien search COMPONENTS */  
  for(f=1; f<=t; f++)
  { fprintf(fo, "\tCOMPONENT dch%d\n\t\tPORT (clk", f); 
    if(interleave>1)  fprintf(fo, ", ce");
    fprintf(fo, ", pe: IN BIT; din: IN BIT_");
    fprintf(fo,"VECTOR(0 TO m-1);\n\t\t\tdout: OUT BIT_VECTOR(0 TO m-1));\n");
    fprintf(fo,"\t\tEND COMPONENT;\n");
    fprintf(fo,"\t\tFOR ALL: dch%d USE ENTITY WORK.dch%d (dch%da);\n",f,f,f);
  }
  
  /* Choose option by CopyFile() */ 

	/******** variable declaration dec ********/
  fprintf(fo,"\n\t-- common signals generated by C program\n\tSIGNAL syn1");
  for(f=2; f< 2*t; f++)
    fprintf(fo, ", syn%d",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL sn0out");
  for(f=1; f<2*t-1; f++)
    fprintf(fo,", sn%dout",f);
  fprintf(fo, ": BIT_VECTOR(0 TO m-1);\n\tSIGNAL sn0in");
  for(f=1; f<2*t-1; f++)
    if(f!= t+1 || t>3) fprintf(fo,", sn%din",f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL c%dout", firstCh);
  for(f=firstCh+1; f<=t; f++)
    fprintf(fo,", c%dout", f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL b%dout", firstCh+2);
  for(f=3+firstCh; f<=t; f++)
    fprintf(fo,", b%dout", f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n\tSIGNAL ch%dout", firstCh);
  for(f=1+firstCh; f<=t; f++)
    fprintf(fo,", ch%dout", f);
  fprintf(fo,": BIT_VECTOR(0 TO m-1);\n");

  fprintf(fo,"\n\t-- for different option by C program\n");
  if(interleave>1) fprintf(fo,"\tSIGNAL cei: BIT; -- interleave CE\n");
  if(option==2) 
  { PrintOption2Sig(fo); 
    CopyOption(fi,fo,2,2); 
    fprintf(fo,"\n\t--------- for option 2 C program \n");
    PrintOption2Cir(fo);
  }
  else 
  { PrintOption3Sig(fo); 
    if(m!=8) CopyOption(fi,fo,3,9); /* option 3 and m!=8 */
    else CopyOption(fi,fo,3,8); /* option 3 and m=8 */
    fprintf(fo,"\n\t--------- for option 3 C program \n");
    PrintOption3Cir(fo);
  }
  fprintf(fo,"\n\t--------- common C program\n");
  PrintComTmec(fo); 
  CopyFile(fi,fo);
  fclose(fi);
  fclose(fo);

		/* print sim.txt elements number */
  fprintf(ftxt,"\n--------------- Syndromes rearranging ------------\n");
  fprintf(ftxt,"dmul21 - 2 to 1 multiplexers \n");
  if(t==3) f=4;  /* no of x?: */
   else f=2*t-1;
  PrintNoElem(ftxt, f, 0, 0);
  fprintf(ftxt,"drdce - m registers with clock enable\n");
  PrintNoElem(ftxt, 2*t-1, m, 0);
  PrintNoElem(ftxt, -1, 0, 0);

  fprintf(ftxt,"\n--------------- Berlekamp-Massey Algorithm ----\n");
  if(option==2)
  { fprintf(ftxt,"dmul21 - 2 to 1 multiplexers\n");
    PrintNoElem(ftxt, t-1, 0, 0); 
    fprintf(ftxt,"drdceSOne - m registers with set to one\n");
    PrintNoElem(ftxt, 4, m, 0);
    fprintf(ftxt,"drdcer - m registers with reset\n"); 
    PrintNoElem(ftxt, 2*t-4, m, 0);
    fprintf(ftxt,"dxorm - m * XOR - modulo 2 addition\n");
    PrintNoElem(ftxt, t-1, 0, m);
    fprintf(ftxt,"dpm - bit-parallel standard basis multiplier option L\n");
    PrintNoElem(ftxt, 3*t+1, 0, (m-1)*(m+Ham()-2));
    fprintf(ftxt,"dxort - modulo 2 addition\n");
    PrintNoElem(ftxt, m, 0, t-1);
    fprintf(ftxt,"drdce - m registers\n");
    PrintNoElem(ftxt, 2, m, 0);
  }
  else /* option 3 */
  { fprintf(ftxt,"dmul21 - 2 to 1 multiplexers\n");
    if(m==8)   { f= 6; g= 4; }
    else  { f=2;  g= 1; }
    f+= t-4;
    PrintNoElem(ftxt, f, 0, 0);
    fprintf(ftxt,"dmli - multiply by L^i\n");
    PrintNoElem(ftxt, g, 0, noXorDmli);
    fprintf(ftxt,"dinv - inversion/division\n");  
    PrintNoElem(ftxt, 1, 2*m, noXorDsq + (m-1)*(m+Ham()-2));
    if(m!=8)
    { fprintf(ftxt,"dsdbmRing - bit-Serial Dual Basis Multiplier Ring\n");
      PrintNoElem(ftxt, 1, m, 1);
      f= 0;
    }
    else f =1; /* additional drdce for m=8 */ 
    f+= 2*t-6; 
    fprintf(ftxt,"drdce - m registers with clock enable\n");
    PrintNoElem(ftxt, f, m, 0);
    fprintf(ftxt,"drdceSOne - m registers with set to one\n");
    if(m==3) f=1; else f=2;
    PrintNoElem(ftxt, f, m, 0);
    fprintf(ftxt,"drd1ce - single register with clock enable\n");
    PrintNoElem(ftxt, 2, 1, 0);
    fprintf(ftxt,"dsdbm - bit-serial dual basis multiplier\n");
    PrintNoElem(ftxt, t-2, 0, m-1);
    fprintf(ftxt,"dshpe - m shift registers (ring) with parallel enable\n");
    PrintNoElem(ftxt, 1, m, 0);
    fprintf(ftxt,"dshr - m shift registers (ring) with reset and addition\n");
    PrintNoElem(ftxt, t-1, m, 1);
    fprintf(ftxt,"dandm - m AND gates\n");
    PrintNoElem(ftxt, t+1, 0, 0);
    fprintf(ftxt,"dxort - t XOR gates\n");
    PrintNoElem(ftxt, m, 0, t);
    fprintf(ftxt,"dssbm - bit-serial standard basis multiplier\n");
    PrintNoElem(ftxt, 1, m,  m-2+Ham());
  } 
    /* AAA */
  PrintNoElem(ftxt, -1, 0, 0);

  fprintf(ftxt,"\n--------------- The buffer  ----\n");
  fprintf(ftxt,"dbuf - buffer for storing data to be corrected\n");
  PrintNoElem(ftxt, 1, k + buf_size +1, 1);
  PrintNoElem(ftxt, -1, 0, 0);

  fprintf(ftxt,"\n--------------- The control system  ----\n");
  if(interleave>1)
  { fprintf(ftxt,"dci - interleave counter\n");
    PrintNoElem(ftxt, 1, sizei, sizei-1);
  }
  fprintf(ftxt,"dca - less signficant control counter\n");
  PrintNoElem(ftxt, 1, sizea, sizea-1);
  fprintf(ftxt,"dcb - more signficant control counter\n");
  PrintNoElem(ftxt, 1, sizeb, sizeb-1);
  fprintf(ftxt,"dcl - degree of error polynomial\n");
  PrintNoElem(ftxt, 1, sizel, 2*sizel-3);
  fprintf(ftxt,"drd1ce - single register\n");
  PrintNoElem(ftxt, 5, 1, 0);
  fprintf(ftxt,"dcount - control system\n");
  PrintNoElem(ftxt, -1, 0, 0);
  fprintf(ftxt,"\n\n\tDECODER total\n");
  PrintNoElem(ftxt, 1, totalReg, totalXor);    
} 

/**************** Write to sim.txt **********************/

void
WriteSimTxt(ftxt)
FILE *ftxt;
{ int f, Lf, db, mask; /* Lf = L^f */
  fprintf(ftxt,"\n\n\nGF(2^%d) generated by polynomial: 1",m);
  for(f=1, mask= L1; f<m; f++, mask>>=1)
    if(mask & gen_basis) fprintf(ftxt, " + x^%d",f);
  fprintf(ftxt, " + x^%d\n  no.  Standard    Dual basis\n   -   ",m);
  PrintBin(ftxt, 0); fprintf(ftxt,"     "); PrintBin(ftxt, 0);
  Lf=one;
  for(f=0; f<=n; f++)
  { fprintf(ftxt,"\n%4d   ",f);
    PrintBin(ftxt, Lf); fprintf(ftxt,"     ");
    PrintBin(ftxt, SB2DB(Lf) );
    Lf= Mul1(Lf);
} }


/******************** MAIN ******************************/

main()
{ FILE *ftxt, *fi;
  printf("\nThe BCH code generating program.\n");
  if ((fi= fopen("bch.vht", "r"))== NULL)
  {	printf("\nError. Can not open file bch.vht\n");
	exit(0);
  }
  if ((ftxt= fopen("sim.txt", "w"))== NULL)
  {	printf("\nError. Can not write to file sim.txt\n");
	exit(0);
  }
  FindMark(fi);
  CopyFile(fi, ftxt);
  printf("For more information see sim.txt file.\n");
  printf("Reading file bch.in... ");
  ReadBchIn(); 
  WriteEncVhd(fi, ftxt);
  fclose(fi);
  WriteSim();  
  printf("Writing to file dec.vhd... ");
  fprintf(ftxt,"\n\n\n\n\t-------------- DECODER ---------------\n\n");
  blockXor= 0; blockReg= 0; totalReg= 0; totalXor= 0;
  if(t==1) WriteDec1Vhd(ftxt);
  if(t==2) WriteDec2Vhd(ftxt);
  if(t>2) WriteDec3Vhd(ftxt);
  WriteSimTxt(ftxt);
  fclose(ftxt);
  printf("done.\n");
}

