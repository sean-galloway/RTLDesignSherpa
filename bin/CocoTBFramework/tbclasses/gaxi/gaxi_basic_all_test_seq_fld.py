"""GAXI Test Sequences for Field ModeThis module provides test sequences for GAXI components with multiple fields.Simplified to work with the predefined field configurations from gaxi_basic_all_test_config.py."""import randomfrom typing import Dict, List, Any, Optional, Union, Callable, Tuplefrom CocoTBFramework.components.gaxi.gaxi_packet import GAXIPacketfrom CocoTBFramework.components.field_config import FieldConfigclass GAXIFieldSequence:    """    Sequence generator for GAXI components in field mode.    This class creates sequences with multiple fields (addr, ctrl, data),    designed for testing field-mode GAXI components.    """    def __init__(self, name: str, field_config: FieldConfig):        """        Initialize the sequence generator with field configuration.        Args:            name: Sequence name            field_config: Field configuration        """        self.name = name        self.field_config = field_config        # Cache field names for use in sequence generation        self.field_names = field_config.field_names()        # Determine if this is multi-data mode by checking for data0/data1 fields        self.is_multi_data = 'data0' in self.field_names and 'data1' in self.field_names        # Generate field masks for value validation        self.field_masks = {}        self.field_widths = {}        for field_name in self.field_names:            field_def = field_config.get_field(field_name)            self.field_masks[field_name] = (1 << field_def.bits) - 1            self.field_widths[field_name] = field_def.bits        # Initialize storage        self.transactions = []        # Randomizer settings (can be changed later)        self.master_randomizer = None        self.slave_randomizer = None    def mask_field_value(self, field_name: str, value: int) -> int:        """        Mask a field value to ensure it fits within the field's bit width.        Args:            field_name: Name of the field            value: Value to be masked        Returns:            Masked value        """        if field_name not in self.field_masks:            return value        mask = self.field_masks[field_name]        masked_value = value & mask        # Log a warning if masking changed the value        if masked_value != value:            print(f"WARNING: Value 0x{value:X} for field '{field_name}' exceeds bit width ({self.field_widths[field_name]} bits), masked to 0x{masked_value:X}")        return masked_value    def add_write(self, addr: int, data: Union[int, Dict[str, int]],                 ctrl: Optional[int] = None, delay: int = 0) -> 'GAXIFieldSequence':        """        Add a write transaction with address, data, and optional control values.        Args:            addr: Address value            data: Data value or dictionary of data field values (for multi-data)            ctrl: Control value (optional)            delay: Number of clock cycles to delay after this transaction        Returns:            Self for method chaining        """        # Apply masking to address        masked_addr = self.mask_field_value('addr', addr)        # Build field values dictionary        field_values = {'addr': masked_addr}        # Handle data fields        if isinstance(data, dict):            # Multi-data mode (data0, data1)            for field_name, value in data.items():                if field_name in self.field_names:                    field_values[field_name] = self.mask_field_value(field_name, value)        elif self.is_multi_data:            # If data is single value but we have multi-data fields            field_values['data0'] = self.mask_field_value('data0', data)            field_values['data1'] = self.mask_field_value('data1', data)        elif 'data' in self.field_names:            # Regular data field            field_values['data'] = self.mask_field_value('data', data)        # Add ctrl if field exists        if 'ctrl' in self.field_names and ctrl is not None:            field_values['ctrl'] = self.mask_field_value('ctrl', ctrl)        # Store transaction        self.transactions.append({            'fields': field_values,            'delay': delay        })        return self    def add_delay(self, cycles: int) -> 'GAXIFieldSequence':        """        Add delay to the previous transaction or create a delay-only transaction.        Args:            cycles: Number of clock cycles to delay        Returns:            Self for method chaining        """        if self.transactions:            self.transactions[-1]['delay'] += cycles        else:            # Store empty transaction with delay            # Initialize with zeros for all fields            field_values = {field_name: 0 for field_name in self.field_names}            self.transactions.append({                'fields': field_values,                'delay': cycles            })        return self    def generate_packets(self) -> List[GAXIPacket]:        """        Generate GAXIPacket objects from the stored transactions.        Returns:            List of GAXI packets        """        packets = []        for transaction in self.transactions:            packet = GAXIPacket(self.field_config)            # Set fields            for field_name, value in transaction['fields'].items():                setattr(packet, field_name, value)            # Set randomizers if configured            if self.master_randomizer and hasattr(packet, 'set_master_randomizer'):                packet.set_master_randomizer(self.master_randomizer)            if self.slave_randomizer and hasattr(packet, 'set_slave_randomizer'):                packet.set_slave_randomizer(self.slave_randomizer)            packets.append(packet)        return packets    def set_master_randomizer(self, randomizer) -> 'GAXIFieldSequence':        """Set the master randomizer for this sequence."""        self.master_randomizer = randomizer        return self    def set_slave_randomizer(self, randomizer) -> 'GAXIFieldSequence':        """Set the slave randomizer for this sequence."""        self.slave_randomizer = randomizer        return selfclass GAXIFieldTestSequences:    """Factory class for creating field-mode GAXI test sequences."""    @staticmethod    def create_incremental_sequence(name: str, field_config: FieldConfig, count: int = 100,                                    addr_step: int = 4, data_pattern: Optional[Callable] = None) -> GAXIFieldSequence:        """        Create a sequence with incrementing addresses and data values.        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions            addr_step: Address increment between transactions            data_pattern: Optional function to generate data from index        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Use data pattern that increments with index if not provided        if data_pattern is None:            data_pattern = lambda idx: idx & 0xFFFFFFFF        # Generate transactions        for i in range(count):            addr = i * addr_step            data = data_pattern(i)            if sequence.is_multi_data:                # Multi-data mode                data_dict = {                    'data0': data & 0xFFFFFFFF,                    'data1': (data << 8) & 0xFFFFFFFF                }                ctrl = (i * 2) & 0xFF if 'ctrl' in sequence.field_names else None                sequence.add_write(addr, data_dict, ctrl, delay=1)            else:                # Single data field                ctrl = (i * 2) & 0xFF if 'ctrl' in sequence.field_names else None                sequence.add_write(addr, data, ctrl, delay=1)        return sequence    @staticmethod    def create_random_sequence(name: str, field_config: FieldConfig, count: int = 100,                                addr_mask: int = 0xFFF, data_mask: int = 0xFFFFFFFF,                                varies_delays: bool = True) -> GAXIFieldSequence:        """        Create a sequence with random values.        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions            addr_mask: Mask for limiting address range            data_mask: Mask for limiting data range            varies_delays: Add varying delays between transactions        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Generate transactions        for _ in range(count):            addr = random.randint(0, addr_mask)            data = random.randint(0, data_mask)            delay = random.randint(0, 5) if varies_delays else 0            if sequence.is_multi_data:                # Multi-data mode                data_dict = {                    'data0': random.randint(0, data_mask),                    'data1': random.randint(0, data_mask)                }                ctrl = random.randint(0, 0xFF) if 'ctrl' in sequence.field_names else None                sequence.add_write(addr, data_dict, ctrl, delay=delay)            else:                ctrl = random.randint(0, 0xFF) if 'ctrl' in sequence.field_names else None                sequence.add_write(addr, data, ctrl, delay=delay)        return sequence    @staticmethod    def create_back_to_back_sequence(name: str, field_config: FieldConfig, count: int = 100,                                    addr_pattern: str = "incremental",                                    data_pattern: str = "incremental") -> GAXIFieldSequence:        """        Create a sequence with back-to-back transactions (no delays).        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions            addr_pattern: Address pattern ("incremental", "random", "constant")            data_pattern: Data pattern ("incremental", "random", "alternating", "walking_ones")        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Generate transactions        for i in range(count):            # Generate address based on pattern            if addr_pattern == "incremental":                addr = i * 4  # Assume 4-byte aligned addresses            elif addr_pattern == "random":                addr = random.randint(0, 0xFFF) & ~0x3  # Random 4-byte aligned            else:  # constant                addr = 0x100            # Generate data based on pattern            if data_pattern == "incremental":                data = i & 0xFFFFFFFF            elif data_pattern == "random":                data = random.randint(0, 0xFFFFFFFF)            elif data_pattern == "alternating":                data = 0x55555555 if (i % 2 == 0) else 0xAAAAAAAA            elif data_pattern == "walking_ones":                data = 1 << (i % 32)            else:                data = 0xA5A5A5A5            # Generate ctrl if needed            ctrl = None            if 'ctrl' in sequence.field_names:                ctrl = i & 0xFF if data_pattern == "incremental" else random.randint(0, 0xFF)            if sequence.is_multi_data:                # Multi-data mode                if data_pattern == "incremental":                    data_dict = {                        'data0': (i * 3) & 0xFFFFFFFF,                        'data1': (i * 7) & 0xFFFFFFFF                    }                else:                    data_dict = {                        'data0': data & 0xFFFFFFFF,                        'data1': (data << 8) & 0xFFFFFFFF                    }                sequence.add_write(addr, data_dict, ctrl, delay=0)            else:                # Single data field                sequence.add_write(addr, data, ctrl, delay=0)        return sequence    @staticmethod    def create_burst_pause_sequence(name: str, field_config: FieldConfig, burst_size: int = 10,                                    num_bursts: int = 5, pause_length: int = 20,                                    addr_start: int = 0, data_start: int = 0) -> GAXIFieldSequence:        """        Create a sequence with bursts of transactions followed by pauses.        Args:            name: Sequence name            field_config: Field configuration            burst_size: Number of transactions in each burst            num_bursts: Number of bursts            pause_length: Delay between bursts            addr_start: Starting address            data_start: Starting data value        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Generate bursts        for burst in range(num_bursts):            burst_addr_base = addr_start + (burst * burst_size * 4)            burst_data_base = data_start + (burst * burst_size)            # Generate transactions for this burst            for i in range(burst_size):                addr = burst_addr_base + (i * 4)                data = (burst_data_base + i) & 0xFFFFFFFF                # Generate ctrl if needed                ctrl = None                if 'ctrl' in sequence.field_names:                    ctrl = (burst * 16 + i) & 0xFF                if sequence.is_multi_data:                    # Multi-data mode                    data_dict = {                        'data0': data & 0xFFFFFFFF,                        'data1': ((data << 8) + i) & 0xFFFFFFFF                    }                    sequence.add_write(addr, data_dict, ctrl, delay=0)                else:                    # Single data field                    sequence.add_write(addr, data, ctrl, delay=0)            # Add pause after burst (except last burst)            if burst < num_bursts - 1:                sequence.add_delay(pause_length)        return sequence    @staticmethod    def create_full_empty_test_sequence(name: str, field_config: FieldConfig, buffer_depth: int = 16,                                        overflow_factor: float = 1.5,                                        addr_start: int = 0, data_start: int = 0) -> GAXIFieldSequence:        """        Create a sequence designed to test buffer full and empty conditions.        Args:            name: Sequence name            field_config: Field configuration            buffer_depth: Depth of the buffer to test            overflow_factor: Factor to multiply buffer_depth for generating extra transactions            addr_start: Starting address            data_start: Starting data value        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Calculate number of transactions (more than buffer depth to ensure full condition)        count = int(buffer_depth * overflow_factor)        # Generate transactions        for i in range(count):            addr = addr_start + (i * 4)            data = (data_start + i) & 0xFFFFFFFF            # Generate ctrl if needed            ctrl = None            if 'ctrl' in sequence.field_names:                ctrl = i & 0xFF            if sequence.is_multi_data:                # Multi-data mode                data_dict = {                    'data0': data & 0xFFFFFFFF,                    'data1': (data << 8) & 0xFFFFFFFF                }                sequence.add_write(addr, data_dict, ctrl, delay=0)            else:                # Single data field                sequence.add_write(addr, data, ctrl, delay=0)        return sequence    @staticmethod    def create_pattern_test_sequence(name: str, field_config: FieldConfig,                                    addr: int = 0x100, pattern_type: str = "walking") -> GAXIFieldSequence:        """        Create a sequence with specific data patterns for testing data path integrity.        Args:            name: Sequence name            field_config: Field configuration            addr: Address to use for all transactions            pattern_type: Pattern type ("walking", "alternating", "corners", "edges")        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Get the width of the data field        data_width = 32  # Default        if 'data' in sequence.field_names:            data_width = sequence.field_widths['data']        elif 'data0' in sequence.field_names:            data_width = sequence.field_widths['data0']        # Define patterns based on type        patterns = []        if pattern_type == "walking":            # Walking ones and zeros            for i in range(data_width):                patterns.append(1 << i)  # Walking ones            for i in range(data_width):                patterns.append(~(1 << i) & ((1 << data_width) - 1))  # Walking zeros        elif pattern_type == "alternating":            # Alternating patterns            patterns = [                0x55555555 & ((1 << data_width) - 1),  # 0101...                0xAAAAAAAA & ((1 << data_width) - 1),  # 1010...                0x33333333 & ((1 << data_width) - 1),  # 0011...                0xCCCCCCCC & ((1 << data_width) - 1),  # 1100...                0x0F0F0F0F & ((1 << data_width) - 1),  # 00001111...                0xF0F0F0F0 & ((1 << data_width) - 1),  # 11110000...                0x00FF00FF & ((1 << data_width) - 1),  # 00000000 11111111...                0xFF00FF00 & ((1 << data_width) - 1),  # 11111111 00000000...            ]        elif pattern_type == "corners":            # Corner cases            mask = (1 << data_width) - 1            patterns = [                0,                   # All zeros                mask,                # All ones                0x00000001,          # Just LSB                1 << (data_width-1), # Just MSB                0x00000003,          # Two LSBs                mask & ~0x00000001,  # All except LSB                mask & ~(1 << (data_width-1)), # All except MSB            ]        elif pattern_type == "edges":            # Edge cases            patterns = [                0x00000000,  # All zeros                0xFFFFFFFF & ((1 << data_width) - 1),  # All ones                0xA5A5A5A5 & ((1 << data_width) - 1),  # Alternating nibbles                0x5A5A5A5A & ((1 << data_width) - 1),  # Alternating nibbles inverted                0xDEADBEEF & ((1 << data_width) - 1),  # Common test pattern                0x01234567 & ((1 << data_width) - 1),  # Incrementing nibbles                0x76543210 & ((1 << data_width) - 1),  # Decrementing nibbles            ]        else:            # Default if unknown pattern            patterns = [0xA5A5A5A5, 0x5A5A5A5A, 0xFFFFFFFF, 0x00000000]        # Generate a transaction for each pattern        for data in patterns:            # Mask to ensure pattern fits in data width            data = data & ((1 << data_width) - 1)            # Generate ctrl if needed            ctrl = None            if 'ctrl' in sequence.field_names:                ctrl = (data >> 16) & 0xFF  # Use part of the data pattern            if sequence.is_multi_data:                # Multi-data mode                data_dict = {                    'data0': data & 0xFFFFFFFF,                    'data1': ~data & 0xFFFFFFFF  # Complement of data0                }                sequence.add_write(addr, data_dict, ctrl, delay=2)            else:                # Single data field                sequence.add_write(addr, data, ctrl, delay=2)        return sequence    @staticmethod    def create_fifo_mode_test_sequence(name: str, field_config: FieldConfig,                                        gaxi_mode: str = 'fifo_mux', count: int = 50) -> GAXIFieldSequence:        """        Create a sequence specifically designed to test fifo_mux or fifo_flop modes.        Args:            name: Sequence name            field_config: Field configuration            gaxi_mode: GAXI mode ('fifo_mux' or 'fifo_flop')            count: Number of transactions        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Create pattern specific to FIFO behavior testing        for i in range(count):            addr = i * 4            data = 0xA0000000 | i  # Distinctive pattern to identify data in waveforms            # Generate ctrl if needed            ctrl = None            if 'ctrl' in sequence.field_names:                ctrl = 0xC0 | (i & 0x3F)            if sequence.is_multi_data:                data_dict = {                    'data0': 0xAAAA0000 | i,                    'data1': 0x55550000 | i                }                # Vary delay pattern based on FIFO mode                if gaxi_mode == 'fifo_flop':                    # For fifo_flop, alternate between no delay and fixed delay                    # to test the one-cycle latency behavior                    delay = 0 if i % 2 == 0 else 3                else:  # fifo_mux mode                    # For fifo_mux, use varying patterns to stress combinatorial paths                    delay = i % 5                sequence.add_write(addr, data_dict, ctrl, delay=delay)            else:                # Vary delay pattern based on FIFO mode                if gaxi_mode == 'fifo_flop':                    delay = 0 if i % 2 == 0 else 3                else:  # fifo_mux mode                    delay = i % 5                sequence.add_write(addr, data, ctrl, delay=delay)        return sequence    @staticmethod    def create_skid_mode_test_sequence(name: str, field_config: FieldConfig, count: int = 50) -> GAXIFieldSequence:        """        Create a sequence specifically designed to test skid buffer behavior.        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions        Returns:            Configured sequence object        """        sequence = GAXIFieldSequence(name, field_config)        # Create pattern specific to skid buffer testing        for i in range(count):            addr = i * 4            data = 0xB0000000 | i  # Distinctive pattern for skid buffer testing            # Generate ctrl if needed            ctrl = None            if 'ctrl' in sequence.field_names:                ctrl = 0xD0 | (i & 0x0F)            # Create a pattern that stresses skid buffer functionality            stage = i % 8            delay = 0            if stage == 3:                # Pause to test transition from full to emptying                delay = 5            elif stage == 7:                # Final longer pause to ensure buffer empties completely                delay = 10            if sequence.is_multi_data:                # Multi-data mode                data_dict = {                    'data0': 0xBBBB0000 | i,                    'data1': 0x33330000 | i                }                sequence.add_write(addr, data_dict, ctrl, delay=delay)            else:                # Single data field                sequence.add_write(addr, data, ctrl, delay=delay)        return sequence    @staticmethod    def create_all_test_sequences(field_config: FieldConfig, buffer_depth: int = 16,                                    gaxi_mode: str = 'skid') -> Dict[str, GAXIFieldSequence]:        """        Create a comprehensive set of test sequences for field mode.        Args:            field_config: Field configuration            buffer_depth: Buffer depth for sizing tests appropriately            gaxi_mode: GAXI mode ('skid', 'fifo_mux', or 'fifo_flop')        Returns:            Dictionary of named test sequences        """        sequences = {}        # Basic sequences for all modes        sequences['incremental'] = GAXIFieldTestSequences.create_incremental_sequence(            'incremental', field_config, count=buffer_depth*2)        sequences['random'] = GAXIFieldTestSequences.create_random_sequence(            'random', field_config, count=buffer_depth*2)        sequences['back_to_back'] = GAXIFieldTestSequences.create_back_to_back_sequence(            'back_to_back', field_config, count=buffer_depth*2)        sequences['burst_pause'] = GAXIFieldTestSequences.create_burst_pause_sequence(            'burst_pause', field_config, burst_size=buffer_depth//2, num_bursts=4)        sequences['full_empty'] = GAXIFieldTestSequences.create_full_empty_test_sequence(            'full_empty', field_config, buffer_depth=buffer_depth)        sequences['pattern'] = GAXIFieldTestSequences.create_pattern_test_sequence(            'pattern', field_config, pattern_type='walking')        # Mode-specific sequences        if gaxi_mode in ['fifo_mux', 'fifo_flop']:            sequences['fifo_mode'] = GAXIFieldTestSequences.create_fifo_mode_test_sequence(                'fifo_mode', field_config, gaxi_mode=gaxi_mode)        else:  # skid mode            sequences['skid_mode'] = GAXIFieldTestSequences.create_skid_mode_test_sequence(                'skid_mode', field_config)        return sequences