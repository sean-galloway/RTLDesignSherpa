"""GAXI Test Sequences for Standard ModeThis module provides test sequences for GAXI components with a single data field.All sequences operate on a standard field configuration with just the 'data' field."""import randomfrom typing import Dict, List, Any, Optional, Union, Callable, Tuplefrom CocoTBFramework.components.gaxi.gaxi_packet import GAXIPacketfrom CocoTBFramework.components.field_config import FieldConfigclass GAXIStandardSequence:    """    Sequence generator for GAXI components in standard mode.    This class creates sequences with a single data field, designed for testing    standard-mode GAXI components like skid buffers and FIFOs.    """    def __init__(self, name: str, field_config: FieldConfig):        """        Initialize the sequence generator with field configuration.        Args:            name: Sequence name            field_config: Field configuration (must contain 'data' field)        """        self.name = name        self.field_config = field_config        # Verify this is a standard-mode field config        if 'data' not in field_config.field_names():            raise ValueError("Standard mode sequence requires 'data' field in field configuration")        # Get data field mask for value validation        data_field = field_config.get_field('data')        self.data_mask = (1 << data_field.bits) - 1        self.data_width = data_field.bits        # Initialize storage        self.transactions = []        # Randomizer settings (can be changed later)        self.master_randomizer = None        self.slave_randomizer = None    def mask_data_value(self, value: int) -> int:        """        Mask a data value to ensure it fits within the field's bit width.        Args:            value: Value to be masked        Returns:            Masked value        """        masked_value = value & self.data_mask        # Log a warning if masking changed the value        if masked_value != value:            print(f"WARNING: Value 0x{value:X} exceeds data width ({self.data_width} bits), masked to 0x{masked_value:X}")        return masked_value    def add_data(self, data: int, delay: int = 0) -> 'GAXIStandardSequence':        """        Add a transaction with a data value.        Args:            data: Data value            delay: Number of clock cycles to delay after this transaction        Returns:            Self for method chaining        """        # Apply masking        masked_data = self.mask_data_value(data)        # Store transaction        self.transactions.append({            'data': masked_data,            'delay': delay        })        return self    def add_delay(self, cycles: int) -> 'GAXIStandardSequence':        """        Add delay to the previous transaction or create a delay-only transaction.        Args:            cycles: Number of clock cycles to delay        Returns:            Self for method chaining        """        if self.transactions:            self.transactions[-1]['delay'] += cycles        else:            # Store empty transaction with delay            self.transactions.append({                'data': 0,                'delay': cycles            })        return self    def generate_packets(self) -> List[GAXIPacket]:        """        Generate GAXIPacket objects from the stored transactions.        Returns:            List of GAXI packets        """        packets = []        for transaction in self.transactions:            packet = GAXIPacket(self.field_config)            # Set data field            packet.data = transaction['data']            # Set delay if randomizers are configured            if self.master_randomizer and hasattr(packet, 'set_master_randomizer'):                packet.set_master_randomizer(self.master_randomizer)            if self.slave_randomizer and hasattr(packet, 'set_slave_randomizer'):                packet.set_slave_randomizer(self.slave_randomizer)            packets.append(packet)        return packets    def set_master_randomizer(self, randomizer) -> 'GAXIStandardSequence':        """Set the master randomizer for this sequence."""        self.master_randomizer = randomizer        return self    def set_slave_randomizer(self, randomizer) -> 'GAXIStandardSequence':        """Set the slave randomizer for this sequence."""        self.slave_randomizer = randomizer        return selfclass GAXIStandardTestSequences:    """Factory class for creating standard-mode GAXI test sequences."""    @staticmethod    def create_incremental_sequence(name: str, field_config: FieldConfig, count: int = 100,                                    data_pattern: Optional[Callable] = None) -> GAXIStandardSequence:        """        Create a sequence with incrementing data values.        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions            data_pattern: Optional function to generate data from index        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Use data pattern that increments with index if not provided        if data_pattern is None:            data_pattern = lambda idx: idx & 0xFFFFFFFF        # Generate transactions        for i in range(count):            data = data_pattern(i)            sequence.add_data(data, delay=1)        return sequence    @staticmethod    def create_random_sequence(name: str, field_config: FieldConfig, count: int = 100,                               data_mask: int = 0xFFFFFFFF,                               varies_delays: bool = True) -> GAXIStandardSequence:        """        Create a sequence with random data values.        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions            data_mask: Mask for limiting data range            varies_delays: Add varying delays between transactions        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Generate transactions        for _ in range(count):            data = random.randint(0, data_mask)            delay = random.randint(0, 5) if varies_delays else 0            sequence.add_data(data, delay=delay)        return sequence    @staticmethod    def create_back_to_back_sequence(name: str, field_config: FieldConfig, count: int = 100,                                    data_pattern: str = "incremental") -> GAXIStandardSequence:        """        Create a sequence with back-to-back transactions (no delays).        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions            data_pattern: Data pattern ("incremental", "random", "alternating", "walking_ones")        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Generate transactions        for i in range(count):            # Generate data based on pattern            if data_pattern == "incremental":                data = i & 0xFFFFFFFF            elif data_pattern == "random":                data = random.randint(0, 0xFFFFFFFF)            elif data_pattern == "alternating":                data = 0x55555555 if (i % 2 == 0) else 0xAAAAAAAA            elif data_pattern == "walking_ones":                data = 1 << (i % 32)            else:                data = 0xA5A5A5A5            sequence.add_data(data, delay=0)        return sequence    @staticmethod    def create_burst_pause_sequence(name: str, field_config: FieldConfig, burst_size: int = 10,                                   num_bursts: int = 5, pause_length: int = 20,                                   data_start: int = 0) -> GAXIStandardSequence:        """        Create a sequence with bursts of transactions followed by pauses.        Args:            name: Sequence name            field_config: Field configuration            burst_size: Number of transactions in each burst            num_bursts: Number of bursts            pause_length: Delay between bursts            data_start: Starting data value        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Generate bursts        for burst in range(num_bursts):            burst_data_base = data_start + (burst * burst_size)            # Generate transactions for this burst            for i in range(burst_size):                data = (burst_data_base + i) & 0xFFFFFFFF                sequence.add_data(data, delay=0)            # Add pause after burst (except last burst)            if burst < num_bursts - 1:                sequence.add_delay(pause_length)        return sequence    @staticmethod    def create_full_empty_test_sequence(name: str, field_config: FieldConfig, buffer_depth: int = 16,                                       overflow_factor: float = 1.5,                                       data_start: int = 0) -> GAXIStandardSequence:        """        Create a sequence designed to test buffer full and empty conditions.        Args:            name: Sequence name            field_config: Field configuration            buffer_depth: Depth of the buffer to test            overflow_factor: Factor to multiply buffer_depth for generating extra transactions            data_start: Starting data value        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Calculate number of transactions (more than buffer depth to ensure full condition)        count = int(buffer_depth * overflow_factor)        # Generate transactions        for i in range(count):            data = (data_start + i) & 0xFFFFFFFF            sequence.add_data(data, delay=0)        return sequence    @staticmethod    def create_pattern_test_sequence(name: str, field_config: FieldConfig,                                    pattern_type: str = "walking") -> GAXIStandardSequence:        """        Create a sequence with specific data patterns for testing data path integrity.        Args:            name: Sequence name            field_config: Field configuration            pattern_type: Pattern type ("walking", "alternating", "corners", "edges")        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Get the width of the data field        data_field = field_config.get_field('data')        data_width = data_field.bits        # Define patterns based on type        patterns = []        if pattern_type == "alternating":            # Alternating patterns            patterns = [                0x55555555 & ((1 << data_width) - 1),  # 0101...                0xAAAAAAAA & ((1 << data_width) - 1),  # 1010...                0x33333333 & ((1 << data_width) - 1),  # 0011...                0xCCCCCCCC & ((1 << data_width) - 1),  # 1100...                0x0F0F0F0F & ((1 << data_width) - 1),  # 00001111...                0xF0F0F0F0 & ((1 << data_width) - 1),  # 11110000...                0x00FF00FF & ((1 << data_width) - 1),  # 00000000 11111111...                0xFF00FF00 & ((1 << data_width) - 1),  # 11111111 00000000...            ]        elif pattern_type == "corners":            # Corner cases            mask = (1 << data_width) - 1            patterns = [                0,                   # All zeros                mask,                # All ones                0x00000001,          # Just LSB                1 << (data_width-1), # Just MSB                0x00000003,          # Two LSBs                mask & ~0x00000001,  # All except LSB                mask & ~(1 << (data_width-1)), # All except MSB            ]        elif pattern_type == "edges":            # Edge cases            patterns = [                0x00000000,  # All zeros                0xFFFFFFFF & ((1 << data_width) - 1),  # All ones                0xA5A5A5A5 & ((1 << data_width) - 1),  # Alternating nibbles                0x5A5A5A5A & ((1 << data_width) - 1),  # Alternating nibbles inverted                0xDEADBEEF & ((1 << data_width) - 1),  # Common test pattern                0x01234567 & ((1 << data_width) - 1),  # Incrementing nibbles                0x76543210 & ((1 << data_width) - 1),  # Decrementing nibbles            ]        elif pattern_type == "walking":            # Walking ones and zeros            patterns.extend(1 << i for i in range(data_width))            patterns.extend(~(1 << i) & ((1 << data_width) - 1) for i in range(data_width))        else:            # Default if unknown pattern            patterns = [0xA5A5A5A5, 0x5A5A5A5A, 0xFFFFFFFF, 0x00000000]        # Generate a transaction for each pattern        for data in patterns:            # Mask to ensure pattern fits in data width (redundant with add_data, but clearer)            data = data & ((1 << data_width) - 1)            sequence.add_data(data, delay=2)        return sequence    @staticmethod    def create_boundary_test_sequence(name: str, field_config: FieldConfig, count: int = 20) -> GAXIStandardSequence:        """        Create a sequence that tests boundary values for the data field.        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Get data field mask        data_field = field_config.get_field('data')        data_mask = (1 << data_field.bits) - 1        # Generate test patterns        for i in range(count):            pattern_type = i % 4            if pattern_type == 0:                # All ones                data = data_mask            elif pattern_type == 1:                # All zeros                data = 0            elif pattern_type == 2:                data = 1 << (i // 4) % 32            else:                # Exceed max to test masking                data = data_mask + 0x1000            sequence.add_data(data, delay=1)        return sequence    @staticmethod    def create_skid_mode_test_sequence(name: str, field_config: FieldConfig, count: int = 50) -> GAXIStandardSequence:        """        Create a sequence specifically designed to test skid buffer behavior.        Args:            name: Sequence name            field_config: Field configuration            count: Number of transactions        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Create pattern specific to skid buffer testing        for i in range(count):            data = 0xB0000000 | i  # Distinctive pattern for skid buffer testing            # Create a pattern that stresses skid buffer functionality            # Alternate between back-to-back transfers and pauses            # to test both skid buffer filling and emptying behaviors            stage = i % 8            if stage < 3 or stage != 3 and stage < 7:                # Multiple back-to-back transfers to fill the skid buffer                sequence.add_data(data, delay=0)            elif stage == 3:                # Pause to test transition from full to emptying                sequence.add_data(data, delay=5)            else:  # stage == 7                # Final longer pause to ensure buffer empties completely                sequence.add_data(data, delay=10)        return sequence    @staticmethod    def create_fifo_mode_test_sequence(name: str, field_config: FieldConfig,                                      gaxi_mode: str = 'fifo_mux', count: int = 50) -> GAXIStandardSequence:        """        Create a sequence specifically designed to test fifo_mux or fifo_flop modes.        Args:            name: Sequence name            field_config: Field configuration            gaxi_mode: GAXI mode ('fifo_mux' or 'fifo_flop')            count: Number of transactions        Returns:            Configured sequence object        """        sequence = GAXIStandardSequence(name, field_config)        # Create pattern specific to FIFO behavior testing        for i in range(count):            data = 0xA0000000 | i  # Distinctive pattern to identify data in waveforms            # Vary delay pattern based on FIFO mode            if gaxi_mode == 'fifo_flop':                # For fifo_flop, alternate between no delay and fixed delay                # to test the one-cycle latency behavior                if i % 2 == 0:                    sequence.add_data(data, delay=0)  # Back-to-back                else:                    sequence.add_data(data, delay=3)  # Gap to clearly see flop behavior            else:  # fifo_mux mode                # For fifo_mux, use varying patterns to stress combinatorial paths                delay = i % 5                sequence.add_data(data, delay=delay)        return sequence    @staticmethod    def create_all_test_sequences(field_config: FieldConfig, buffer_depth: int = 16,                                    gaxi_mode: str = 'skid') -> Dict[str, GAXIStandardSequence]:        """        Create a comprehensive set of test sequences for standard mode.        Args:            field_config: Field configuration            buffer_depth: Buffer depth for sizing tests appropriately            gaxi_mode: GAXI mode ('skid', 'fifo_mux', or 'fifo_flop')        Returns:            Dictionary of named test sequences        """        sequences = {            'incremental': GAXIStandardTestSequences.create_incremental_sequence(                'incremental', field_config, count=buffer_depth * 2            )        }        sequences['random'] = GAXIStandardTestSequences.create_random_sequence(            'random', field_config, count=buffer_depth*2)        sequences['back_to_back'] = GAXIStandardTestSequences.create_back_to_back_sequence(            'back_to_back', field_config, count=buffer_depth*2)        sequences['burst_pause'] = GAXIStandardTestSequences.create_burst_pause_sequence(            'burst_pause', field_config, burst_size=buffer_depth//2, num_bursts=4)        sequences['full_empty'] = GAXIStandardTestSequences.create_full_empty_test_sequence(            'full_empty', field_config, buffer_depth=buffer_depth)        sequences['pattern'] = GAXIStandardTestSequences.create_pattern_test_sequence(            'pattern', field_config, pattern_type='walking')        sequences['boundary'] = GAXIStandardTestSequences.create_boundary_test_sequence(            'boundary', field_config)        # Mode-specific sequences        if gaxi_mode in {'fifo_mux', 'fifo_flop'}:            sequences['fifo_mode'] = GAXIStandardTestSequences.create_fifo_mode_test_sequence(                'fifo_mode', field_config, gaxi_mode=gaxi_mode)        else:  # skid mode            sequences['skid_mode'] = GAXIStandardTestSequences.create_skid_mode_test_sequence(                'skid_mode', field_config)        return sequences