"""Testbench for FIFO module"""import osimport loggingimport randomimport cocotbfrom collections import dequefrom CocoTBFramework.tbclasses.tbbase import TBBasefrom CocoTBFramework.components.flex_randomizer import FlexRandomizerfrom CocoTBFramework.components.fifo.fifo_packet import FIFOPacketfrom CocoTBFramework.components.fifo.fifo_master import FIFOMasterfrom CocoTBFramework.components.fifo.fifo_slave import FIFOSlavefrom CocoTBFramework.components.fifo.fifo_monitor import FIFOMonitorfrom CocoTBFramework.components.field_config import FieldConfigclass FIFOScoreboard:    """    Specialized scoreboard for FIFO testing.    Features:    - Tracks packets sent through the FIFO    - Compares output packets against expected data    - Checks for data ordering and integrity    """    def __init__(self, title, field_config, log=None):        """Initialize the scoreboard"""        self.title = title        # Convert to FieldConfig if received as dictionary        if isinstance(field_config, dict):            self.field_config = FieldConfig.validate_and_create(field_config)        else:            self.field_config = field_config        # Create a logger if not provided        if log is None:            self.log = logging.getLogger(f"{title}")            self.log.setLevel(logging.INFO)        else:            self.log = log        # Initialize queues        self.expected_queue = deque()  # Input side transactions        self.actual_queue = deque()    # Output side transactions        # Error tracking        self.error_count = 0        self.comparison_count = 0    def clear(self):        """Clear all queues and reset counters"""        self.expected_queue.clear()        self.actual_queue.clear()        self.error_count = 0        self.comparison_count = 0    def add_expected_packet(self, packet):        """        Add an expected packet from the write side of the FIFO        Args:            packet: Input packet from write monitor        """        self.expected_queue.append(packet)        self.log.debug(f"Added expected packet: {packet.formatted(compact=True) if hasattr(packet, 'formatted') else str(packet)}")    def add_actual_packet(self, packet):        """        Add an actual packet from the read side of the FIFO        Args:            packet: Output packet from read monitor        """        self.actual_queue.append(packet)        self.log.debug(f"Added actual packet: {packet.formatted(compact=True) if hasattr(packet, 'formatted') else str(packet)}")        # Perform comparison automatically        self._check_next_packet()    def _check_next_packet(self):        """Check the next output packet against expected data"""        if not self.actual_queue or not self.expected_queue:            return        # Get the next expected and actual packets        expected = self.expected_queue.popleft()        actual = self.actual_queue.popleft()        self.comparison_count += 1        # Compare data fields        expected_data = expected.data if hasattr(expected, 'data') else 0        actual_data = actual.data if hasattr(actual, 'data') else 0        # If we have other fields, compare them too        if hasattr(expected, 'addr') and hasattr(actual, 'addr'):            expected_addr = expected.addr            actual_addr = actual.addr            addr_match = expected_addr == actual_addr        else:            addr_match = True  # No address fields to compare        if hasattr(expected, 'ctrl') and hasattr(actual, 'ctrl'):            expected_ctrl = expected.ctrl            actual_ctrl = actual.ctrl            ctrl_match = expected_ctrl == actual_ctrl        else:            ctrl_match = True  # No control fields to compare        # Check for mismatch        if expected_data != actual_data or not addr_match or not ctrl_match:            self.error_count += 1            # Construct error message            error_msg = f"Packet mismatch (#{self.comparison_count}):\n"            error_msg += f"  Expected: data=0x{expected_data:X}"            if not addr_match:                error_msg += f", addr=0x{expected_addr:X}"            if not ctrl_match:                error_msg += f", ctrl=0x{expected_ctrl:X}"            error_msg += f"\n  Actual:   data=0x{actual_data:X}"            if not addr_match:                error_msg += f", addr=0x{actual_addr:X}"            if not ctrl_match:                error_msg += f", ctrl=0x{actual_ctrl:X}"            self.log.error(error_msg)        else:            self.log.debug(f"Packet match (#{self.comparison_count}): data=0x{actual_data:X}")    def check_remaining_data(self):        """        Check if any queues have leftover data        Returns:            Number of errors (non-zero if any queue has leftover data)        """        errors = 0        # Check expected queue (write side)        if self.expected_queue:            pending_count = len(self.expected_queue)            self.log.error(f"FIFO has {pending_count} expected packets that never came out")            errors += 1        # Check actual queue (read side)        if self.actual_queue:            extra_count = len(self.actual_queue)            self.log.error(f"FIFO has {extra_count} actual packets that were not expected")            errors += 1        return errors    def report(self):        """        Generate a report and return the number of errors        Returns:            Number of errors detected        """        # Check for any leftover data        leftover_errors = self.check_remaining_data()        total_errors = self.error_count + leftover_errors        # Log summary        self.log.info(f"Scoreboard report for {self.title}:")        self.log.info(f"  Packets compared: {self.comparison_count}")        self.log.info(f"  Data mismatches: {self.error_count}")        self.log.info(f"  Leftover data errors: {leftover_errors}")        self.log.info(f"  Total errors: {total_errors}")        if total_errors == 0:            self.log.info("  TEST PASSED: All packets verified successfully")        else:            self.log.error(f"  TEST FAILED: {total_errors} errors detected")        return total_errorsclass FIFOTB(TBBase):    """    Testbench for the FIFO modules.    Features:    - Write side with master for pushing data    - Read side with slave for pulling data    - Monitors for both sides    - Scoreboard for verification    - Support for various test types    """    def __init__(self, dut):        """Initialize the testbench with the DUT"""        super().__init__(dut)        # Get test parameters from environment variables        self.DATA_WIDTH = self.convert_to_int(os.environ.get('DATA_WIDTH', '32'))        self.ID_WIDTH = self.convert_to_int(os.environ.get('ID_WIDTH', '4'))        self.OUTPUT_FIFO_DEPTH = self.convert_to_int(os.environ.get('OUTPUT_FIFO_DEPTH', '16'))        # Calculate DEPTH from ID_WIDTH if not provided directly        self.MODE = os.environ.get('MODE', 'skid')  # fifo_mux, fifo_flop        self.SEED = self.convert_to_int(os.environ.get('SEED', '12345'))        # Initialize random generator        random.seed(self.SEED)        # Clock and reset signals        self.clock = self.dut.i_clk        self.reset_n = self.dut.i_rst_n        # Log configuration        self.log.info(f"FIFO TB initialized with DATA_WIDTH={self.DATA_WIDTH}, ID_WIDTH={self.ID_WIDTH}")        self.log.info(f"DEPTH={self.DEPTH}, MODE={self.MODE}, SEED={self.SEED}")        # Define field configuration        self.field_config = FieldConfig()        self.field_config.add_field_dict('data', {            'bits': self.DATA_WIDTH,            'default': 0,            'format': 'hex',            'display_width': (self.DATA_WIDTH + 3) // 4,            'active_bits': (self.DATA_WIDTH-1, 0),            'description': 'Data value'        })        # Add ID field when ID_WIDTH > 0        if self.ID_WIDTH > 0:            self.field_config.add_field_dict('id', {                'bits': self.ID_WIDTH,                'default': 0,                'format': 'hex',                'display_width': (self.ID_WIDTH + 3) // 4,                'active_bits': (self.ID_WIDTH-1, 0),                'description': 'ID value'            })        # Create randomizers for master and slave with different configurations        self.randomizer_configs = {            'fast': {'write_delay': ([[0, 0]], [1])},                     # No delay            'moderate': {'write_delay': ([[0, 2], [3, 6]], [3, 1])},      # Moderate delay            'slow': {'write_delay': ([[0, 1], [2, 10], [11, 20]], [1, 3, 1])}  # Longer delay        }        # Create randomizers        self.master_randomizer = FlexRandomizer(self.randomizer_configs['moderate'])        self.slave_randomizer = FlexRandomizer({            'read_delay': ([[0, 0], [1, 3], [4, 8]], [3, 2, 1])        })        # Define signal maps for master (write side)        self.master_map = {            'i_write': 'i_write',            'o_wr_full': 'o_wr_full'        }        self.master_opt_map = {            'i_wr_data': 'i_wr_data'        }        # Define signal maps for slave (read side)        self.slave_map = {            'o_rd_empty': 'o_rd_empty',            'i_read': 'i_read'        }        # Select signal map based on mode        if self.MODE == 'fifo_mux':            self.slave_opt_map = {                'o_rd_data': 'ow_rd_data'            }        else:            self.slave_opt_map = {                'o_rd_data': 'o_rd_data'            }        # Create FIFO master (write side)        self.master = FIFOMaster(            dut, 'FIFO Master', '', self.clock,            field_config=self.field_config,            randomizer=self.master_randomizer,            timeout_cycles=1000,            signal_map=self.master_map,            optional_signal_map=self.master_opt_map,            multi_sig=False,            log=self.log        )        # Create FIFO slave (read side)        self.slave = FIFOSlave(            dut, 'FIFO Slave', '', self.clock,            field_config=self.field_config,            randomizer=self.slave_randomizer,            timeout_cycles=1000,            signal_map=self.slave_map,            optional_signal_map=self.slave_opt_map,            multi_sig=False,            mode=self.MODE,            log=self.log        )        # Create monitors for write and read sides        self.write_monitor = FIFOMonitor(            dut, 'FIFO Write Monitor', '', self.clock,            field_config=self.field_config,            is_slave=False,            signal_map=self.master_map,            optional_signal_map=self.master_opt_map,            multi_sig=False,            mode=self.MODE,            log=self.log        )        self.read_monitor = FIFOMonitor(            dut, 'FIFO Read Monitor', '', self.clock,            field_config=self.field_config,            is_slave=True,            signal_map=self.slave_map,            optional_signal_map=self.slave_opt_map,            multi_sig=False,            mode=self.MODE,            log=self.log        )        # Create scoreboard        self.scoreboard = FIFOScoreboard(            'FIFO Scoreboard',            self.field_config,            log=self.log        )        # Test counters        self.total_errors = 0    async def assert_reset(self):        """Assert the reset signal"""        self.reset_n.value = 0        # Reset master and slave        await self.master.reset_bus()        await self.slave.reset_bus()    async def deassert_reset(self):        """Deassert the reset signal"""        self.reset_n.value = 1        self.log.info("Reset deasserted")    def get_randomizer_by_name(self, name):        """Get a randomizer by name"""        if name in self.randomizer_configs:            return FlexRandomizer(self.randomizer_configs[name])        self.log.warning(f"Unknown randomizer name: {name}, using 'moderate'")        return FlexRandomizer(self.randomizer_configs['moderate'])    def set_master_randomizer(self, name='moderate'):        """Set randomizer for master"""        self.master.set_randomizer(self.get_randomizer_by_name(name))        self.log.info(f"Set master randomizer to {name}")    def set_slave_randomizer(self, name='moderate'):        """Set randomizer for slave"""        if name == 'fixed':            self.slave.set_randomizer(FlexRandomizer({                'read_delay': ([[2, 2]], [1])            }))        elif name == 'fast':            self.slave.set_randomizer(FlexRandomizer({                'read_delay': ([[0, 0]], [1])            }))        elif name == 'slow':            self.slave.set_randomizer(FlexRandomizer({                'read_delay': ([[0, 1], [2, 10], [11, 20]], [1, 3, 1])            }))        else:  # moderate (default)            self.slave.set_randomizer(FlexRandomizer({                'read_delay': ([[0, 0], [1, 3], [4, 8]], [3, 2, 1])            }))        self.log.info(f"Set slave randomizer to {name}")    async def wait_for_master_idle(self):        """Wait until master has completed its transmissions"""        while self.master.transfer_busy:            await self.wait_clocks('i_clk', 1)    async def wait_for_expected_outputs(self, expected_count, timeout_clocks=5000):        """        Wait until the expected number of outputs have been received or timeout        Args:            expected_count: Expected number of output packets            timeout_clocks: Maximum number of clock cycles to wait        Returns:            True if all expected outputs were received, False if timeout        """        count = 0        while len(self.read_monitor.observed_queue) < expected_count and count < timeout_clocks:            await self.wait_clocks('i_clk', 1)            count += 1            # Status updates every 200 clocks            if count % 200 == 0:                self.log.info(f"Waiting for outputs: {len(self.read_monitor.observed_queue)}/{expected_count} received")        received = len(self.read_monitor.observed_queue)        if received < expected_count:            self.log.warning(f"Timeout waiting for outputs: {received}/{expected_count} received")            return False        self.log.info(f"All expected outputs received: {received}/{expected_count}")        return True    async def send_packets(self, count, base_data=0, base_id=0, data_pattern=None, id_pattern=None):        """        Send packets through the FIFO        Args:            count: Number of packets to send            base_data: Base value for data (incremented for each packet)            base_id: Base value for ID field (if used)            data_pattern: Optional function to generate data values            id_pattern: Optional function to generate ID values        Returns:            List of sent packets        """        sent_packets = []        for i in range(count):            # Create packet            pkt = FIFOPacket(self.field_config)            # Set data based on pattern or increment            if data_pattern:                pkt.data = data_pattern(i)            else:                pkt.data = (base_data + i) & ((1 << self.DATA_WIDTH) - 1)  # Mask to DATA_WIDTH bits            # Set ID field if we have one and ID_WIDTH > 0            if self.ID_WIDTH > 0 and hasattr(pkt, 'id'):                if id_pattern:                    pkt.id = id_pattern(i)                else:                    pkt.id = (base_id + i) & ((1 << self.ID_WIDTH) - 1)  # Mask to ID_WIDTH bits            # Send packet            await self.master.send(pkt)            # Store packet for verification            sent_packets.append(pkt)            # Log every N packets            if (i + 1) % 20 == 0 or i == 0 or i == count - 1:                self.log.info(f"Sent {i+1}/{count} packets")        return sent_packets    def add_expected_packets_to_scoreboard(self, packets):        """Add expected packets to the scoreboard"""        for pkt in packets:            self.scoreboard.add_expected_packet(pkt)    def add_actual_packets_to_scoreboard(self):        """Add actual packets from the read monitor to the scoreboard"""        while self.read_monitor.observed_queue:            pkt = self.read_monitor.observed_queue.popleft()            self.scoreboard.add_actual_packet(pkt)    def check_scoreboard(self):        """Check the scoreboard for errors"""        errors = self.scoreboard.report()        self.total_errors += errors        if errors > 0:            self.log.error(f"Scoreboard found {errors} errors")        else:            self.log.info("Scoreboard verification passed")        return errors    async def run_simple_test(self, packet_count=40):        """        Run a simple test with sequential data        Args:            packet_count: Number of packets to send        Returns:            True if test passed, False if failed        """        self.log.info(f"Starting simple test with {packet_count} packets")        # Reset system        await self.assert_reset()        await self.wait_clocks('i_clk', 10)        await self.deassert_reset()        await self.wait_clocks('i_clk', 10)        # Clear the scoreboard before starting        self.scoreboard.clear()        # Send packets        sent_packets = await self.send_packets(packet_count, base_data=0x100)        # Add expected packets to scoreboard        self.add_expected_packets_to_scoreboard(sent_packets)        # Wait for master to finish transmitting        await self.wait_for_master_idle()        self.log.info("Master finished sending")        # Wait for expected outputs        await self.wait_for_expected_outputs(packet_count)        # Add received packets to scoreboard        self.add_actual_packets_to_scoreboard()        # Wait a bit to ensure all packets have been processed        await self.wait_clocks('i_clk', 100)        # Check scoreboard        errors = self.check_scoreboard()        return errors == 0    async def run_pattern_test(self, patterns=None):        """        Run a test with specific data patterns        Args:            patterns: List of data patterns to send (defaults to standard test patterns)        Returns:            True if test passed, False if failed        """        # Define default test patterns if none provided        if patterns is None:            patterns = [                0x00000000,              # All zeros                0xFFFFFFFF & ((1 << self.DATA_WIDTH) - 1),  # All ones (masked to DATA_WIDTH)                0x55555555 & ((1 << self.DATA_WIDTH) - 1),  # 0101...                0xAAAAAAAA & ((1 << self.DATA_WIDTH) - 1),  # 1010...                0x33333333 & ((1 << self.DATA_WIDTH) - 1),  # 0011...                0xCCCCCCCC & ((1 << self.DATA_WIDTH) - 1),  # 1100...                0x0F0F0F0F & ((1 << self.DATA_WIDTH) - 1),  # 00001111...                0xF0F0F0F0 & ((1 << self.DATA_WIDTH) - 1),  # 11110000...                0x00FF00FF & ((1 << self.DATA_WIDTH) - 1),  # 00000000 11111111...                0xFF00FF00 & ((1 << self.DATA_WIDTH) - 1),  # 11111111 00000000...            ]        self.log.info(f"Starting pattern test with {len(patterns)} patterns")        # Reset system        await self.assert_reset()        await self.wait_clocks('i_clk', 10)        await self.deassert_reset()        await self.wait_clocks('i_clk', 10)        # Clear the scoreboard        self.scoreboard.clear()        # Send pattern packets        sent_packets = []        for i, pattern in enumerate(patterns):            # Create packet with pattern            pkt = FIFOPacket(self.field_config)            pkt.data = pattern            # Send packet            await self.master.send(pkt)            # Add to sent packets            sent_packets.append(pkt)            self.log.info(f"Sent pattern {i+1}/{len(patterns)}: 0x{pattern:X}")        # Add expected packets to scoreboard        self.add_expected_packets_to_scoreboard(sent_packets)        # Wait for master to finish transmitting        await self.wait_for_master_idle()        # Wait for expected outputs        await self.wait_for_expected_outputs(len(patterns))        # Add received packets to scoreboard        self.add_actual_packets_to_scoreboard()        # Wait a bit to ensure all packets have been processed        await self.wait_clocks('i_clk', 100)        # Check scoreboard        errors = self.check_scoreboard()        return errors == 0    async def run_timing_test(self, master_timing='moderate', slave_timing='moderate', packet_count=50):        """        Run a test with different timing configurations        Args:            master_timing: Timing profile for master ('fast', 'moderate', 'slow')            slave_timing: Timing profile for slave ('fast', 'moderate', 'slow')            packet_count: Number of packets to send        Returns:            True if test passed, False if failed        """        self.log.info(f"Starting timing test with master={master_timing}, slave={slave_timing}")        # Reset system        await self.assert_reset()        await self.wait_clocks('i_clk', 10)        await self.deassert_reset()        await self.wait_clocks('i_clk', 10)        # Set timing profiles        self.set_master_randomizer(master_timing)        self.set_slave_randomizer(slave_timing)        # Clear the scoreboard        self.scoreboard.clear()        # Send packets        sent_packets = await self.send_packets(packet_count, base_data=0x1000)        # Add expected packets to scoreboard        self.add_expected_packets_to_scoreboard(sent_packets)        # Wait for master to finish transmitting        await self.wait_for_master_idle()        self.log.info("Master finished sending")        # Wait for expected outputs        await self.wait_for_expected_outputs(packet_count)        # Add received packets to scoreboard        self.add_actual_packets_to_scoreboard()        # Wait a bit to ensure all packets have been processed        await self.wait_clocks('i_clk', 100)        # Check scoreboard        errors = self.check_scoreboard()        return errors == 0    async def run_stress_test(self, duration_clocks=10000):        """        Run a stress test with continuous data streams        Args:            duration_clocks: Duration of the test in clock cycles        Returns:            True if test passed, False if failed        """        self.log.info(f"Starting stress test for {duration_clocks} clock cycles")        # Reset system        await self.assert_reset()        await self.wait_clocks('i_clk', 10)        await self.deassert_reset()        await self.wait_clocks('i_clk', 10)        # Clear the scoreboard        self.scoreboard.clear()        # Set randomizers for fast throughput        self.set_master_randomizer('fast')        self.set_slave_randomizer('fast')        # Start packet generation task - large number to ensure continuous flow        task = cocotb.start_soon(self.send_packets(500, base_data=0x100))        # Wait for specified duration        await self.wait_clocks('i_clk', duration_clocks)        # Wait for task to complete        sent_packets = await task        # Add expected packets to scoreboard        self.add_expected_packets_to_scoreboard(sent_packets)        # Wait for master to finish transmitting        await self.wait_for_master_idle()        # Allow time for all packets to be processed        await self.wait_clocks('i_clk', 500)        # Add received packets to scoreboard        self.add_actual_packets_to_scoreboard()        # Check the scoreboard        errors = self.check_scoreboard()        return errors == 0    async def run_overflow_test(self):        """        Test FIFO overflow handling by writing more data than FIFO depth        and then reading it all out.        Returns:            True if test passed, False if failed        """        self.log.info(f"Starting overflow test (FIFO depth: {self.DEPTH})")        # Reset system        await self.assert_reset()        await self.wait_clocks('i_clk', 10)        await self.deassert_reset()        await self.wait_clocks('i_clk', 10)        # Clear the scoreboard        self.scoreboard.clear()        # Set master to fast and slave to slow to encourage overflow        self.set_master_randomizer('fast')        self.set_slave_randomizer('slow')        # Send 2x the FIFO depth to guarantee overflow        packet_count = self.DEPTH * 2        # Send packets but don't await them        send_task = cocotb.start_soon(self.send_packets(packet_count, base_data=0x300))        # Wait for a period to allow FIFO to fill up        await self.wait_clocks('i_clk', self.DEPTH * 2)        # Check if full signal has been asserted (should happen)        full_asserted = self.dut.o_wr_full.value == 1        if full_asserted:            self.log.info("FIFO full signal asserted as expected")        else:            self.log.warning("FIFO full signal not asserted when expected")        # Now set slave to fast to drain the FIFO        self.set_slave_randomizer('fast')        # Wait for sending to complete        sent_packets = await send_task        # Add expected packets to scoreboard        self.add_expected_packets_to_scoreboard(sent_packets)        # Wait for master to finish transmitting        await self.wait_for_master_idle()        # Allow time for all packets to be processed        await self.wait_clocks('i_clk', 500)        # Check if empty signal has been asserted (should happen)        empty_asserted = self.dut.o_rd_empty.value == 1        if empty_asserted:            self.log.info("FIFO empty signal asserted as expected after draining")        else:            self.log.warning("FIFO empty signal not asserted when expected after draining")        # Add received packets to scoreboard        self.add_actual_packets_to_scoreboard()        # Check the scoreboard        errors = self.check_scoreboard()        return errors == 0 and full_asserted    async def run_underflow_test(self):        """        Test FIFO underflow handling by attempting to read from an empty FIFO.        Returns:            True if test passed, False if failed        """        self.log.info("Starting underflow test")        # Reset system        await self.assert_reset()        await self.wait_clocks('i_clk', 10)        await self.deassert_reset()        await self.wait_clocks('i_clk', 10)        # Clear the scoreboard        self.scoreboard.clear()        # Check if empty signal is asserted after reset (should be)        empty_asserted = self.dut.o_rd_empty.value == 1        if empty_asserted:            self.log.info("FIFO empty signal asserted after reset as expected")        else:            self.log.error("FIFO empty signal not asserted after reset")            return False        # Try to force a read when empty by setting read signal        self.dut.i_read.value = 1        # Wait a few cycles        await self.wait_clocks('i_clk', 5)        # Set read back to 0        self.dut.i_read.value = 0        # Now write a few packets        packet_count = 5        sent_packets = await self.send_packets(packet_count, base_data=0x400)        # Add expected packets to scoreboard        self.add_expected_packets_to_scoreboard(sent_packets)        # Wait for master to finish transmitting        await self.wait_for_master_idle()        # Check if empty signal has been deasserted (FIFO not empty anymore)        empty_deasserted = self.dut.o_rd_empty.value == 0        if empty_deasserted:            self.log.info("FIFO empty signal deasserted after writes as expected")        else:            self.log.error("FIFO empty signal still asserted after writes")            return False        # Read out all packets        await self.wait_for_expected_outputs(packet_count)        # Add received packets to scoreboard        self.add_actual_packets_to_scoreboard()        # Check if empty signal is asserted again after reading all packets        await self.wait_clocks('i_clk', 5)  # Wait for empty to update        empty_asserted_after = self.dut.o_rd_empty.value == 1        if empty_asserted_after:            self.log.info("FIFO empty signal asserted after reading all packets as expected")        else:            self.log.error("FIFO empty signal not asserted after reading all packets")            return False        # Check the scoreboard        errors = self.check_scoreboard()        return errors == 0