"""
Simplified FIFO Signal Mapping - Single Read Data Interface

Based on the clean fifo_sync.sv RTL that has only one o_rd_data output.
The REGISTERED parameter is internal to the RTL - from BFM perspective, 
there's always just one consistent read data signal.

This eliminates the need for mode-aware data signal resolution!
"""
from typing import Dict, List, Optional, Any, Union


# Standard FIFO modes (kept for parameter passing to RTL)
FIFO_VALID_MODES = ['fifo_mux', 'fifo_flop']

# Simplified base signal patterns - no more mux vs flop data patterns!
FIFO_BASE_PATTERNS = {
    # Write-side patterns (for masters and write monitors)
    'write_base': [
        '{in_prefix}write',                   # i_write
        '{in_prefix}{bus_name}_write',        # i_e_write (with bus_name)
        '{in_prefix}{bus_name}write'          # fallback without underscore
    ],
    'wr_data_base': [
        '{in_prefix}wr_data',                 # i_wr_data
        '{in_prefix}data',                    # i_data
        '{in_prefix}{bus_name}_wr_data',      # i_e_wr_data (with bus_name)
        '{in_prefix}{bus_name}_data',         # i_e_data (with bus_name)
        '{in_prefix}{bus_name}wr_data',       # fallback without underscore
        '{in_prefix}{bus_name}data'           # fallback
    ],
    'wr_field_base': [
        '{in_prefix}{field_name}',            # i_data0, i_data1, etc.
        '{in_prefix}{bus_name}_{field_name}', # i_e_data0
        '{in_prefix}{bus_name}{field_name}'   # fallback
    ],
    'full_base': [
        '{out_prefix}wr_full',                # o_wr_full
        '{out_prefix}full',                   # o_full (alternative)
        '{out_prefix}{bus_name}_wr_full',     # o_e_wr_full (with bus_name)
        '{out_prefix}{bus_name}wr_full',      # fallback without underscore
        '{out_prefix}{bus_name}_full',        # o_e_full (alternative with bus_name)
        '{out_prefix}{bus_name}full'          # fallback
    ],
    
    # Read-side patterns (for slaves and read monitors) - SIMPLIFIED!
    'read_base': [
        '{in_prefix}read',                    # i_read
        '{in_prefix}{bus_name}_read',         # i_e_read (with bus_name)
        '{in_prefix}{bus_name}read'           # fallback without underscore
    ],
    'rd_data_base': [
        '{out_prefix}rd_data',                # o_rd_data (single output!)
        '{out_prefix}data',                   # o_data
        '{out_prefix}{bus_name}_rd_data',     # o_e_rd_data (with bus_name)
        '{out_prefix}{bus_name}_data',        # o_e_data (with bus_name)
        '{out_prefix}{bus_name}rd_data',      # fallback without underscore
        '{out_prefix}{bus_name}data'          # fallback
    ],
    'rd_field_base': [
        '{out_prefix}{field_name}',           # o_data0, o_data1, etc.
        '{out_prefix}{bus_name}_{field_name}',# o_e_data0
        '{out_prefix}{bus_name}{field_name}'  # fallback
    ],
    'empty_base': [
        '{out_prefix}rd_empty',               # o_rd_empty
        '{out_prefix}empty',                  # o_empty (alternative)
        '{out_prefix}{bus_name}_rd_empty',    # o_e_rd_empty (with bus_name)
        '{out_prefix}{bus_name}_empty',       # o_e_empty (with bus_name)
        '{out_prefix}{bus_name}rd_empty',     # fallback without underscore
        '{out_prefix}{bus_name}empty'         # fallback
    ]
}

# Much simpler signal mapping - no mode-aware complexity!
PROTOCOL_SIGNAL_CONFIGS = {
    'fifo_master': {
        'signal_map': {
            'i_write': FIFO_BASE_PATTERNS['write_base'],
            'o_wr_full': FIFO_BASE_PATTERNS['full_base']
        },
        'optional_signal_map': {
            # No mode-aware patterns needed - RTL handles timing internally
            'multi_sig_false': FIFO_BASE_PATTERNS['wr_data_base'],
            'multi_sig_true': FIFO_BASE_PATTERNS['wr_field_base']
        }
    },

    'fifo_slave': {
        'signal_map': {
            'i_read': FIFO_BASE_PATTERNS['read_base'],
            'o_rd_empty': FIFO_BASE_PATTERNS['empty_base']
        },
        'optional_signal_map': {
            # Single read data pattern - no more mux vs flop complexity!
            'multi_sig_false': FIFO_BASE_PATTERNS['rd_data_base'],
            'multi_sig_true': FIFO_BASE_PATTERNS['rd_field_base']
        }
    }

    # Note: No special monitor configurations needed!
    # Write monitors use 'fifo_master', read monitors use 'fifo_slave'
}


class SignalResolver:
    """
    Simplified signal resolver for clean FIFO RTL interface.
    
    Much simpler now that there's only one read data output in the RTL.
    No more mode-aware data signal resolution needed!
    """

    def __init__(self, protocol_type: str, dut, bus, log, component_name: str,
                field_config=None, multi_sig: bool = False,
                in_prefix: str = 'i_', out_prefix: str = 'o_',
                bus_name: str = '', pkt_prefix: str = '', mode: str = None,
                super_debug: bool = False):
        """
        Initialize signal resolver.

        Args:
            protocol_type: Protocol type ('fifo_master', 'fifo_slave')
            dut: Device under test
            bus: Bus object from BusDriver/BusMonitor
            log: Logger instance
            component_name: Component name for error messages
            field_config: Field configuration (required for multi_sig=True)
            multi_sig: Whether using multi-signal mode
            in_prefix: Input signal prefix
            out_prefix: Output signal prefix
            bus_name: Bus/channel name
            pkt_prefix: Packet field prefix (unused but kept for compatibility)
            mode: FIFO mode (kept for RTL parameter, not used in signal resolution)
            super_debug: Enable detailed signal resolution debugging
        """
        self.protocol_type = protocol_type
        self.dut = dut
        self.bus = bus
        self.log = log
        self.component_name = component_name
        self.field_config = field_config
        self.multi_sig = multi_sig
        self.mode = mode  # Kept for RTL parameter but not used in signal resolution
        self.super_debug = super_debug

        # Validate protocol type
        if protocol_type not in PROTOCOL_SIGNAL_CONFIGS:
            available = list(PROTOCOL_SIGNAL_CONFIGS.keys())
            raise ValueError(f"Unknown protocol type '{protocol_type}'. Available: {available}")

        # Get protocol configuration
        self.config = PROTOCOL_SIGNAL_CONFIGS[protocol_type]

        # Validate field_config for multi_sig mode
        if multi_sig and not field_config:
            raise ValueError(f"field_config is required when multi_sig=True for {component_name}")

        # Store substitution variables
        self.substitution_vars = {
            'in_prefix': in_prefix,
            'out_prefix': out_prefix,
            'bus_name': bus_name,
        }

        # Storage for resolved signals
        self.resolved_signals = {}
        self.missing_signals = []
        self.fallback_used = {}

        # Prepare signal lists for cocotb Bus initialization
        self._signals, self._optional_signals = self._prepare_signal_lists()

    def _prepare_signal_lists(self):
        """Prepare _signals and _optional_signals lists - MUCH SIMPLER now!"""
        _signals = []
        _optional_signals = []

        # Add required signals
        for logical_name, patterns in self.config['signal_map'].items():
            signal_name = self._select_best_pattern_for_bus_init(patterns)
            _signals.append(signal_name)

        # Add optional signals - simplified!
        optional_map = self.config.get('optional_signal_map', {})
        mode_key = 'multi_sig_true' if self.multi_sig else 'multi_sig_false'
        
        if mode_key in optional_map:
            patterns = optional_map[mode_key]
            
            if self.multi_sig:
                # Multi-signal mode: add individual field signals
                for field_name in self.field_config.field_names():
                    signal_name = self._select_best_pattern_for_bus_init(patterns, field_name=field_name)
                    _optional_signals.append(signal_name)
            else:
                # Single signal mode: add data signal
                signal_name = self._select_best_pattern_for_bus_init(patterns)
                _optional_signals.append(signal_name)

        if self.super_debug:
            self.log.info(f"{self.component_name}: Signal preparation (protocol='{self.protocol_type}') - "
                            f"_signals: {_signals}, _optional_signals: {_optional_signals}")

        return _signals, _optional_signals

    def _resolve_required_signals(self):
        """Resolve all required signals from signal_map."""
        for logical_name, patterns in self.config['signal_map'].items():
            signal_obj = self._try_signal_patterns(logical_name, patterns, required=True)
            self.resolved_signals[logical_name] = signal_obj

    def _resolve_optional_signals(self):
        """Resolve optional signals - simplified!"""
        optional_map = self.config.get('optional_signal_map', {})
        mode_key = 'multi_sig_true' if self.multi_sig else 'multi_sig_false'
        
        if mode_key in optional_map:
            patterns = optional_map[mode_key]
            
            if self.multi_sig:
                # Multi-signal mode: resolve individual field signals
                for field_name in self.field_config.field_names():
                    logical_name = f'field_{field_name}_sig'
                    signal_obj = self._try_signal_patterns(logical_name, patterns,
                                                            field_name=field_name, required=False)
                    self.resolved_signals[logical_name] = signal_obj
            else:
                # Single signal mode: resolve data signal
                signal_obj = self._try_signal_patterns('data_sig', patterns, required=False)
                self.resolved_signals['data_sig'] = signal_obj

    def _substitute_variables(self, pattern: str, field_name: str = None) -> str:
        """Substitute variables in a signal name pattern."""
        format_vars = self.substitution_vars.copy()
        if field_name:
            format_vars['field_name'] = field_name

        substituted = pattern.format(**format_vars)

        if self.super_debug:
            self.log.info(f"{self.component_name}: SUBSTITUTE ::{pattern}:: -> ::{substituted}::")

        return substituted

    def _try_signal_patterns(self, logical_name: str, patterns: List[str],
                        field_name: str = None, required: bool = True) -> Optional[Any]:
        """Try multiple signal patterns until one is found on the bus."""
        tried_names = []

        for i, pattern in enumerate(patterns):
            signal_name = self._substitute_variables(pattern, field_name)
            tried_names.append(signal_name)

            if self.super_debug:
                self.log.info(f"{self.component_name}: ATTEMPT_{i+1} ::{signal_name}:: for {logical_name}")

            # Check if signal exists on bus
            if hasattr(self.bus, signal_name):
                signal_obj = getattr(self.bus, signal_name)

                if signal_obj is not None:
                    # Track if this was a fallback
                    if len(tried_names) > 1:
                        self.fallback_used[logical_name] = signal_name
                        self.log.info(f"{self.component_name}: Using fallback signal '{signal_name}' for {logical_name}")
                    else:
                        self.log.debug(f"{self.component_name}: Found signal '{signal_name}' for {logical_name}")
                    return signal_obj

        # No signal found
        self.missing_signals.append((logical_name, tried_names, required))

        if required:
            available_signals = [s for s in dir(self.bus) if not s.startswith('_')]
            self.log.error(f"{self.component_name}: Available signals: {sorted(available_signals)}")
            self.log.error(f"{self.component_name}: Required signal '{logical_name}' not found. "
                        f"Tried: {', '.join(tried_names)}")
            raise ValueError(f"Required signal '{logical_name}' not found. Tried: {', '.join(tried_names)}")
        else:
            self.log.warning(f"{self.component_name}: Optional signal '{logical_name}' not found. "
                        f"Tried: {', '.join(tried_names)}")
            return None

    def _select_best_pattern_for_bus_init(self, patterns, field_name=None):
        """Select the best pattern for bus initialization based on bus_name."""
        bus_name = self.substitution_vars['bus_name']

        # If bus_name is empty, prefer patterns that don't use {bus_name}
        if not bus_name:
            for pattern in patterns:
                if '{bus_name}' not in pattern:
                    return self._substitute_variables(pattern, field_name)

        # If bus_name is not empty, prefer patterns that do use {bus_name}
        else:
            for pattern in patterns:
                if '{bus_name}' in pattern:
                    return self._substitute_variables(pattern, field_name)

        # Fallback to first pattern
        return self._substitute_variables(patterns[0], field_name)

    def _resolve_all_signals(self):
        """Resolve all signals for this protocol."""
        self.log.debug(f"{self.component_name}: Resolving signals for protocol '{self.protocol_type}', "
                        f"multi_sig={self.multi_sig}")

        # Resolve required signals
        self._resolve_required_signals()

        # Resolve optional signals
        self._resolve_optional_signals()

        # Log summary
        total_signals = len(self.resolved_signals)
        found_signals = sum(1 for sig in self.resolved_signals.values() if sig is not None)
        self.log.debug(f"{self.component_name}: Resolved {found_signals}/{total_signals} signals")

    def get_signal_lists(self):
        """Get the _signals and _optional_signals lists for cocotb Bus initialization."""
        return self._signals, self._optional_signals

    def _derive_attribute_name(self, logical_name: str) -> str:
        """Derive attribute name from logical signal name."""
        # Handle field signals
        if logical_name.startswith('field_') and logical_name.endswith('_sig'):
            return logical_name  # field_{field_name}_sig stays as-is

        # Handle data signal
        if logical_name == 'data_sig':
            return 'data_sig'

        # Handle control signals
        if logical_name == 'i_write':
            return 'write_sig'
        elif logical_name == 'o_wr_full':
            return 'full_sig'
        elif logical_name == 'i_read':
            return 'read_sig'
        elif logical_name == 'o_rd_empty':
            return 'empty_sig'
        else:
            # Fallback: use logical name as-is
            return logical_name

    def apply_to_component(self, component):
        """Apply resolved signals to component as attributes."""
        # Resolve signals now if not done yet
        if not self.resolved_signals:
            if self.bus is None:
                raise ValueError(f"{self.component_name}: Bus must be set before applying signals")
            self._resolve_all_signals()

        # Apply signal mappings
        for logical_name, signal_obj in self.resolved_signals.items():
            attr_name = self._derive_attribute_name(logical_name)
            setattr(component, attr_name, signal_obj)
            if signal_obj is not None:
                self.log.debug(f"{self.component_name}: Set {attr_name} = {logical_name} signal")
            else:
                self.log.debug(f"{self.component_name}: Set {attr_name} = None (missing signal)")

    def get_signal(self, logical_name: str):
        """Get a resolved signal by logical name."""
        return self.resolved_signals.get(logical_name)

    def has_signal(self, logical_name: str) -> bool:
        """Check if a signal was found and is not None."""
        return self.resolved_signals.get(logical_name) is not None

    def get_stats(self) -> Dict[str, Any]:
        """Get statistics about signal resolution."""
        total_signals = len(self.resolved_signals)
        resolved_signals = sum(1 for sig in self.resolved_signals.values() if sig is not None)
        missing_required = sum(1 for _, _, required in self.missing_signals if required)
        missing_optional = sum(1 for _, _, required in self.missing_signals if not required)

        stats = {
            'protocol_type': self.protocol_type,
            'multi_sig_mode': self.multi_sig,
            'mode': self.mode,
            'total_signals': total_signals,
            'resolved_signals': resolved_signals,
            'missing_required': missing_required,
            'missing_optional': missing_optional,
            'resolution_rate': (resolved_signals / total_signals * 100) if total_signals > 0 else 100
        }

        # Add fallback usage info
        if self.fallback_used:
            stats['fallbacks_used'] = len(self.fallback_used)
            stats['fallback_details'] = self.fallback_used.copy()

        return stats
