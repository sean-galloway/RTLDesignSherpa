#!/usr/bin/env python3
import os
import re
import subprocess
import shutil
import tempfile
import logging
import argparse
from pathlib import Path
from zipfile import ZipFile

def extract_links_from_markdown(md_text):
    return re.findall(r'^\s*\[.*?\]\((.*?)\)\s*$', md_text, re.MULTILINE)

def demote_headings(md_text, level_shift=1):
    def replacer(match):
        hashes = match.group(1)
        return '#' * (len(hashes) + level_shift) + match.group(2)
    return re.sub(r'^(#{1,6})(.*?)$', replacer, md_text, flags=re.MULTILINE)

def collect_markdown(index_path, collected=None, depth=0):
    if collected is None:
        collected = set()
    index_path = Path(index_path).resolve()
    if index_path in collected:
        return ""
    collected.add(index_path)

    with open(index_path, encoding='utf-8') as f:
        lines = f.readlines()

    base_dir = index_path.parent
    output_lines = []
    title = None

    for line in lines:
        if depth == 0 and not title:
            match = re.match(r'^#\s+(.*)', line)
            if match:
                title = match.group(1).strip()

        match = re.match(r'^\s*\[.*?\]\((.*?)\)\s*$', line)
        if match:
            included_file = base_dir / match.group(1).strip()
            if included_file.exists():
                included_text = collect_markdown(included_file, collected, depth + 1)
                included_text = demote_headings(included_text, level_shift=1)
                output_lines.append(included_text)
            else:
                output_lines.append(f'<!-- Missing file: {included_file} -->\n')
        else:
            output_lines.append(line)

    if depth == 0:
        return "".join(output_lines), title
    else:
        return "".join(output_lines)

def convert_dotx_to_docx(dotx_path, output_path):
    with tempfile.TemporaryDirectory() as tmpdir:
        with ZipFile(dotx_path, 'r') as zip_ref:
            zip_ref.extractall(tmpdir)
        content_types_path = Path(tmpdir) / "[Content_Types].xml"
        with open(content_types_path, 'r', encoding='utf-8') as f:
            content = f.read()
        content = content.replace(
            "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"
        )
        with open(content_types_path, 'w', encoding='utf-8') as f:
            f.write(content)
        shutil.make_archive(output_path.with_suffix(""), 'zip', tmpdir)
    os.rename(output_path.with_suffix(".zip"), output_path)

def write_combined_markdown(text, path):
    with open(path, 'w', encoding='utf-8') as f:
        f.write(text)

def insert_title_page(title):
    abstract = "<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>"
    yaml_block = f"""---
title: "{title}"
author: "Generated by md_to_docx.py"
date: today
abstract: '{abstract}'
---\n\n"""
    return yaml_block

def run_pandoc(input_path, output_path, reference_doc=None, pdf=False, toc=False):
    cmd = ['pandoc', str(input_path), '-o', str(output_path), '-s']
    if reference_doc:
        cmd += ['--reference-doc', str(reference_doc)]
    if toc:
        cmd.append('--toc')
    subprocess.run(cmd, check=True)

    if pdf:
        pdf_path = output_path.with_suffix('.pdf')
        subprocess.run(['pandoc', str(input_path), '-o', str(pdf_path), '-s'], check=True)

def main():
    parser = argparse.ArgumentParser(description="Markdown to DOCX compiler with template and TOC support")
    parser.add_argument('input', type=Path, help="Path to the index markdown file")
    parser.add_argument('-t', '--template', type=Path, help="Path to DOTX or DOCX reference file")
    parser.add_argument('-o', '--output', type=Path, default=Path("output.docx"), help="Output DOCX path")
    parser.add_argument('--title-page', action='store_true', help="Add a title page from the first heading")
    parser.add_argument('--toc', action='store_true', help="Include table of contents")
    parser.add_argument('--pdf', action='store_true', help="Also export to PDF")
    parser.add_argument('--debug-md', action='store_true', help="Output combined markdown to debug.md")
    parser.add_argument('--verbose', '-v', action='store_true', help="Verbose logging")
    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)

    logging.info(f"Collecting markdown from: {args.input}")
    combined_md, title = collect_markdown(args.input)

    if args.title_page and title:
        combined_md = insert_title_page(title) + combined_md

    temp_md_path = Path(tempfile.mkstemp(suffix=".md")[1])
    write_combined_markdown(combined_md, temp_md_path)

    reference_docx = None
    if args.template:
        if args.template.suffix == '.dotx':
            reference_docx = args.template.with_suffix('.docx')
            logging.info(f"Converting {args.template} to {reference_docx}")
            convert_dotx_to_docx(args.template, reference_docx)
        else:
            reference_docx = args.template

    if args.debug_md:
        debug_path = Path("debug.md")
        logging.info(f"Writing debug markdown to {debug_path}")
        write_combined_markdown(combined_md, debug_path)

    logging.info(f"Generating DOCX to {args.output}")
    run_pandoc(temp_md_path, args.output, reference_doc=reference_docx, pdf=args.pdf, toc=args.toc)

    logging.info("Done.")

if __name__ == '__main__':
    main()